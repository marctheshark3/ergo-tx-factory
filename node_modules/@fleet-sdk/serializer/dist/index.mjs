import { ensureBigInt, _0n, _128n, isEmpty, assert, first, last, isUndefined, isDefined, some, byteSizeOf, _7n, _1n, _63n, _127n } from '@fleet-sdk/common';
import { ensureBytes, hex, blake2b256 } from '@fleet-sdk/crypto';

// src/coders/sigmaByteReader.ts
function hexToBigInt(hex6) {
  const value = BigInt(hex6.length % 2 ? `0x0${hex6}` : `0x${hex6}`);
  const highByte = Number.parseInt(hex6.slice(0, 2), 16);
  if (128 & highByte) return -negateAndMask(value);
  return value;
}
function bigIntToHex(value) {
  const positive = value >= _0n;
  let hex6 = (positive ? value : negateAndMask(value)).toString(16);
  if (hex6.length % 2) hex6 = `0${hex6}`;
  if (positive && 128 & Number.parseInt(hex6.slice(0, 2), 16)) {
    return `00${hex6}`;
  }
  return hex6;
}
function negateAndMask(value) {
  let val = value;
  const negative = val < _0n;
  if (negative) val = -val;
  const bits = val.toString(2);
  let len = bits.length;
  const mod = len % 8;
  if (mod > 0) {
    len += 8 - mod;
  } else if (negative && first(bits) === "1" && bits.indexOf("1", 1) !== -1) {
    len += 8;
  }
  const mask = (1n << BigInt(len)) - 1n;
  return (~val & mask) + 1n;
}
function writeVLQ(writer, value) {
  if (value === 0) return writer.write(0);
  if (value < 0) {
    throw new RangeError(
      "Variable Length Quantity not supported for negative numbers."
    );
  }
  let val = value;
  do {
    let lower7bits = val & 127;
    val >>= 7;
    if (val > 0) lower7bits |= 128;
    writer.write(lower7bits);
  } while (val > 0);
  return writer;
}
function readVLQ(reader) {
  if (reader.isEmpty) {
    return 0;
  }
  let value = 0;
  let shift = 0;
  let lower7bits = 0;
  do {
    lower7bits = reader.readByte();
    value |= (lower7bits & 127) << shift;
    shift += 7;
  } while ((lower7bits & 128) !== 0);
  return value;
}
function writeBigVLQ(writer, value) {
  if (value === _0n) return writer.write(0);
  if (value < _0n) {
    throw new RangeError(
      "Variable Length Quantity not supported for negative numbers"
    );
  }
  let val = value;
  do {
    let lower7bits = Number(val & _127n);
    val >>= _7n;
    if (val > 0) lower7bits |= 128;
    writer.write(lower7bits);
  } while (val > 0);
  return writer;
}
function readBigVLQ(reader) {
  if (reader.isEmpty) return _0n;
  let value = _0n;
  let shift = _0n;
  let lower7bits = _0n;
  do {
    lower7bits = BigInt(reader.readByte());
    value |= (lower7bits & _127n) << shift;
    shift += _7n;
  } while ((lower7bits & _128n) !== _0n);
  return value;
}
function estimateVLQSize(value) {
  let size = 0;
  let val = value;
  if (typeof val === "number") {
    do {
      size++;
      val = Math.floor(val / 128);
    } while (val > 0);
    return size;
  }
  val = ensureBigInt(val);
  do {
    size++;
    val /= _128n;
  } while (val > _0n);
  return size;
}
function zigZagEncode(input) {
  return input << 1 ^ input >> 63;
}
function zigZagDecode(input) {
  return input >> 1 ^ -(input & 1);
}
function zigZagEncodeBigInt(input) {
  return input << _1n ^ input >> _63n;
}
function zigZagDecodeBigInt(input) {
  return input >> _1n ^ -(input & _1n);
}

// src/coders/sigmaByteReader.ts
var SigmaByteReader = class {
  #bytes;
  #cursor;
  get isEmpty() {
    return isEmpty(this.#bytes);
  }
  constructor(bytes) {
    this.#bytes = ensureBytes(bytes);
    this.#cursor = 0;
  }
  readBoolean() {
    return this.readByte() === 1;
  }
  readBits(length) {
    const bits = new Array(length);
    let bitOffset = 0;
    for (let i = 0; i < length; i++) {
      const bit = this.#bytes[this.#cursor] >> bitOffset++ & 1;
      bits[i] = bit === 1;
      if (bitOffset === 8) {
        bitOffset = 0;
        this.#cursor++;
      }
    }
    if (bitOffset > 0) this.#cursor++;
    return bits;
  }
  readByte() {
    return this.#bytes[this.#cursor++];
  }
  readBytes(length) {
    return this.#bytes.subarray(this.#cursor, this.#cursor += length);
  }
  readVlq() {
    return readVLQ(this);
  }
  readShort() {
    return Number(zigZagDecode(readVLQ(this)));
  }
  readInt() {
    return Number(this.readLong());
  }
  readLong() {
    return zigZagDecodeBigInt(readBigVLQ(this));
  }
  readBigInt() {
    const len = readVLQ(this);
    return hexToBigInt(hex.encode(this.readBytes(len)));
  }
};
var SigmaByteWriter = class {
  #bytes;
  #cursor;
  get length() {
    return this.#cursor;
  }
  constructor(length) {
    this.#bytes = new Uint8Array(length);
    this.#cursor = 0;
  }
  writeBoolean(value) {
    this.write(value === true ? 1 : 0);
    return this;
  }
  writeVLQ(value) {
    return writeVLQ(this, value);
  }
  writeBigVLQ(value) {
    return writeBigVLQ(this, value);
  }
  writeShort(value) {
    this.writeVLQ(zigZagEncode(value));
    return this;
  }
  writeInt(value) {
    this.writeLong(BigInt(value));
    return this;
  }
  writeLong(value) {
    this.writeBigVLQ(zigZagEncodeBigInt(value));
    return this;
  }
  write(byte) {
    this.#bytes[this.#cursor++] = byte;
    return this;
  }
  writeBytes(bytes) {
    this.#bytes.set(bytes, this.#cursor);
    this.#cursor += bytes.length;
    return this;
  }
  writeHex(bytesHex) {
    return this.writeBytes(hex.decode(bytesHex));
  }
  writeBits(bits) {
    let bitOffset = 0;
    for (let i = 0; i < bits.length; i++) {
      if (bits[i]) {
        this.#bytes[this.#cursor] |= 1 << bitOffset++;
      } else {
        this.#bytes[this.#cursor] &= ~(1 << bitOffset++);
      }
      if (bitOffset === 8) {
        bitOffset = 0;
        this.#cursor++;
      }
    }
    if (bitOffset > 0) this.#cursor++;
    return this;
  }
  writeBigInt(value) {
    const hex6 = bigIntToHex(value);
    return this.writeVLQ(hex6.length / 2).writeHex(hex6);
  }
  writeChecksum(length = 4, hashFn = blake2b256) {
    const hash = hashFn(this.toBytes());
    return this.writeBytes(length ? hash.subarray(0, length) : hash);
  }
  encode(coder) {
    return coder.encode(this.toBytes());
  }
  toBytes() {
    if (this.#cursor === this.#bytes.length) return this.#bytes;
    return this.#bytes.subarray(0, this.#cursor);
  }
};

// src/types/base.ts
var SType = class {
  coerce(data) {
    return data;
  }
};
var SMonomorphicType = class extends SType {
  get embeddable() {
    return false;
  }
};
var SPrimitiveType = class extends SMonomorphicType {
  get embeddable() {
    return true;
  }
};
var SGenericType = class extends SType {
  #internalType;
  constructor(type) {
    super();
    this.#internalType = type;
  }
  get elementsType() {
    return this.#internalType;
  }
  get embeddable() {
    return false;
  }
};
var SBoolType = class extends SPrimitiveType {
  get code() {
    return 1;
  }
  toString() {
    return "SBool";
  }
};
var SByteType = class extends SPrimitiveType {
  get code() {
    return 2;
  }
  toString() {
    return "SByte";
  }
};
var SShortType = class extends SPrimitiveType {
  get code() {
    return 3;
  }
  toString() {
    return "SShort";
  }
};
var SIntType = class extends SPrimitiveType {
  get code() {
    return 4;
  }
  toString() {
    return "SInt";
  }
};
var SLongType = class extends SPrimitiveType {
  get code() {
    return 5;
  }
  coerce(data) {
    return ensureBigInt(data);
  }
  toString() {
    return "SLong";
  }
};
var SBigIntType = class extends SPrimitiveType {
  get code() {
    return 6;
  }
  coerce(data) {
    return ensureBigInt(data);
  }
  toString() {
    return "SBigInt";
  }
};
var SGroupElementType = class extends SPrimitiveType {
  get code() {
    return 7;
  }
  coerce(data) {
    return typeof data === "string" ? hex.decode(data) : data;
  }
  toString() {
    return "SGroupElement";
  }
};
var SSigmaPropType = class extends SPrimitiveType {
  get code() {
    return 8;
  }
  toString() {
    return "SSigmaProp";
  }
};

// src/types/monomorphics.ts
var SUnitType = class extends SMonomorphicType {
  get code() {
    return 98;
  }
  toString() {
    return "SUnit";
  }
};

// src/types/descriptors.ts
var constructorCode = Object.freeze({
  embeddable: 0,
  simpleColl: 1,
  nestedColl: 2,
  option: 3,
  optionCollection: 4,
  pairOne: 5,
  pairTwo: 6,
  symmetricPair: 7,
  genericTuple: 8
});
var MAX_PRIMITIVE_TYPE_CODE = 11;
var PRIMITIVE_TYPE_RANGE = MAX_PRIMITIVE_TYPE_CODE + 1;
var typeCodeOf = (ctor) => PRIMITIVE_TYPE_RANGE * ctor;
var collDescriptor = Object.freeze({
  code: typeCodeOf(constructorCode.simpleColl),
  embeddable: false,
  simpleCollTypeCode: typeCodeOf(constructorCode.simpleColl),
  nestedCollTypeCode: typeCodeOf(constructorCode.nestedColl)
});
var tupleDescriptor = Object.freeze({
  code: typeCodeOf(constructorCode.pairOne),
  embeddable: false,
  pairOneTypeCode: typeCodeOf(constructorCode.pairOne),
  pairTwoTypeCode: typeCodeOf(constructorCode.pairTwo),
  tripleTypeCode: typeCodeOf(constructorCode.pairTwo),
  symmetricPairTypeCode: typeCodeOf(constructorCode.symmetricPair),
  quadrupleTypeCode: typeCodeOf(constructorCode.symmetricPair),
  genericTupleTypeCode: typeCodeOf(constructorCode.genericTuple)
});
var descriptors = {
  bool: new SBoolType(),
  byte: new SByteType(),
  short: new SShortType(),
  int: new SIntType(),
  long: new SLongType(),
  bigInt: new SBigIntType(),
  groupElement: new SGroupElementType(),
  sigmaProp: new SSigmaPropType(),
  unit: new SUnitType(),
  coll: collDescriptor,
  tuple: tupleDescriptor
};
function isColl(type) {
  return type.code >= descriptors.coll.simpleCollTypeCode && type.code <= descriptors.coll.nestedCollTypeCode + MAX_PRIMITIVE_TYPE_CODE;
}
function isTuple(type) {
  return type.code >= descriptors.tuple.pairOneTypeCode && type.code <= descriptors.tuple.genericTupleTypeCode;
}
function getPrimitiveType(typeCode) {
  switch (typeCode) {
    case descriptors.bool.code:
      return descriptors.bool;
    case descriptors.byte.code:
      return descriptors.byte;
    case descriptors.short.code:
      return descriptors.short;
    case descriptors.int.code:
      return descriptors.int;
    case descriptors.long.code:
      return descriptors.long;
    case descriptors.bigInt.code:
      return descriptors.bigInt;
    case descriptors.groupElement.code:
      return descriptors.groupElement;
    case descriptors.sigmaProp.code:
      return descriptors.sigmaProp;
    default:
      throw new Error(
        `The type code '0x${typeCode.toString(16)}' is not a valid primitive type code.`
      );
  }
}
var SCollType = class extends SGenericType {
  get code() {
    return descriptors.coll.code;
  }
  coerce(elements) {
    if (this.elementsType.code === descriptors.byte.code && !(elements instanceof Uint8Array)) {
      return typeof elements === "string" ? hex.decode(elements) : Uint8Array.from(elements);
    }
    return elements.map((el) => this.elementsType.coerce(el));
  }
  toString() {
    return `SColl[${this.elementsType.toString()}]`;
  }
};
var STupleType = class extends SGenericType {
  get code() {
    return descriptors.tuple.code;
  }
  coerce(elements) {
    const output = new Array(elements.length);
    for (let i = 0; i < elements.length; i++) {
      output[i] = this.elementsType[i].coerce(elements[i]);
    }
    return output;
  }
  toString() {
    return `(${this.elementsType.map((el) => el.toString()).join(", ")})`;
  }
};
function monoProxy(ctor, cache, forceConstruction) {
  return new Proxy(ctor, {
    apply: (target, _, args) => {
      const instance = cache ?? new target();
      if (!forceConstruction && isEmpty(args)) return instance;
      return new SConstant(instance, ...args);
    }
  });
}
function genericProxy(ctor, handler) {
  return new Proxy(ctor, {
    apply: handler
  });
}
var SByte = monoProxy(SByteType, descriptors.byte);
var SBool = monoProxy(SBoolType, descriptors.bool);
var SShort = monoProxy(
  SShortType,
  descriptors.short
);
var SInt = monoProxy(SIntType, descriptors.int);
var SLong = monoProxy(
  SLongType,
  descriptors.long
);
var SBigInt = monoProxy(
  SBigIntType,
  descriptors.bigInt
);
var SGroupElement = monoProxy(SGroupElementType, descriptors.groupElement);
var SSigmaProp = monoProxy(
  SSigmaPropType,
  descriptors.sigmaProp
);
var SUnit = monoProxy(SUnitType, void 0, true);
var SColl = genericProxy(
  SCollType,
  (target, _, args) => {
    const [type, elements] = args;
    const elementsType = type();
    if (!elements) return () => new target(elementsType);
    return new SConstant(new target(elementsType), elements);
  }
);
var SPair = genericProxy(
  STupleType,
  (target, _, args) => {
    const [left, right] = args;
    if (typeof left === "function" && typeof right === "function") {
      return () => new target([left(), right()]);
    }
    if (left instanceof SConstant && right instanceof SConstant) {
      return new SConstant(new target([left.type, right.type]), [
        left.data,
        right.data
      ]);
    }
    throw new Error("Invalid tuple declaration.");
  }
);

// src/serializers/dataSerializer.ts
var GROUP_ELEMENT_LENGTH = 33;
var PROVE_DLOG_OP = 205;
var dataSerializer = {
  serialize(data, type, writer) {
    if (type.embeddable) {
      switch (type.code) {
        case descriptors.bool.code:
          return writer.writeBoolean(data);
        case descriptors.byte.code:
          return writer.write(data);
        case descriptors.short.code:
          return writer.writeShort(data);
        case descriptors.int.code:
          return writer.writeInt(data);
        case descriptors.long.code:
          return writer.writeLong(data);
        case descriptors.bigInt.code:
          return writer.writeBigInt(data);
        case descriptors.groupElement.code:
          return writer.writeBytes(data);
        case descriptors.sigmaProp.code: {
          const node = data;
          if (node.type === descriptors.groupElement) {
            writer.write(PROVE_DLOG_OP);
            return dataSerializer.serialize(node.data, node.type, writer);
          }
          throw Error(
            "Serialization error: SigmaProp operation not implemented."
          );
        }
      }
    }
    if (isColl(type)) {
      if (type.elementsType.code === descriptors.byte.code) {
        assert(
          data instanceof Uint8Array,
          `SColl[Byte] expected an UInt8Array, got ${typeof data}.`
        );
      } else {
        assert(
          Array.isArray(data),
          `SColl expected an array, got ${typeof data}.`
        );
      }
      writer.writeVLQ(data.length);
      switch (type.elementsType.code) {
        case descriptors.bool.code: {
          return writer.writeBits(data);
        }
        case descriptors.byte.code: {
          return writer.writeBytes(data);
        }
        default: {
          for (let i = 0; i < data.length; i++) {
            dataSerializer.serialize(data[i], type.elementsType, writer);
          }
          return writer;
        }
      }
    }
    if (isTuple(type)) {
      assert(
        Array.isArray(data),
        `STupleType serialization expected an array, got ${typeof data}.`
      );
      const len = type.elementsType.length;
      for (let i = 0; i < len; i++) {
        dataSerializer.serialize(data[i], type.elementsType[i], writer);
      }
      return writer;
    }
    if (type.code === descriptors.unit.code) return writer;
    throw Error(
      `Serialization error: '0x${type.code.toString(16)}' type not implemented.`
    );
  },
  deserialize(type, reader) {
    if (type.embeddable) {
      switch (type.code) {
        case descriptors.bool.code:
          return reader.readBoolean();
        case descriptors.byte.code:
          return reader.readByte();
        case descriptors.short.code:
          return reader.readShort();
        case descriptors.int.code:
          return reader.readInt();
        case descriptors.long.code:
          return reader.readLong();
        case descriptors.bigInt.code:
          return reader.readBigInt();
        case descriptors.groupElement.code:
          return reader.readBytes(GROUP_ELEMENT_LENGTH);
        case descriptors.sigmaProp.code: {
          if (reader.readByte() === PROVE_DLOG_OP) {
            return this.deserialize(descriptors.groupElement, reader);
          }
          break;
        }
      }
    } else {
      switch (type.code) {
        case descriptors.coll.code: {
          const length = reader.readVlq();
          const embeddedType = type.elementsType;
          switch (embeddedType.code) {
            case descriptors.bool.code:
              return reader.readBits(length);
            case descriptors.byte.code:
              return reader.readBytes(length);
            default: {
              const elements = new Array(length);
              for (let i = 0; i < length; i++) {
                elements[i] = this.deserialize(embeddedType, reader);
              }
              return elements;
            }
          }
        }
        case descriptors.tuple.code: {
          return type.elementsType.map(
            (t) => this.deserialize(t, reader)
          );
        }
        case descriptors.unit.code:
          return void 0;
      }
    }
    throw new Error(
      `Parsing error: '0x${type.code.toString(16)}' type not implemented.`
    );
  }
};
var typeSerializer = {
  serialize(type, writer) {
    if (type.embeddable) {
      writer.write(type.code);
    } else if (type.code === descriptors.unit.code) {
      writer.write(type.code);
    } else if (isColl(type)) {
      if (type.elementsType.embeddable) {
        writer.write(
          descriptors.coll.simpleCollTypeCode + type.elementsType.code
        );
      } else if (isColl(type.elementsType)) {
        const nestedColl = type.elementsType;
        if (nestedColl.elementsType.embeddable) {
          writer.write(
            descriptors.coll.nestedCollTypeCode + nestedColl.elementsType.code
          );
        } else {
          writer.write(descriptors.coll.simpleCollTypeCode);
          this.serialize(nestedColl, writer);
        }
      } else {
        writer.write(descriptors.coll.simpleCollTypeCode);
        this.serialize(type.elementsType, writer);
      }
    } else if (isTuple(type)) {
      switch (type.elementsType.length) {
        case 2: {
          const left = first(type.elementsType);
          const right = last(type.elementsType);
          if (left.embeddable) {
            if (left.code === right.code) {
              writer.write(descriptors.tuple.symmetricPairTypeCode + left.code);
            } else {
              writer.write(descriptors.tuple.pairOneTypeCode + left.code);
              this.serialize(right, writer);
            }
          } else if (right.embeddable) {
            writer.write(descriptors.tuple.pairTwoTypeCode + right.code);
            this.serialize(left, writer);
          } else {
            writer.write(descriptors.tuple.pairOneTypeCode);
            this.serialize(left, writer);
            this.serialize(right, writer);
          }
          return;
        }
        case 3:
          writer.write(descriptors.tuple.tripleTypeCode);
          break;
        case 4:
          writer.write(descriptors.tuple.quadrupleTypeCode);
          break;
        default: {
          const len = type.elementsType.length;
          assert(
            len >= 2 && len <= 255,
            "Invalid type: tuples must have between 2 and 255 items."
          );
          writer.write(descriptors.tuple.genericTupleTypeCode);
          writer.writeVLQ(len);
        }
      }
      for (let i = 0; i < type.elementsType.length; i++) {
        this.serialize(type.elementsType[i], writer);
      }
    } else {
      throw new Error("Serialization error: type not implemented.");
    }
  },
  deserialize(r) {
    const byte = r.readByte();
    assert(
      byte > 0,
      `Parsing Error: Unexpected type code '0x${byte.toString(16)}'`
    );
    if (byte < descriptors.tuple.genericTupleTypeCode) {
      const ctorCode = Math.floor(byte / PRIMITIVE_TYPE_RANGE);
      const embdCode = Math.floor(byte % PRIMITIVE_TYPE_RANGE);
      switch (ctorCode) {
        case constructorCode.embeddable: {
          return getPrimitiveType(embdCode);
        }
        case constructorCode.simpleColl: {
          const internal = embdCode === 0 ? this.deserialize(r) : getPrimitiveType(embdCode);
          return new SCollType(internal);
        }
        case constructorCode.nestedColl: {
          return new SCollType(new SCollType(getPrimitiveType(embdCode)));
        }
        case constructorCode.pairOne: {
          const internal = embdCode === 0 ? [this.deserialize(r), this.deserialize(r)] : [getPrimitiveType(embdCode), this.deserialize(r)];
          return new STupleType(internal);
        }
        case constructorCode.pairTwo: {
          const internal = embdCode === 0 ? [this.deserialize(r), this.deserialize(r), this.deserialize(r)] : [this.deserialize(r), getPrimitiveType(embdCode)];
          return new STupleType(internal);
        }
        case constructorCode.symmetricPair: {
          const internal = embdCode === 0 ? [
            this.deserialize(r),
            this.deserialize(r),
            this.deserialize(r),
            this.deserialize(r)
          ] : [getPrimitiveType(embdCode), getPrimitiveType(embdCode)];
          return new STupleType(internal);
        }
      }
    }
    switch (byte) {
      case descriptors.tuple.genericTupleTypeCode: {
        const len = r.readVlq();
        const wrapped = new Array(len);
        for (let i = 0; i < len; i++) {
          wrapped[i] = this.deserialize(r);
        }
        return new STupleType(wrapped);
      }
      case descriptors.unit.code: {
        return descriptors.unit;
      }
    }
    throw new Error("Not implemented.");
  }
};

// src/sigmaConstant.ts
var MAX_CONSTANT_LENGTH = 4096;
var SConstant = class _SConstant {
  #type;
  #data;
  constructor(type, data) {
    this.#type = type;
    this.#data = type.coerce(data);
  }
  static from(bytes) {
    assert(bytes.length > 0, "Empty constant bytes.");
    const reader = new SigmaByteReader(bytes);
    const type = typeSerializer.deserialize(reader);
    const data = dataSerializer.deserialize(type, reader);
    return new _SConstant(type, data);
  }
  get type() {
    return this.#type;
  }
  get data() {
    return this.#data;
  }
  toBytes() {
    const writer = new SigmaByteWriter(MAX_CONSTANT_LENGTH);
    typeSerializer.serialize(this.type, writer);
    dataSerializer.serialize(this.data, this.type, writer);
    return writer.toBytes();
  }
  toHex() {
    return hex.encode(this.toBytes());
  }
};
function decode(value, coder) {
  if (isUndefined(value)) return;
  const data = parse(value, "safe");
  if (isUndefined(data)) return;
  return coder ? coder(data) : data;
}
function parse(constant, mode = "strict") {
  if (mode === "strict") return SConstant.from(constant ?? "").data;
  if (!constant) return;
  try {
    return SConstant.from(constant).data;
  } catch {
    return;
  }
}
var MAX_UINT16_VALUE = 65535;
function serializeBox(box, writer = new SigmaByteWriter(5e4), distinctTokenIds) {
  writer.writeBigVLQ(ensureBigInt(box.value));
  writer.writeHex(box.ergoTree);
  writer.writeVLQ(box.creationHeight);
  writeTokens(writer, box.assets, distinctTokenIds);
  writeRegisters(writer, box.additionalRegisters);
  if (isDefined(distinctTokenIds)) return writer;
  if (!isBox(box)) throw new Error("Invalid box type.");
  return writer.writeHex(box.transactionId).writeVLQ(box.index);
}
function isBox(box) {
  const castedBox = box;
  return isDefined(castedBox.transactionId) && isDefined(castedBox.index);
}
function writeTokens(writer, tokens, tokenIds) {
  if (isEmpty(tokens)) {
    writer.write(0);
    return;
  }
  writer.writeVLQ(tokens.length);
  if (some(tokenIds)) {
    tokens.map(
      (token) => writer.writeVLQ(tokenIds.indexOf(token.tokenId)).writeBigVLQ(ensureBigInt(token.amount))
    );
  } else {
    tokens.map(
      (token) => writer.writeHex(token.tokenId).writeBigVLQ(ensureBigInt(token.amount))
    );
  }
}
function writeRegisters(writer, registers) {
  const keys = Object.keys(registers).sort();
  let length = 0;
  for (const key of keys) {
    if (registers[key]) length++;
  }
  writer.writeVLQ(length);
  if (length === 0) return;
  for (const key of keys) {
    const register = registers[key];
    if (isDefined(register)) writer.writeHex(register);
  }
}
function estimateBoxSize(box, withValue) {
  if (isUndefined(box.creationHeight)) {
    throw new Error("Box size estimation error: creation height is undefined.");
  }
  let size = 0;
  size += estimateVLQSize(isDefined(withValue) ? withValue : box.value);
  size += byteSizeOf(box.ergoTree);
  size += estimateVLQSize(box.creationHeight);
  size += estimateVLQSize(box.assets.length);
  for (const asset of box.assets) {
    size += byteSizeOf(asset.tokenId) + estimateVLQSize(asset.amount);
  }
  let registersLength = 0;
  for (const key in box.additionalRegisters) {
    const register = box.additionalRegisters[key];
    if (register) {
      size += byteSizeOf(register);
      registersLength++;
    }
  }
  size += estimateVLQSize(registersLength);
  size += 32;
  size += estimateVLQSize(isBox(box) ? box.index : MAX_UINT16_VALUE);
  return size;
}
function serializeTransaction(transaction) {
  const writer = new SigmaByteWriter(1e5);
  writer.writeVLQ(transaction.inputs.length);
  transaction.inputs.map((input) => writeInput(writer, input));
  writer.writeVLQ(transaction.dataInputs.length);
  transaction.dataInputs.map((dataInput) => writer.writeHex(dataInput.boxId));
  const distinctTokenIds = getDistinctTokenIds(transaction.outputs);
  writer.writeVLQ(distinctTokenIds.length);
  distinctTokenIds.map((tokenId) => writer.writeHex(tokenId));
  writer.writeVLQ(transaction.outputs.length);
  transaction.outputs.map(
    (output) => serializeBox(output, writer, distinctTokenIds)
  );
  return writer;
}
function writeInput(writer, input) {
  writer.writeHex(input.boxId);
  writer.write(0);
  writeExtension(writer, input.extension);
}
function writeExtension(writer, extension) {
  const keys = Object.keys(extension);
  let length = 0;
  for (const key of keys) {
    const ext = extension[key];
    if (isDefined(ext)) {
      length++;
    }
  }
  writer.writeVLQ(length);
  if (length === 0) return;
  for (const key of keys) {
    const ext = extension[key];
    if (isDefined(ext)) {
      writer.writeVLQ(Number(key)).writeHex(ext);
    }
  }
}
function getDistinctTokenIds(outputs) {
  const tokenIds = /* @__PURE__ */ new Set();
  outputs.flatMap(
    (output) => output.assets.map((asset) => tokenIds.add(asset.tokenId))
  );
  return Array.from(tokenIds);
}

export { SBigInt, SBigIntType, SBool, SBoolType, SByte, SByteType, SColl, SCollType, SConstant, SGenericType, SGroupElement, SGroupElementType, SInt, SIntType, SLong, SLongType, SMonomorphicType, SPair, SPrimitiveType, SShort, SShortType, SSigmaProp, SSigmaPropType, STupleType, SType, SUnit, SUnitType, SigmaByteReader, SigmaByteWriter, dataSerializer, decode, estimateBoxSize, estimateVLQSize, isColl, isTuple, parse, serializeBox, serializeTransaction, typeSerializer };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.mjs.map