{"version":3,"sources":["../src/coders/sigmaByteReader.ts","../src/coders/bigint.ts","../src/coders/vlq.ts","../src/coders/zigZag.ts","../src/coders/sigmaByteWriter.ts","../src/sigmaConstant.ts","../src/serializers/dataSerializer.ts","../src/types/base.ts","../src/types/primitives.ts","../src/types/monomorphics.ts","../src/types/descriptors.ts","../src/types/generics.ts","../src/types/constructors.ts","../src/serializers/typeSerializer.ts","../src/serializers/boxSerializer.ts","../src/serializers/transactionSerializer.ts"],"names":["hex","_0n","assert","ensureBigInt","isEmpty","first","isUndefined","isDefined"],"mappings":"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","sourcesContent":["import { isEmpty } from \"@fleet-sdk/common\";\nimport { type ByteInput, ensureBytes, hex } from \"@fleet-sdk/crypto\";\nimport { hexToBigInt } from \"./bigint\";\nimport { readBigVLQ, readVLQ } from \"./vlq\";\nimport { zigZagDecode, zigZagDecodeBigInt } from \"./zigZag\";\n\nexport class SigmaByteReader {\n  readonly #bytes: Uint8Array;\n  #cursor: number;\n\n  public get isEmpty(): boolean {\n    return isEmpty(this.#bytes);\n  }\n\n  constructor(bytes: ByteInput) {\n    this.#bytes = ensureBytes(bytes);\n    this.#cursor = 0;\n  }\n\n  public readBoolean(): boolean {\n    return this.readByte() === 0x01;\n  }\n\n  public readBits(length: number): ArrayLike<boolean> {\n    const bits = new Array<boolean>(length);\n    let bitOffset = 0;\n\n    for (let i = 0; i < length; i++) {\n      const bit = (this.#bytes[this.#cursor] >> bitOffset++) & 1;\n      bits[i] = bit === 1;\n\n      if (bitOffset === 8) {\n        bitOffset = 0;\n        this.#cursor++;\n      }\n    }\n\n    if (bitOffset > 0) this.#cursor++;\n\n    return bits;\n  }\n\n  public readByte(): number {\n    return this.#bytes[this.#cursor++];\n  }\n\n  public readBytes(length: number): Uint8Array {\n    return this.#bytes.subarray(this.#cursor, (this.#cursor += length));\n  }\n\n  public readVlq(): number {\n    return readVLQ(this);\n  }\n\n  public readShort(): number {\n    return Number(zigZagDecode(readVLQ(this)));\n  }\n\n  public readInt(): number {\n    return Number(this.readLong());\n  }\n\n  public readLong(): bigint {\n    return zigZagDecodeBigInt(readBigVLQ(this));\n  }\n\n  public readBigInt(): bigint {\n    const len = readVLQ(this);\n    return hexToBigInt(hex.encode(this.readBytes(len)));\n  }\n}\n","import { _0n, first } from \"@fleet-sdk/common\";\n\n/**\n * Converts a hex string to bigint.\n * @param hex The hex string to be converted.\n * @returns The bigint value represented by the hex string.\n */\nexport function hexToBigInt(hex: string): bigint {\n  // https://coolaj86.com/articles/convert-hex-to-decimal-with-js-bigints/\n  const value = BigInt(hex.length % 2 ? `0x0${hex}` : `0x${hex}`);\n  const highByte = Number.parseInt(hex.slice(0, 2), 16);\n  if (0x80 & highByte) return -negateAndMask(value);\n\n  return value;\n}\n\n/**\n * Serializes a `BigInt` to a hex string\n * @param value The bigint value to be serialized\n * @returns Hex representation for the provided `number`.\n */\nexport function bigIntToHex(value: bigint): string {\n  // implementation inspired on\n  // https://coolaj86.com/articles/convert-decimal-to-hex-with-js-bigints/\n  const positive = value >= _0n;\n  let hex = (positive ? value : negateAndMask(value)).toString(16);\n  if (hex.length % 2) hex = `0${hex}`;\n\n  if (positive && 0x80 & Number.parseInt(hex.slice(0, 2), 16)) {\n    return `00${hex}`;\n  }\n\n  return hex;\n}\n\n/**\n * Returns the two’s complement of a bigint value.\n * @param value The bigint value to negate.\n * @returns The two’s complement of `number` as a bigint.\n */\nexport function negateAndMask(value: bigint): bigint {\n  let val = value;\n  const negative = val < _0n;\n  if (negative) val = -val; // turn into a positive number\n\n  const bits = val.toString(2);\n  let len = bits.length; // convert to binary\n  const mod = len % 8;\n\n  if (mod > 0) {\n    len += 8 - mod;\n  } else if (negative && first(bits) === \"1\" && bits.indexOf(\"1\", 1) !== -1) {\n    len += 8;\n  }\n\n  const mask = (1n << BigInt(len)) - 1n; // create a mask\n  return (~val & mask) + 1n; // invert bits, mask it, and add one\n}\n","import { _0n, _127n, _128n, _7n, ensureBigInt } from \"@fleet-sdk/common\";\nimport type { SigmaByteReader } from \"./sigmaByteReader\";\nimport type { SigmaByteWriter } from \"./sigmaByteWriter\";\n\n/**\n * A **variable-length quantity (VLQ)** is a universal code that uses an arbitrary number\n * of binary octets (eight-bit bytes) to represent an arbitrarily large integer. A VLQ\n * is essentially a base-128 representation of an unsigned integer with the addition of\n * the eighth bit to mark continuation of bytes. VLQ is identical to LEB128 except in\n * endianness. See the example below.\n */\n\n/**\n * Write an unsigned integer value as VLQ to a `SigmaByteWriter`.\n * @param value: Integer value\n * @param writer: Sigma writer\n * @returns Sigma writer passed as function argument.\n */\nexport function writeVLQ(\n  writer: SigmaByteWriter,\n  value: number\n): SigmaByteWriter {\n  // source: https://stackoverflow.com/a/3564685\n  if (value === 0) return writer.write(0);\n  if (value < 0) {\n    throw new RangeError(\n      \"Variable Length Quantity not supported for negative numbers.\"\n    );\n  }\n\n  let val = value;\n  do {\n    let lower7bits = val & 0x7f;\n    val >>= 7;\n    if (val > 0) lower7bits |= 0x80;\n    writer.write(lower7bits);\n  } while (val > 0);\n\n  return writer;\n}\n\n/**\n * Decode VLQ bytes to an unsigned integer value\n * @param reader VLQ bytes\n * @returns Unsigned integer value\n */\nexport function readVLQ(reader: SigmaByteReader): number {\n  if (reader.isEmpty) {\n    return 0;\n  }\n\n  let value = 0;\n  let shift = 0;\n  let lower7bits = 0;\n\n  do {\n    lower7bits = reader.readByte();\n    value |= (lower7bits & 0x7f) << shift;\n    shift += 7;\n  } while ((lower7bits & 0x80) !== 0);\n\n  return value;\n}\n\n/**\n * Write an unsigned integer value as VLQ to a `SigmaByteWriter`.\n * @param value: Big integer value\n * @param writer: Sigma writer\n * @returns Sigma writer passed as function argument.\n */\nexport function writeBigVLQ(\n  writer: SigmaByteWriter,\n  value: bigint\n): SigmaByteWriter {\n  // source: https://stackoverflow.com/a/3564685\n\n  if (value === _0n) return writer.write(0);\n  if (value < _0n) {\n    throw new RangeError(\n      \"Variable Length Quantity not supported for negative numbers\"\n    );\n  }\n\n  let val = value;\n  do {\n    let lower7bits = Number(val & _127n);\n    val >>= _7n;\n    if (val > 0) lower7bits |= 0x80;\n    writer.write(lower7bits);\n  } while (val > 0);\n\n  return writer;\n}\n\n/**\n * Decode VLQ bytes to an unsigned big integer value\n * @param reader VLQ bytes\n * @returns Unsigned integer value\n */\nexport function readBigVLQ(reader: SigmaByteReader): bigint {\n  if (reader.isEmpty) return _0n;\n\n  let value = _0n;\n  let shift = _0n;\n  let lower7bits = _0n;\n\n  do {\n    lower7bits = BigInt(reader.readByte());\n    value |= (lower7bits & _127n) << shift;\n    shift += _7n;\n  } while ((lower7bits & _128n) !== _0n);\n\n  return value;\n}\n\n/**\n * Estimates the byte size of a given unsigned integer.\n * @param value: the value to be evaluated.\n * @returns the byte size of the value.\n */\nexport function estimateVLQSize(value: number | bigint | string): number {\n  let size = 0;\n  let val = value;\n  if (typeof val === \"number\") {\n    do {\n      size++;\n      val = Math.floor(val / 128);\n    } while (val > 0);\n\n    return size;\n  }\n\n  val = ensureBigInt(val);\n  do {\n    size++;\n    val /= _128n;\n  } while (val > _0n);\n\n  return size;\n}\n","import { _1n, _63n } from \"@fleet-sdk/common\";\n\n/**\n * ZigZag encoding maps signed integers to unsigned integers so that numbers\n * with a small absolute value (for instance, -1) have a small variant encoded\n * value too. It does this in a way that \"zig-zags\" back and forth through the\n * positive and negative integers, so that -1 is encoded as 1, 1 is encoded as 2,\n * -2 is encoded as 3, and so on.\n * @see https://developers.google.com/protocol-buffers/docs/encoding#types\n */\n\n/**\n * Encode a signed integer.\n * @param input Signed integer\n * @returns ZigZag-encoded value\n */\nexport function zigZagEncode(input: number): number {\n  return (input << 1) ^ (input >> 63);\n}\n\n/**\n * Decode a ZigZag-encoded value.\n * @param input ZigZag-encoded value\n * @returns Signed integer\n */\nexport function zigZagDecode(input: number): number {\n  return (input >> 1) ^ -(input & 1);\n}\n\n/**\n * Encode a signed big integer.\n * @param input Signed big integer\n * @returns ZigZag-encoded value\n */\nexport function zigZagEncodeBigInt(input: bigint): bigint {\n  return (input << _1n) ^ (input >> _63n);\n}\n\n/**\n * Decode a ZigZag-encoded value.\n * @param input ZigZag-encoded value\n * @returns Signed big integer\n */\nexport function zigZagDecodeBigInt(input: bigint): bigint {\n  return (input >> _1n) ^ -(input & _1n);\n}\n","import { blake2b256, type Coder, hex } from \"@fleet-sdk/crypto\";\nimport { bigIntToHex } from \"./bigint\";\nimport { writeBigVLQ, writeVLQ } from \"./vlq\";\nimport { zigZagEncode, zigZagEncodeBigInt } from \"./zigZag\";\n\nexport class SigmaByteWriter {\n  readonly #bytes: Uint8Array;\n  #cursor: number;\n\n  public get length() {\n    return this.#cursor;\n  }\n\n  constructor(length: number) {\n    this.#bytes = new Uint8Array(length);\n    this.#cursor = 0;\n  }\n\n  public writeBoolean(value: boolean): SigmaByteWriter {\n    this.write(value === true ? 0x01 : 0x00);\n\n    return this;\n  }\n\n  public writeVLQ(value: number): SigmaByteWriter {\n    return writeVLQ(this, value);\n  }\n\n  public writeBigVLQ(value: bigint): SigmaByteWriter {\n    return writeBigVLQ(this, value);\n  }\n\n  public writeShort(value: number): SigmaByteWriter {\n    this.writeVLQ(zigZagEncode(value));\n    return this;\n  }\n\n  public writeInt(value: number): SigmaByteWriter {\n    this.writeLong(BigInt(value));\n    return this;\n  }\n\n  public writeLong(value: bigint): SigmaByteWriter {\n    this.writeBigVLQ(zigZagEncodeBigInt(value));\n    return this;\n  }\n\n  public write(byte: number): SigmaByteWriter {\n    this.#bytes[this.#cursor++] = byte;\n    return this;\n  }\n\n  public writeBytes(bytes: ArrayLike<number>): SigmaByteWriter {\n    this.#bytes.set(bytes, this.#cursor);\n    this.#cursor += bytes.length;\n    return this;\n  }\n\n  public writeHex(bytesHex: string): SigmaByteWriter {\n    return this.writeBytes(hex.decode(bytesHex));\n  }\n\n  public writeBits(bits: ArrayLike<boolean>): SigmaByteWriter {\n    let bitOffset = 0;\n\n    for (let i = 0; i < bits.length; i++) {\n      if (bits[i]) {\n        this.#bytes[this.#cursor] |= 1 << bitOffset++;\n      } else {\n        this.#bytes[this.#cursor] &= ~(1 << bitOffset++);\n      }\n\n      if (bitOffset === 8) {\n        bitOffset = 0;\n        this.#cursor++;\n      }\n    }\n\n    if (bitOffset > 0) this.#cursor++;\n\n    return this;\n  }\n\n  public writeBigInt(value: bigint): SigmaByteWriter {\n    const hex = bigIntToHex(value);\n    return this.writeVLQ(hex.length / 2).writeHex(hex);\n  }\n\n  public writeChecksum(length = 4, hashFn = blake2b256): SigmaByteWriter {\n    const hash = hashFn(this.toBytes());\n    return this.writeBytes(length ? hash.subarray(0, length) : hash);\n  }\n\n  public encode<T>(coder: Coder<Uint8Array, T>): T {\n    return coder.encode(this.toBytes());\n  }\n\n  public toBytes(): Uint8Array {\n    if (this.#cursor === this.#bytes.length) return this.#bytes;\n    return this.#bytes.subarray(0, this.#cursor);\n  }\n}\n","import { assert, isUndefined } from \"@fleet-sdk/common\";\nimport { type ByteInput, hex } from \"@fleet-sdk/crypto\";\nimport { SigmaByteReader, SigmaByteWriter } from \"./coders\";\nimport { dataSerializer } from \"./serializers/dataSerializer\";\nimport { typeSerializer } from \"./serializers/typeSerializer\";\nimport type { SType } from \"./types\";\n\nexport const MAX_CONSTANT_LENGTH = 4096;\n\nexport class SConstant<D = unknown, T extends SType = SType> {\n  readonly #type: T;\n  readonly #data: D;\n\n  constructor(type: T, data: D) {\n    this.#type = type;\n    this.#data = type.coerce(data) as D;\n  }\n\n  static from<D, T extends SType = SType>(bytes: ByteInput): SConstant<D, T> {\n    assert(bytes.length > 0, \"Empty constant bytes.\");\n\n    const reader = new SigmaByteReader(bytes);\n    const type = typeSerializer.deserialize(reader);\n    const data = dataSerializer.deserialize(type, reader);\n\n    return new SConstant(type as T, data as D);\n  }\n\n  get type(): T {\n    return this.#type;\n  }\n\n  get data(): D {\n    return this.#data;\n  }\n\n  toBytes(): Uint8Array {\n    const writer = new SigmaByteWriter(MAX_CONSTANT_LENGTH);\n    typeSerializer.serialize(this.type, writer);\n    dataSerializer.serialize(this.data, this.type, writer);\n\n    return writer.toBytes();\n  }\n\n  toHex(): string {\n    return hex.encode(this.toBytes());\n  }\n}\n\nexport function decode<T>(value: ByteInput | undefined): T | undefined;\nexport function decode<T, K>(\n  value: ByteInput | undefined,\n  coder: (input: T) => K\n): K | undefined;\nexport function decode<T, K>(\n  value: ByteInput | undefined,\n  coder?: (input: T) => K\n): T | K | undefined {\n  if (isUndefined(value)) return;\n  const data = parse<T>(value, \"safe\");\n  if (isUndefined(data)) return;\n\n  return coder ? coder(data) : data;\n}\n\n/** @deprecated use `decode` instead */\nexport function parse<T>(constant: ByteInput): T;\n/** @deprecated use `decode` instead */\nexport function parse<T>(constant: ByteInput, mode: \"strict\"): T;\n/** @deprecated use `decode` instead */\nexport function parse<T>(\n  constant: ByteInput | undefined,\n  mode: \"safe\"\n): T | undefined;\n/** @deprecated use `decode` instead */\nexport function parse<T>(\n  constant: ByteInput | undefined,\n  mode: \"strict\" | \"safe\" = \"strict\"\n) {\n  if (mode === \"strict\") return SConstant.from<T>(constant ?? \"\").data;\n  if (!constant) return;\n\n  try {\n    return SConstant.from<T>(constant).data;\n  } catch {\n    return;\n  }\n}\n","import { assert } from \"@fleet-sdk/common\";\nimport type { SigmaByteReader, SigmaByteWriter } from \"../coders\";\nimport type { SConstant } from \"../sigmaConstant\";\nimport {\n  isColl,\n  isTuple,\n  type SCollType,\n  type STupleType,\n  type SType\n} from \"../types\";\nimport { descriptors } from \"../types/descriptors\";\n\nconst GROUP_ELEMENT_LENGTH = 33;\nconst PROVE_DLOG_OP = 0xcd;\n\nexport const dataSerializer = {\n  serialize(\n    data: unknown,\n    type: SType,\n    writer: SigmaByteWriter\n  ): SigmaByteWriter {\n    if (type.embeddable) {\n      switch (type.code) {\n        case descriptors.bool.code:\n          return writer.writeBoolean(data as boolean);\n        case descriptors.byte.code:\n          return writer.write(data as number);\n        case descriptors.short.code:\n          return writer.writeShort(data as number);\n        case descriptors.int.code:\n          return writer.writeInt(data as number);\n        case descriptors.long.code:\n          return writer.writeLong(data as bigint);\n        case descriptors.bigInt.code:\n          return writer.writeBigInt(data as bigint);\n        case descriptors.groupElement.code:\n          return writer.writeBytes(data as Uint8Array);\n        case descriptors.sigmaProp.code: {\n          const node = data as SConstant<SConstant<Uint8Array>>;\n          if (node.type === descriptors.groupElement) {\n            writer.write(PROVE_DLOG_OP);\n            return dataSerializer.serialize(node.data, node.type, writer);\n          }\n\n          throw Error(\n            \"Serialization error: SigmaProp operation not implemented.\"\n          );\n        }\n      }\n    }\n\n    if (isColl(type)) {\n      if (type.elementsType.code === descriptors.byte.code) {\n        assert(\n          data instanceof Uint8Array,\n          `SColl[Byte] expected an UInt8Array, got ${typeof data}.`\n        );\n      } else {\n        assert(\n          Array.isArray(data),\n          `SColl expected an array, got ${typeof data}.`\n        );\n      }\n\n      writer.writeVLQ(data.length);\n      switch (type.elementsType.code) {\n        case descriptors.bool.code: {\n          return writer.writeBits(data as boolean[]);\n        }\n        case descriptors.byte.code: {\n          return writer.writeBytes(data as Uint8Array);\n        }\n        default: {\n          for (let i = 0; i < data.length; i++) {\n            dataSerializer.serialize(data[i], type.elementsType, writer);\n          }\n\n          return writer;\n        }\n      }\n    }\n\n    if (isTuple(type)) {\n      assert(\n        Array.isArray(data),\n        `STupleType serialization expected an array, got ${typeof data}.`\n      );\n\n      const len = type.elementsType.length;\n      for (let i = 0; i < len; i++) {\n        dataSerializer.serialize(data[i], type.elementsType[i], writer);\n      }\n\n      return writer;\n    }\n\n    if (type.code === descriptors.unit.code) return writer;\n\n    throw Error(\n      `Serialization error: '0x${type.code.toString(16)}' type not implemented.`\n    );\n  },\n\n  deserialize(type: SType, reader: SigmaByteReader): unknown {\n    if (type.embeddable) {\n      switch (type.code) {\n        case descriptors.bool.code:\n          return reader.readBoolean();\n        case descriptors.byte.code:\n          return reader.readByte();\n        case descriptors.short.code:\n          return reader.readShort();\n        case descriptors.int.code:\n          return reader.readInt();\n        case descriptors.long.code:\n          return reader.readLong();\n        case descriptors.bigInt.code:\n          return reader.readBigInt();\n        case descriptors.groupElement.code:\n          return reader.readBytes(GROUP_ELEMENT_LENGTH);\n        case descriptors.sigmaProp.code: {\n          if (reader.readByte() === PROVE_DLOG_OP) {\n            return this.deserialize(descriptors.groupElement, reader);\n          }\n\n          break;\n        }\n      }\n    } else {\n      switch (type.code) {\n        case descriptors.coll.code: {\n          const length = reader.readVlq();\n          const embeddedType = (type as SCollType).elementsType;\n\n          switch (embeddedType.code) {\n            case descriptors.bool.code:\n              return reader.readBits(length);\n            case descriptors.byte.code:\n              return reader.readBytes(length);\n            default: {\n              const elements = new Array(length);\n              for (let i = 0; i < length; i++) {\n                elements[i] = this.deserialize(embeddedType, reader);\n              }\n\n              return elements;\n            }\n          }\n        }\n        case descriptors.tuple.code: {\n          return (type as STupleType).elementsType.map((t) =>\n            this.deserialize(t, reader)\n          );\n        }\n        case descriptors.unit.code:\n          return undefined;\n      }\n    }\n\n    throw new Error(\n      `Parsing error: '0x${type.code.toString(16)}' type not implemented.`\n    );\n  }\n};\n","export abstract class SType<I = unknown, O = I> {\n  abstract get code(): number;\n  abstract get embeddable(): boolean;\n\n  coerce(data: I): O {\n    // a bit hacky but most of types will not need a specific coercion function.\n    return data as unknown as O;\n  }\n\n  abstract toString(): string;\n}\n\nexport abstract class SMonomorphicType<I, O = I> extends SType<I, O> {\n  abstract get code(): number;\n\n  get embeddable(): boolean {\n    return false;\n  }\n}\n\nexport abstract class SPrimitiveType<I, O = I> extends SMonomorphicType<I, O> {\n  abstract get code(): number;\n\n  override get embeddable(): boolean {\n    return true;\n  }\n}\n\nexport abstract class SGenericType<T extends SType | SType[]> extends SType {\n  readonly #internalType: T;\n\n  constructor(type: T) {\n    super();\n    this.#internalType = type;\n  }\n\n  abstract get code(): number;\n\n  get elementsType(): T {\n    return this.#internalType;\n  }\n\n  get embeddable(): boolean {\n    return false;\n  }\n}\n","import { ensureBigInt } from \"@fleet-sdk/common\";\nimport { hex } from \"@fleet-sdk/crypto\";\nimport type { SConstant } from \"../sigmaConstant\";\nimport { SPrimitiveType } from \"./base\";\nimport type { BigIntInput, ByteInput } from \"./constructors\";\n\nexport class SBoolType extends SPrimitiveType<boolean> {\n  get code(): 0x01 {\n    return 0x01;\n  }\n\n  toString(): string {\n    return \"SBool\";\n  }\n}\n\nexport class SByteType extends SPrimitiveType<number> {\n  get code(): 0x02 {\n    return 0x02;\n  }\n\n  toString(): string {\n    return \"SByte\";\n  }\n}\n\nexport class SShortType extends SPrimitiveType<number> {\n  get code(): 0x03 {\n    return 0x03;\n  }\n\n  toString(): string {\n    return \"SShort\";\n  }\n}\n\nexport class SIntType extends SPrimitiveType<number> {\n  get code(): 0x04 {\n    return 0x04;\n  }\n\n  toString(): string {\n    return \"SInt\";\n  }\n}\n\nexport class SLongType extends SPrimitiveType<BigIntInput, bigint> {\n  get code(): 0x05 {\n    return 0x05;\n  }\n\n  override coerce(data: BigIntInput): bigint {\n    return ensureBigInt(data);\n  }\n\n  toString(): string {\n    return \"SLong\";\n  }\n}\n\nexport class SBigIntType extends SPrimitiveType<string | bigint, bigint> {\n  get code(): number {\n    return 0x06;\n  }\n\n  override coerce(data: BigIntInput): bigint {\n    return ensureBigInt(data);\n  }\n\n  toString(): string {\n    return \"SBigInt\";\n  }\n}\n\nexport class SGroupElementType extends SPrimitiveType<ByteInput, Uint8Array> {\n  get code(): 0x07 {\n    return 0x07;\n  }\n\n  override coerce(data: ByteInput): Uint8Array {\n    return typeof data === \"string\" ? hex.decode(data) : data;\n  }\n\n  toString(): string {\n    return \"SGroupElement\";\n  }\n}\n\nexport class SSigmaPropType extends SPrimitiveType<SConstant<Uint8Array>> {\n  get code(): 0x08 {\n    return 0x08;\n  }\n\n  toString(): string {\n    return \"SSigmaProp\";\n  }\n}\n","import { SMonomorphicType } from \"./base\";\n\nexport class SUnitType extends SMonomorphicType<undefined> {\n  get code(): 0x62 {\n    return 0x62;\n  }\n\n  toString(): string {\n    return \"SUnit\";\n  }\n}\n","import type { SType } from \"./base\";\nimport type { SCollType, STupleType } from \"./generics\";\nimport { SUnitType } from \"./monomorphics\";\nimport {\n  SBigIntType,\n  SBoolType,\n  SByteType,\n  SGroupElementType,\n  SIntType,\n  SLongType,\n  SShortType,\n  SSigmaPropType\n} from \"./primitives\";\n\nexport const constructorCode = Object.freeze({\n  embeddable: 0,\n\n  simpleColl: 1,\n  nestedColl: 2,\n\n  option: 3,\n  optionCollection: 4,\n\n  pairOne: 5,\n  pairTwo: 6,\n  symmetricPair: 7,\n  genericTuple: 8\n});\n\nconst MAX_PRIMITIVE_TYPE_CODE = 0x0b;\nexport const PRIMITIVE_TYPE_RANGE = MAX_PRIMITIVE_TYPE_CODE + 0x01;\nconst typeCodeOf = (ctor: number) => PRIMITIVE_TYPE_RANGE * ctor;\n\ntype Descriptor = { code: number; embeddable: boolean };\n\nconst collDescriptor = Object.freeze({\n  code: typeCodeOf(constructorCode.simpleColl),\n  embeddable: false,\n  simpleCollTypeCode: typeCodeOf(constructorCode.simpleColl),\n  nestedCollTypeCode: typeCodeOf(constructorCode.nestedColl)\n}) satisfies Descriptor;\n\nconst tupleDescriptor = Object.freeze({\n  code: typeCodeOf(constructorCode.pairOne),\n  embeddable: false,\n  pairOneTypeCode: typeCodeOf(constructorCode.pairOne),\n  pairTwoTypeCode: typeCodeOf(constructorCode.pairTwo),\n  tripleTypeCode: typeCodeOf(constructorCode.pairTwo),\n  symmetricPairTypeCode: typeCodeOf(constructorCode.symmetricPair),\n  quadrupleTypeCode: typeCodeOf(constructorCode.symmetricPair),\n  genericTupleTypeCode: typeCodeOf(constructorCode.genericTuple)\n}) satisfies Descriptor;\n\nexport const descriptors = {\n  bool: new SBoolType(),\n  byte: new SByteType(),\n  short: new SShortType(),\n  int: new SIntType(),\n  long: new SLongType(),\n  bigInt: new SBigIntType(),\n  groupElement: new SGroupElementType(),\n  sigmaProp: new SSigmaPropType(),\n  unit: new SUnitType(),\n  coll: collDescriptor,\n  tuple: tupleDescriptor\n} satisfies { [key: string]: Descriptor };\n\nexport function isColl(type: SType): type is SCollType {\n  return (\n    type.code >= descriptors.coll.simpleCollTypeCode &&\n    type.code <= descriptors.coll.nestedCollTypeCode + MAX_PRIMITIVE_TYPE_CODE\n  );\n}\n\nexport function isTuple(type: SType): type is STupleType {\n  return (\n    type.code >= descriptors.tuple.pairOneTypeCode &&\n    type.code <= descriptors.tuple.genericTupleTypeCode\n  );\n}\n\nexport function getPrimitiveType(typeCode: number) {\n  switch (typeCode) {\n    case descriptors.bool.code:\n      return descriptors.bool;\n    case descriptors.byte.code:\n      return descriptors.byte;\n    case descriptors.short.code:\n      return descriptors.short;\n    case descriptors.int.code:\n      return descriptors.int;\n    case descriptors.long.code:\n      return descriptors.long;\n    case descriptors.bigInt.code:\n      return descriptors.bigInt;\n    case descriptors.groupElement.code:\n      return descriptors.groupElement;\n    case descriptors.sigmaProp.code:\n      return descriptors.sigmaProp;\n    default:\n      throw new Error(\n        `The type code '0x${typeCode.toString(16)}' is not a valid primitive type code.`\n      );\n  }\n}\n","import { hex } from \"@fleet-sdk/crypto\";\nimport { SGenericType, type SType } from \"./base\";\nimport { descriptors } from \"./descriptors\";\n\nexport class SCollType<T extends SType = SType> extends SGenericType<T> {\n  get code(): number {\n    return descriptors.coll.code;\n  }\n\n  override coerce<I, O>(elements: I[]): O[] | Uint8Array {\n    if (\n      this.elementsType.code === descriptors.byte.code &&\n      !(elements instanceof Uint8Array)\n    ) {\n      return typeof elements === \"string\"\n        ? hex.decode(elements)\n        : Uint8Array.from(elements as ArrayLike<number>);\n    }\n\n    return elements.map((el) => this.elementsType.coerce(el)) as O[];\n  }\n\n  toString(): string {\n    return `SColl[${this.elementsType.toString()}]`;\n  }\n}\n\nexport class STupleType<T extends SType[] = SType[]> extends SGenericType<T> {\n  get code(): number {\n    return descriptors.tuple.code;\n  }\n\n  override coerce<I, O>(elements: I[]): O[] {\n    const output = new Array(elements.length);\n    for (let i = 0; i < elements.length; i++) {\n      output[i] = this.elementsType[i].coerce(elements[i]);\n    }\n\n    return output;\n  }\n\n  toString(): string {\n    return `(${this.elementsType.map((el) => el.toString()).join(\", \")})`;\n  }\n}\n","import { isEmpty } from \"@fleet-sdk/common\";\nimport { SConstant } from \"../sigmaConstant\";\nimport type { SType } from \"./base\";\nimport { descriptors } from \"./descriptors\";\nimport { SCollType, STupleType } from \"./generics\";\nimport { SUnitType } from \"./monomorphics\";\nimport {\n  SBigIntType,\n  SBoolType,\n  SByteType,\n  SGroupElementType,\n  SIntType,\n  SLongType,\n  SShortType,\n  SSigmaPropType\n} from \"./primitives\";\n\nexport type BigIntInput = string | bigint;\nexport type ByteInput = Uint8Array | string;\n\nexport type SConstructor<\n  T = unknown,\n  S extends SType = SType | SCollType<SType>\n> = (arg?: T) => S;\n\n// biome-ignore lint/suspicious/noExplicitAny: <explanation>\ntype Any = any;\n\ntype Constructable<T = Any> = { new (...args: Any): T };\ntype GenericProxyArgs<R> = R extends (...args: Any) => unknown\n  ? Parameters<R>\n  : [];\n\ntype SProxy<T extends SType, I, O = I> = {\n  (value: I): SConstant<O, T>;\n  (value?: I): T;\n};\n\n/**\n * Creates a proxy for monomorphic types, this allows constructor\n * functions to be equivalent to their corresponding type.\n *\n * This function will return one instance of `ctor` if not params as set.\n * Otherwise it will return an `SigmaConstant` instance of `ctor` type.\n *\n * @example\n * // SInt is a proxy for SIntType\n * (intConstant instanceof SInt) === true\n * (intConstant instanceof SIntType) === true\n * @param ctor Class to be proxied.\n * @param cache If defined, proxy will return this instead of a new instance of `ctor`.\n * @param forceConstruction If true, bypasses the constant creation and returns a type.\n * @returns\n */\nfunction monoProxy<T extends SType, I, O = I>(\n  ctor: Constructable<T>,\n  cache?: T,\n  forceConstruction?: boolean\n): SProxy<T, I, O> {\n  return new Proxy(ctor, {\n    apply: (target, _, args) => {\n      const instance = cache ?? new target();\n      if (!forceConstruction && isEmpty(args)) return instance;\n\n      return new (SConstant as Constructable)(instance, ...args);\n    }\n  }) as Any;\n}\n\n/**\n * Creates a proxy for generic types.\n */\nfunction genericProxy<T extends SType, R>(\n  ctor: Constructable<T>,\n  handler: (\n    target: Constructable<T>,\n    thisArgs: unknown,\n    args: GenericProxyArgs<R>\n  ) => unknown\n) {\n  return new Proxy(ctor, {\n    apply: handler\n  }) as R;\n}\n\nexport const SByte = monoProxy<SByteType, number>(SByteType, descriptors.byte);\n\nexport const SBool = monoProxy<SBoolType, boolean>(SBoolType, descriptors.bool);\n\nexport const SShort = monoProxy<SShortType, number>(\n  SShortType,\n  descriptors.short\n);\n\nexport const SInt = monoProxy<SIntType, number>(SIntType, descriptors.int);\n\nexport const SLong = monoProxy<SLongType, BigIntInput, bigint>(\n  SLongType,\n  descriptors.long\n);\n\nexport const SBigInt = monoProxy<SBigIntType, BigIntInput, bigint>(\n  SBigIntType,\n  descriptors.bigInt\n);\n\nexport const SGroupElement = monoProxy<\n  SGroupElementType,\n  ByteInput,\n  Uint8Array\n>(SGroupElementType, descriptors.groupElement);\n\nexport const SSigmaProp = monoProxy<SSigmaPropType, SConstant<Uint8Array>>(\n  SSigmaPropType,\n  descriptors.sigmaProp\n);\n\ntype SUnit = (value?: undefined) => SConstant<undefined, SUnitType>;\nexport const SUnit: SUnit = monoProxy(SUnitType, undefined, true);\n\ntype SColl = {\n  <D, T extends SType>(type: SConstructor<D, T>): SConstructor<D[], T>;\n  <D, T extends SByteType>(\n    type: SConstructor<D, T>,\n    elements: ByteInput | D[]\n  ): SConstant<Uint8Array, T>;\n  <D, T extends SType>(\n    type: SConstructor<D, T>,\n    elements: D[]\n  ): SConstant<D[], T>;\n};\n\nexport const SColl = genericProxy<SCollType, SColl>(\n  SCollType,\n  (target, _, args) => {\n    const [type, elements] = args;\n    const elementsType = type();\n    if (!elements) return () => new target(elementsType);\n\n    return new SConstant(new target(elementsType), elements);\n  }\n);\n\nexport function STuple(...items: SConstant[]) {\n  return new SConstant(\n    new STupleType(items.map((x) => x.type)),\n    items.map((x) => x.data)\n  );\n}\n\ntype ByteInputOr<D, T extends SType> = T extends SByteType ? ByteInput | D : D;\ntype SPair = {\n  <L, R>(\n    left: SConstant<L>,\n    right: SConstant<R>\n  ): SConstant<[L, R], STupleType>;\n  <LD, RD, LT extends SType, RT extends SType>(\n    left: SConstructor<LD, LT>,\n    right: SConstructor<RD, RT>\n  ): SConstructor<[ByteInputOr<LD, LT>, ByteInputOr<RD, RT>]>;\n};\n\nexport const SPair = genericProxy<STupleType, SPair>(\n  STupleType,\n  (target, _, args) => {\n    const [left, right] = args;\n\n    if (typeof left === \"function\" && typeof right === \"function\") {\n      return () => new target([left(), right()]);\n    }\n\n    if (left instanceof SConstant && right instanceof SConstant) {\n      return new SConstant(new target([left.type, right.type]), [\n        left.data,\n        right.data\n      ]);\n    }\n\n    throw new Error(\"Invalid tuple declaration.\");\n  }\n);\n","import { assert, first, last } from \"@fleet-sdk/common\";\nimport type { SigmaByteReader, SigmaByteWriter } from \"../coders\";\nimport { isColl, isTuple, SCollType, STupleType, type SType } from \"../types\";\nimport {\n  constructorCode,\n  descriptors,\n  getPrimitiveType,\n  PRIMITIVE_TYPE_RANGE\n} from \"../types/descriptors\";\n\nexport const typeSerializer = {\n  serialize(type: SType, writer: SigmaByteWriter) {\n    if (type.embeddable) {\n      writer.write(type.code);\n    } else if (type.code === descriptors.unit.code) {\n      writer.write(type.code);\n    } else if (isColl(type)) {\n      if (type.elementsType.embeddable) {\n        writer.write(\n          descriptors.coll.simpleCollTypeCode + type.elementsType.code\n        );\n      } else if (isColl(type.elementsType)) {\n        const nestedColl = type.elementsType;\n        if (nestedColl.elementsType.embeddable) {\n          writer.write(\n            descriptors.coll.nestedCollTypeCode + nestedColl.elementsType.code\n          );\n        } else {\n          writer.write(descriptors.coll.simpleCollTypeCode);\n          this.serialize(nestedColl, writer);\n        }\n      } else {\n        writer.write(descriptors.coll.simpleCollTypeCode);\n        this.serialize(type.elementsType, writer);\n      }\n    } else if (isTuple(type)) {\n      switch (type.elementsType.length) {\n        case 2: {\n          const left = first(type.elementsType);\n          const right = last(type.elementsType);\n\n          if (left.embeddable) {\n            if (left.code === right.code) {\n              // Symmetric pair of primitive types (`(Int, Int)`, `(Byte,Byte)`, etc.)\n              writer.write(descriptors.tuple.symmetricPairTypeCode + left.code);\n            } else {\n              // Pair of types where first is primitive (`(_, Int)`)\n              writer.write(descriptors.tuple.pairOneTypeCode + left.code);\n              this.serialize(right, writer);\n            }\n          } else if (right.embeddable) {\n            // Pair of types where second is primitive (`(Int, _)`)\n            writer.write(descriptors.tuple.pairTwoTypeCode + right.code);\n            this.serialize(left, writer);\n          } else {\n            // Pair of non-primitive types (`((Int, Byte), (Boolean,Box))`, etc.)\n            writer.write(descriptors.tuple.pairOneTypeCode);\n            this.serialize(left, writer);\n            this.serialize(right, writer);\n          }\n\n          return;\n        }\n        case 3:\n          writer.write(descriptors.tuple.tripleTypeCode);\n          break;\n        case 4:\n          writer.write(descriptors.tuple.quadrupleTypeCode);\n          break;\n        default: {\n          const len = type.elementsType.length;\n          assert(\n            len >= 2 && len <= 255,\n            \"Invalid type: tuples must have between 2 and 255 items.\"\n          );\n\n          // Generic tuple\n          writer.write(descriptors.tuple.genericTupleTypeCode);\n          writer.writeVLQ(len);\n        }\n      }\n\n      for (let i = 0; i < type.elementsType.length; i++) {\n        this.serialize(type.elementsType[i], writer);\n      }\n    } else {\n      throw new Error(\"Serialization error: type not implemented.\");\n    }\n  },\n\n  deserialize(r: SigmaByteReader): SType {\n    const byte = r.readByte();\n    assert(\n      byte > 0,\n      `Parsing Error: Unexpected type code '0x${byte.toString(16)}'`\n    );\n\n    if (byte < descriptors.tuple.genericTupleTypeCode) {\n      const ctorCode = Math.floor(byte / PRIMITIVE_TYPE_RANGE);\n      const embdCode = Math.floor(byte % PRIMITIVE_TYPE_RANGE);\n\n      switch (ctorCode) {\n        case constructorCode.embeddable: {\n          return getPrimitiveType(embdCode);\n        }\n        case constructorCode.simpleColl: {\n          const internal =\n            embdCode === 0 ? this.deserialize(r) : getPrimitiveType(embdCode);\n\n          return new SCollType(internal);\n        }\n        case constructorCode.nestedColl: {\n          return new SCollType(new SCollType(getPrimitiveType(embdCode)));\n        }\n        case constructorCode.pairOne: {\n          const internal =\n            embdCode === 0\n              ? [this.deserialize(r), this.deserialize(r)] // Pair of non-primitive types (`((Int, Byte), (Boolean,Box))`, etc.)\n              : [getPrimitiveType(embdCode), this.deserialize(r)]; // Pair of types where first is primitive (`(_, Int)`)\n\n          return new STupleType(internal);\n        }\n        case constructorCode.pairTwo: {\n          const internal =\n            embdCode === 0\n              ? [this.deserialize(r), this.deserialize(r), this.deserialize(r)] // Triple of types\n              : [this.deserialize(r), getPrimitiveType(embdCode)];\n\n          return new STupleType(internal);\n        }\n        case constructorCode.symmetricPair: {\n          const internal =\n            embdCode === 0\n              ? [\n                  this.deserialize(r),\n                  this.deserialize(r),\n                  this.deserialize(r),\n                  this.deserialize(r)\n                ] // Quadruple of types\n              : [getPrimitiveType(embdCode), getPrimitiveType(embdCode)]; // Symmetric pair of primitive types (`(Int, Int)`, `(Byte,Byte)`, etc.)\n\n          return new STupleType(internal);\n        }\n      }\n    }\n\n    switch (byte) {\n      case descriptors.tuple.genericTupleTypeCode: {\n        const len = r.readVlq();\n        const wrapped = new Array<SType>(len);\n        for (let i = 0; i < len; i++) {\n          wrapped[i] = this.deserialize(r);\n        }\n\n        return new STupleType(wrapped);\n      }\n      case descriptors.unit.code: {\n        return descriptors.unit;\n      }\n    }\n\n    throw new Error(\"Not implemented.\");\n  }\n};\n","import {\n  type Amount,\n  type Box,\n  type BoxCandidate,\n  byteSizeOf,\n  ensureBigInt,\n  isDefined,\n  isEmpty,\n  isUndefined,\n  type NonMandatoryRegisters,\n  some,\n  type TokenAmount\n} from \"@fleet-sdk/common\";\nimport { estimateVLQSize, SigmaByteWriter } from \"../coders\";\n\nconst MAX_UINT16_VALUE = 65535;\n\nexport function serializeBox(box: Box<Amount>): SigmaByteWriter;\nexport function serializeBox(\n  box: Box<Amount>,\n  writer: SigmaByteWriter\n): SigmaByteWriter;\nexport function serializeBox(\n  box: BoxCandidate<Amount>,\n  writer: SigmaByteWriter,\n  distinctTokenIds: string[]\n): SigmaByteWriter;\nexport function serializeBox(\n  box: Box<Amount> | BoxCandidate<Amount>,\n  writer = new SigmaByteWriter(5_0000),\n  distinctTokenIds?: string[]\n): SigmaByteWriter {\n  writer.writeBigVLQ(ensureBigInt(box.value));\n  writer.writeHex(box.ergoTree);\n  writer.writeVLQ(box.creationHeight);\n  writeTokens(writer, box.assets, distinctTokenIds);\n  writeRegisters(writer, box.additionalRegisters);\n\n  if (isDefined(distinctTokenIds)) return writer;\n  if (!isBox(box)) throw new Error(\"Invalid box type.\");\n  return writer.writeHex(box.transactionId).writeVLQ(box.index);\n}\n\nfunction isBox<T extends Amount>(\n  box: Box<Amount> | BoxCandidate<Amount>\n): box is Box<T> {\n  const castedBox = box as Box<T>;\n\n  return isDefined(castedBox.transactionId) && isDefined(castedBox.index);\n}\n\nfunction writeTokens(\n  writer: SigmaByteWriter,\n  tokens: TokenAmount<Amount>[],\n  tokenIds?: string[]\n): void {\n  if (isEmpty(tokens)) {\n    writer.write(0);\n\n    return;\n  }\n\n  writer.writeVLQ(tokens.length);\n  if (some(tokenIds)) {\n    tokens.map((token) =>\n      writer\n        .writeVLQ(tokenIds.indexOf(token.tokenId))\n        .writeBigVLQ(ensureBigInt(token.amount))\n    );\n  } else {\n    tokens.map((token) =>\n      writer.writeHex(token.tokenId).writeBigVLQ(ensureBigInt(token.amount))\n    );\n  }\n}\n\nfunction writeRegisters(\n  writer: SigmaByteWriter,\n  registers: NonMandatoryRegisters\n): void {\n  const keys = Object.keys(registers).sort();\n  let length = 0;\n\n  for (const key of keys) {\n    if (registers[key as keyof NonMandatoryRegisters]) length++;\n  }\n\n  writer.writeVLQ(length);\n  if (length === 0) return;\n\n  for (const key of keys) {\n    const register = registers[key as keyof NonMandatoryRegisters];\n    if (isDefined(register)) writer.writeHex(register);\n  }\n}\n\n/**\n * Estimates the byte size a box.\n * @returns byte size of the box.\n */\nexport function estimateBoxSize(\n  box: Box<Amount> | BoxCandidate<Amount>,\n  withValue?: Amount\n): number {\n  if (isUndefined(box.creationHeight)) {\n    throw new Error(\"Box size estimation error: creation height is undefined.\");\n  }\n\n  let size = 0;\n\n  size += estimateVLQSize(isDefined(withValue) ? withValue : box.value);\n  size += byteSizeOf(box.ergoTree);\n  size += estimateVLQSize(box.creationHeight);\n\n  size += estimateVLQSize(box.assets.length);\n  for (const asset of box.assets) {\n    size += byteSizeOf(asset.tokenId) + estimateVLQSize(asset.amount);\n  }\n\n  let registersLength = 0;\n  for (const key in box.additionalRegisters) {\n    const register =\n      box.additionalRegisters[key as keyof NonMandatoryRegisters];\n    if (register) {\n      size += byteSizeOf(register);\n      registersLength++;\n    }\n  }\n\n  size += estimateVLQSize(registersLength);\n  size += 32; // transaction id (BLAKE2b 256 hash)\n  size += estimateVLQSize(isBox(box) ? box.index : MAX_UINT16_VALUE);\n\n  return size;\n}\n","import {\n  type Amount,\n  type BoxCandidate,\n  type ContextExtension,\n  type DataInput,\n  isDefined,\n  type UnsignedInput\n} from \"@fleet-sdk/common\";\nimport { SigmaByteWriter } from \"../coders\";\nimport { serializeBox } from \"./boxSerializer\";\n\nexport type MinimalUnsignedTransaction = {\n  inputs: readonly UnsignedInput[];\n  dataInputs: readonly DataInput[];\n  outputs: readonly BoxCandidate<Amount>[];\n};\n\nexport function serializeTransaction(\n  transaction: MinimalUnsignedTransaction\n): SigmaByteWriter {\n  const writer = new SigmaByteWriter(100_000);\n\n  // write inputs\n  writer.writeVLQ(transaction.inputs.length);\n  transaction.inputs.map((input) => writeInput(writer, input));\n\n  // write data inputs\n  writer.writeVLQ(transaction.dataInputs.length);\n  transaction.dataInputs.map((dataInput) => writer.writeHex(dataInput.boxId));\n\n  // write distinct token IDs\n  const distinctTokenIds = getDistinctTokenIds(transaction.outputs);\n  writer.writeVLQ(distinctTokenIds.length);\n  distinctTokenIds.map((tokenId) => writer.writeHex(tokenId));\n\n  // write outputs\n  writer.writeVLQ(transaction.outputs.length);\n  transaction.outputs.map((output) =>\n    serializeBox(output, writer, distinctTokenIds)\n  );\n\n  return writer;\n}\n\nfunction writeInput(writer: SigmaByteWriter, input: UnsignedInput): void {\n  writer.writeHex(input.boxId);\n  writer.write(0); // empty proof\n  writeExtension(writer, input.extension);\n}\n\nfunction writeExtension(\n  writer: SigmaByteWriter,\n  extension: ContextExtension\n): void {\n  const keys = Object.keys(extension);\n  let length = 0;\n\n  for (const key of keys) {\n    const ext = extension[key as unknown as keyof ContextExtension];\n    if (isDefined(ext)) {\n      length++;\n    }\n  }\n\n  writer.writeVLQ(length);\n  if (length === 0) return;\n\n  for (const key of keys) {\n    const ext = extension[key as unknown as keyof ContextExtension];\n    if (isDefined(ext)) {\n      writer.writeVLQ(Number(key)).writeHex(ext);\n    }\n  }\n}\n\nfunction getDistinctTokenIds(outputs: readonly BoxCandidate<Amount>[]) {\n  const tokenIds = new Set<string>();\n  outputs.flatMap((output) =>\n    output.assets.map((asset) => tokenIds.add(asset.tokenId))\n  );\n\n  return Array.from(tokenIds);\n}\n"]}