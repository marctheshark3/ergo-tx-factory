import { ByteInput as ByteInput$1, blake2b256, Coder } from '@fleet-sdk/crypto';
import { Box, Amount, BoxCandidate, UnsignedInput, DataInput } from '@fleet-sdk/common';

declare class SigmaByteReader {
    #private;
    get isEmpty(): boolean;
    constructor(bytes: ByteInput$1);
    readBoolean(): boolean;
    readBits(length: number): ArrayLike<boolean>;
    readByte(): number;
    readBytes(length: number): Uint8Array;
    readVlq(): number;
    readShort(): number;
    readInt(): number;
    readLong(): bigint;
    readBigInt(): bigint;
}

declare class SigmaByteWriter {
    #private;
    get length(): number;
    constructor(length: number);
    writeBoolean(value: boolean): SigmaByteWriter;
    writeVLQ(value: number): SigmaByteWriter;
    writeBigVLQ(value: bigint): SigmaByteWriter;
    writeShort(value: number): SigmaByteWriter;
    writeInt(value: number): SigmaByteWriter;
    writeLong(value: bigint): SigmaByteWriter;
    write(byte: number): SigmaByteWriter;
    writeBytes(bytes: ArrayLike<number>): SigmaByteWriter;
    writeHex(bytesHex: string): SigmaByteWriter;
    writeBits(bits: ArrayLike<boolean>): SigmaByteWriter;
    writeBigInt(value: bigint): SigmaByteWriter;
    writeChecksum(length?: number, hashFn?: typeof blake2b256): SigmaByteWriter;
    encode<T>(coder: Coder<Uint8Array, T>): T;
    toBytes(): Uint8Array;
}

/**
 * Estimates the byte size of a given unsigned integer.
 * @param value: the value to be evaluated.
 * @returns the byte size of the value.
 */
declare function estimateVLQSize(value: number | bigint | string): number;

declare abstract class SType<I = unknown, O = I> {
    abstract get code(): number;
    abstract get embeddable(): boolean;
    coerce(data: I): O;
    abstract toString(): string;
}
declare abstract class SMonomorphicType<I, O = I> extends SType<I, O> {
    abstract get code(): number;
    get embeddable(): boolean;
}
declare abstract class SPrimitiveType<I, O = I> extends SMonomorphicType<I, O> {
    abstract get code(): number;
    get embeddable(): boolean;
}
declare abstract class SGenericType<T extends SType | SType[]> extends SType {
    #private;
    constructor(type: T);
    abstract get code(): number;
    get elementsType(): T;
    get embeddable(): boolean;
}

declare class SCollType<T extends SType = SType> extends SGenericType<T> {
    get code(): number;
    coerce<I, O>(elements: I[]): O[] | Uint8Array;
    toString(): string;
}
declare class STupleType<T extends SType[] = SType[]> extends SGenericType<T> {
    get code(): number;
    coerce<I, O>(elements: I[]): O[];
    toString(): string;
}

declare class SUnitType extends SMonomorphicType<undefined> {
    get code(): 0x62;
    toString(): string;
}

type BigIntInput = string | bigint;
type ByteInput = Uint8Array | string;
type SConstructor<T = unknown, S extends SType = SType | SCollType<SType>> = (arg?: T) => S;
type SProxy<T extends SType, I, O = I> = {
    (value: I): SConstant<O, T>;
    (value?: I): T;
};
declare const SByte: SProxy<SByteType, number, number>;
declare const SBool: SProxy<SBoolType, boolean, boolean>;
declare const SShort: SProxy<SShortType, number, number>;
declare const SInt: SProxy<SIntType, number, number>;
declare const SLong: SProxy<SLongType, BigIntInput, bigint>;
declare const SBigInt: SProxy<SBigIntType, BigIntInput, bigint>;
declare const SGroupElement: SProxy<SGroupElementType, ByteInput, Uint8Array>;
declare const SSigmaProp: SProxy<SSigmaPropType, SConstant<Uint8Array, SType<unknown, unknown>>, SConstant<Uint8Array, SType<unknown, unknown>>>;
type SUnit = (value?: undefined) => SConstant<undefined, SUnitType>;
declare const SUnit: SUnit;
type SColl = {
    <D, T extends SType>(type: SConstructor<D, T>): SConstructor<D[], T>;
    <D, T extends SByteType>(type: SConstructor<D, T>, elements: ByteInput | D[]): SConstant<Uint8Array, T>;
    <D, T extends SType>(type: SConstructor<D, T>, elements: D[]): SConstant<D[], T>;
};
declare const SColl: SColl;
type ByteInputOr<D, T extends SType> = T extends SByteType ? ByteInput | D : D;
type SPair = {
    <L, R>(left: SConstant<L>, right: SConstant<R>): SConstant<[L, R], STupleType>;
    <LD, RD, LT extends SType, RT extends SType>(left: SConstructor<LD, LT>, right: SConstructor<RD, RT>): SConstructor<[ByteInputOr<LD, LT>, ByteInputOr<RD, RT>]>;
};
declare const SPair: SPair;

declare class SBoolType extends SPrimitiveType<boolean> {
    get code(): 0x01;
    toString(): string;
}
declare class SByteType extends SPrimitiveType<number> {
    get code(): 0x02;
    toString(): string;
}
declare class SShortType extends SPrimitiveType<number> {
    get code(): 0x03;
    toString(): string;
}
declare class SIntType extends SPrimitiveType<number> {
    get code(): 0x04;
    toString(): string;
}
declare class SLongType extends SPrimitiveType<BigIntInput, bigint> {
    get code(): 0x05;
    coerce(data: BigIntInput): bigint;
    toString(): string;
}
declare class SBigIntType extends SPrimitiveType<string | bigint, bigint> {
    get code(): number;
    coerce(data: BigIntInput): bigint;
    toString(): string;
}
declare class SGroupElementType extends SPrimitiveType<ByteInput, Uint8Array> {
    get code(): 0x07;
    coerce(data: ByteInput): Uint8Array;
    toString(): string;
}
declare class SSigmaPropType extends SPrimitiveType<SConstant<Uint8Array>> {
    get code(): 0x08;
    toString(): string;
}

declare function isColl(type: SType): type is SCollType;
declare function isTuple(type: SType): type is STupleType;

declare class SConstant<D = unknown, T extends SType = SType> {
    #private;
    constructor(type: T, data: D);
    static from<D, T extends SType = SType>(bytes: ByteInput$1): SConstant<D, T>;
    get type(): T;
    get data(): D;
    toBytes(): Uint8Array;
    toHex(): string;
}
declare function decode<T>(value: ByteInput$1 | undefined): T | undefined;
declare function decode<T, K>(value: ByteInput$1 | undefined, coder: (input: T) => K): K | undefined;
/** @deprecated use `decode` instead */
declare function parse<T>(constant: ByteInput$1): T;
/** @deprecated use `decode` instead */
declare function parse<T>(constant: ByteInput$1, mode: "strict"): T;
/** @deprecated use `decode` instead */
declare function parse<T>(constant: ByteInput$1 | undefined, mode: "safe"): T | undefined;

declare function serializeBox(box: Box<Amount>): SigmaByteWriter;
declare function serializeBox(box: Box<Amount>, writer: SigmaByteWriter): SigmaByteWriter;
declare function serializeBox(box: BoxCandidate<Amount>, writer: SigmaByteWriter, distinctTokenIds: string[]): SigmaByteWriter;
/**
 * Estimates the byte size a box.
 * @returns byte size of the box.
 */
declare function estimateBoxSize(box: Box<Amount> | BoxCandidate<Amount>, withValue?: Amount): number;

type MinimalUnsignedTransaction = {
    inputs: readonly UnsignedInput[];
    dataInputs: readonly DataInput[];
    outputs: readonly BoxCandidate<Amount>[];
};
declare function serializeTransaction(transaction: MinimalUnsignedTransaction): SigmaByteWriter;

declare const dataSerializer: {
    serialize(data: unknown, type: SType, writer: SigmaByteWriter): SigmaByteWriter;
    deserialize(type: SType, reader: SigmaByteReader): unknown;
};

declare const typeSerializer: {
    serialize(type: SType, writer: SigmaByteWriter): void;
    deserialize(r: SigmaByteReader): SType;
};

export { type MinimalUnsignedTransaction, SBigInt, SBigIntType, SBool, SBoolType, SByte, SByteType, SColl, SCollType, SConstant, SGenericType, SGroupElement, SGroupElementType, SInt, SIntType, SLong, SLongType, SMonomorphicType, SPair, SPrimitiveType, SShort, SShortType, SSigmaProp, SSigmaPropType, STupleType, SType, SUnit, SUnitType, SigmaByteReader, SigmaByteWriter, dataSerializer, decode, estimateBoxSize, estimateVLQSize, isColl, isTuple, parse, serializeBox, serializeTransaction, typeSerializer };
