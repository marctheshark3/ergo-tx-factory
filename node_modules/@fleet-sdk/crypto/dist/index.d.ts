import { HexString } from '@fleet-sdk/common';
import * as _scure_base from '@scure/base';

type ByteInput = Uint8Array | HexString;
interface Coder<F, T> {
    encode(decoded: F): T;
    decode(encoded: T): F;
}
interface BytesCoder extends Coder<Uint8Array, string> {
    /**
     * Encodes an array of bytes to a string
     */
    encode: (data: Uint8Array) => string;
    /**
     * Decodes a string to an array of bytes
     */
    decode: (str: string) => Uint8Array;
}

declare function ensureBytes(input: ByteInput): Uint8Array;
declare function blake2b256(message: ByteInput): Uint8Array;
declare function sha256(message: ByteInput): Uint8Array;

declare const hex: BytesCoder;

declare const utf8: BytesCoder;

/**
 * A coder for Big Endian  `BigInt` <> `Uint8Array` conversion..
 */
declare const bigintBE: Coder<Uint8Array, bigint>;

declare const base58check: _scure_base.BytesCoder;
declare const base58: BytesCoder;
declare const base64: BytesCoder;

/**
 * Validate Elliptic Curve point
 *
 * @param pointBytes EC point bytes
 * @returns True if the point is valid
 */
declare function validateEcPoint(pointBytes: Uint8Array): boolean;

/**
 * Secure PRNG from "@noble/hashes". Uses crypto.getRandomValues, which defers to OS.
 */
declare const randomBytes: (bytesLength?: number) => Uint8Array;

export { type ByteInput, type BytesCoder, type Coder, base58, base58check, base64, bigintBE, blake2b256, ensureBytes, hex, randomBytes, sha256, utf8, validateEcPoint };
