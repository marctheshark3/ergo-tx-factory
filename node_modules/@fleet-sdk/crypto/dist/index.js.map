{"version":3,"sources":["../src/index.ts","../src/hashes.ts","../src/coders/index.ts","../src/coders/hex.ts","../src/coders/utf8.ts","../src/coders/bigintBE.ts","../src/ecpoint.ts"],"names":["hex","assertInstanceOf","assertTypeOf"],"mappings":"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","sourcesContent":["import { randomBytes as nobleRandomBytes } from \"@noble/hashes/utils\";\n\n/**\n * Secure PRNG from \"@noble/hashes\". Uses crypto.getRandomValues, which defers to OS.\n */\nexport const randomBytes = nobleRandomBytes as (\n  bytesLength?: number\n) => Uint8Array;\n\nexport * from \"./hashes\";\nexport * from \"./types\";\nexport * from \"./coders\";\nexport * from \"./ecpoint\";\n","import { blake2b } from \"@noble/hashes/blake2b\";\nimport { sha256 as _sha256 } from \"@noble/hashes/sha256\";\nimport { hex } from \"./coders\";\nimport type { ByteInput } from \"./types\";\n\nexport function ensureBytes(input: ByteInput): Uint8Array {\n  return typeof input === \"string\" ? hex.decode(input) : input;\n}\n\nexport function blake2b256(message: ByteInput): Uint8Array {\n  return blake2b(ensureBytes(message), { dkLen: 32 });\n}\n\nexport function sha256(message: ByteInput): Uint8Array {\n  return _sha256(ensureBytes(message));\n}\n","import {\n  base58check as base58checkCoder,\n  base58 as base58Coder,\n  base64 as base64Coder\n} from \"@scure/base\";\nimport { sha256 } from \"../hashes\";\nimport type { BytesCoder } from \"../types\";\n\nexport const base58check = base58checkCoder(sha256);\nexport const base58 = base58Coder as BytesCoder;\nexport const base64 = base64Coder as BytesCoder;\n\nexport { hex } from \"./hex\";\nexport { utf8 } from \"./utf8\";\nexport { bigintBE } from \"./bigintBE\";\n","import { assert, assertInstanceOf, assertTypeOf } from \"@fleet-sdk/common\";\nimport type { BytesCoder } from \"../types\";\n\nconst HEXES = Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, \"0\")\n);\n\nconst HexChar = {\n  ZERO: 48, // 0\n  NINE: 57, // 9\n  A_UP: 65, // A\n  F_UP: 70, // F\n  A_LO: 97, // a\n  F_LO: 102 // f\n} as const;\n\nfunction bytesToHex(bytes: Uint8Array): string {\n  assertInstanceOf(bytes, Uint8Array);\n\n  let hex = \"\";\n  for (let i = 0, len = bytes.length; i < len; i++) {\n    hex += HEXES[bytes[i]];\n  }\n\n  return hex;\n}\n\nfunction hexToBytes(hex: string): Uint8Array {\n  assertTypeOf(hex, \"string\");\n  assert(hex.length % 2 === 0, \"Invalid hex padding.\");\n\n  const len = hex.length / 2;\n  const bytes = new Uint8Array(len);\n  for (let i = 0, j = 0; i < len; i++) {\n    const n1 = charCodeToBase16(hex.charCodeAt(j++));\n    const n2 = charCodeToBase16(hex.charCodeAt(j++));\n    bytes[i] = n1 * 16 + n2;\n  }\n\n  return bytes;\n}\n\nfunction charCodeToBase16(char: number) {\n  if (char >= HexChar.ZERO && char <= HexChar.NINE) return char - HexChar.ZERO;\n  if (char >= HexChar.A_UP && char <= HexChar.F_UP)\n    return char - (HexChar.A_UP - 10);\n  if (char >= HexChar.A_LO && char <= HexChar.F_LO)\n    return char - (HexChar.A_LO - 10);\n\n  throw new Error(\"Invalid byte sequence.\");\n}\n\nexport const hex: BytesCoder = {\n  encode: bytesToHex,\n  decode: hexToBytes\n};\n","import { assertInstanceOf, assertTypeOf } from \"@fleet-sdk/common\";\nimport type { BytesCoder } from \"../types\";\n\nfunction bytesToUtf8(bytes: Uint8Array): string {\n  assertInstanceOf(bytes, Uint8Array);\n\n  return new TextDecoder().decode(bytes);\n}\n\nfunction utf8ToBytes(str: string): Uint8Array {\n  assertTypeOf(str, \"string\");\n\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\nexport const utf8: BytesCoder = {\n  encode: bytesToUtf8,\n  decode: utf8ToBytes\n};\n","import { hex } from \"@scure/base\";\nimport type { Coder } from \"../types\";\n\n/**\n * A coder for Big Endian  `BigInt` <> `Uint8Array` conversion..\n */\nexport const bigintBE: Coder<Uint8Array, bigint> = {\n  /**\n   * Encode a `Uint8Array` to a `BigInt`.\n   */\n  encode(data) {\n    const hexInput = hex.encode(data);\n    return BigInt(hexInput === \"\" ? \"0\" : `0x${hexInput}`);\n  },\n\n  /**\n   * Decode a `BigInt` to a `Uint8Array`.\n   */\n  decode(data) {\n    const hexData = data.toString(16);\n    return hex.decode(hexData.length % 2 ? `0${hexData}` : hexData);\n  }\n};\n","import { isEmpty } from \"@fleet-sdk/common\";\n\n/**\n * EC point type\n */\nenum EcPointType {\n  /**\n   * Compressed, positive Y coordinate\n   */\n  Compressed = 0x02,\n  /**\n   * Compressed, negative Y coordinate\n   */\n  CompressedOdd = 0x03,\n  /**\n   * Uncompressed\n   */\n  Uncompressed = 0x04\n}\n\n/**\n * Validate Elliptic Curve point\n *\n * @param pointBytes EC point bytes\n * @returns True if the point is valid\n */\nexport function validateEcPoint(pointBytes: Uint8Array) {\n  if (isEmpty(pointBytes)) return false;\n\n  switch (pointBytes[0]) {\n    case EcPointType.Compressed:\n    case EcPointType.CompressedOdd:\n      return pointBytes.length === 33;\n    case EcPointType.Uncompressed:\n      return pointBytes.length === 65;\n    default:\n      return false;\n  }\n}\n"]}