'use strict';

var utils = require('@noble/hashes/utils');
var blake2b = require('@noble/hashes/blake2b');
var sha256$1 = require('@noble/hashes/sha256');
var base = require('@scure/base');
var common = require('@fleet-sdk/common');

// src/index.ts
var HEXES = Array.from(
  { length: 256 },
  (_, i) => i.toString(16).padStart(2, "0")
);
var HexChar = {
  ZERO: 48,
  // 0
  NINE: 57,
  // 9
  A_UP: 65,
  // A
  F_UP: 70,
  // F
  A_LO: 97,
  // a
  F_LO: 102
  // f
};
function bytesToHex(bytes) {
  common.assertInstanceOf(bytes, Uint8Array);
  let hex3 = "";
  for (let i = 0, len = bytes.length; i < len; i++) {
    hex3 += HEXES[bytes[i]];
  }
  return hex3;
}
function hexToBytes(hex3) {
  common.assertTypeOf(hex3, "string");
  common.assert(hex3.length % 2 === 0, "Invalid hex padding.");
  const len = hex3.length / 2;
  const bytes = new Uint8Array(len);
  for (let i = 0, j = 0; i < len; i++) {
    const n1 = charCodeToBase16(hex3.charCodeAt(j++));
    const n2 = charCodeToBase16(hex3.charCodeAt(j++));
    bytes[i] = n1 * 16 + n2;
  }
  return bytes;
}
function charCodeToBase16(char) {
  if (char >= HexChar.ZERO && char <= HexChar.NINE) return char - HexChar.ZERO;
  if (char >= HexChar.A_UP && char <= HexChar.F_UP)
    return char - (HexChar.A_UP - 10);
  if (char >= HexChar.A_LO && char <= HexChar.F_LO)
    return char - (HexChar.A_LO - 10);
  throw new Error("Invalid byte sequence.");
}
var hex = {
  encode: bytesToHex,
  decode: hexToBytes
};
function bytesToUtf8(bytes) {
  common.assertInstanceOf(bytes, Uint8Array);
  return new TextDecoder().decode(bytes);
}
function utf8ToBytes(str) {
  common.assertTypeOf(str, "string");
  return new Uint8Array(new TextEncoder().encode(str));
}
var utf8 = {
  encode: bytesToUtf8,
  decode: utf8ToBytes
};
var bigintBE = {
  /**
   * Encode a `Uint8Array` to a `BigInt`.
   */
  encode(data) {
    const hexInput = base.hex.encode(data);
    return BigInt(hexInput === "" ? "0" : `0x${hexInput}`);
  },
  /**
   * Decode a `BigInt` to a `Uint8Array`.
   */
  decode(data) {
    const hexData = data.toString(16);
    return base.hex.decode(hexData.length % 2 ? `0${hexData}` : hexData);
  }
};

// src/coders/index.ts
var base58check = base.base58check(sha256);
var base58 = base.base58;
var base64 = base.base64;

// src/hashes.ts
function ensureBytes(input) {
  return typeof input === "string" ? hex.decode(input) : input;
}
function blake2b256(message) {
  return blake2b.blake2b(ensureBytes(message), { dkLen: 32 });
}
function sha256(message) {
  return sha256$1.sha256(ensureBytes(message));
}
function validateEcPoint(pointBytes) {
  if (common.isEmpty(pointBytes)) return false;
  switch (pointBytes[0]) {
    case 2 /* Compressed */:
    case 3 /* CompressedOdd */:
      return pointBytes.length === 33;
    case 4 /* Uncompressed */:
      return pointBytes.length === 65;
    default:
      return false;
  }
}

// src/index.ts
var randomBytes = utils.randomBytes;

exports.base58 = base58;
exports.base58check = base58check;
exports.base64 = base64;
exports.bigintBE = bigintBE;
exports.blake2b256 = blake2b256;
exports.ensureBytes = ensureBytes;
exports.hex = hex;
exports.randomBytes = randomBytes;
exports.sha256 = sha256;
exports.utf8 = utf8;
exports.validateEcPoint = validateEcPoint;
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.js.map