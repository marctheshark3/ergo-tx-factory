import { randomBytes as randomBytes$1 } from '@noble/hashes/utils';
import { blake2b } from '@noble/hashes/blake2b';
import { sha256 as sha256$1 } from '@noble/hashes/sha256';
import { base58check as base58check$1, hex as hex$1, base58 as base58$1, base64 as base64$1 } from '@scure/base';
import { isEmpty, assertInstanceOf, assertTypeOf, assert } from '@fleet-sdk/common';

// src/index.ts
var HEXES = Array.from(
  { length: 256 },
  (_, i) => i.toString(16).padStart(2, "0")
);
var HexChar = {
  ZERO: 48,
  // 0
  NINE: 57,
  // 9
  A_UP: 65,
  // A
  F_UP: 70,
  // F
  A_LO: 97,
  // a
  F_LO: 102
  // f
};
function bytesToHex(bytes) {
  assertInstanceOf(bytes, Uint8Array);
  let hex3 = "";
  for (let i = 0, len = bytes.length; i < len; i++) {
    hex3 += HEXES[bytes[i]];
  }
  return hex3;
}
function hexToBytes(hex3) {
  assertTypeOf(hex3, "string");
  assert(hex3.length % 2 === 0, "Invalid hex padding.");
  const len = hex3.length / 2;
  const bytes = new Uint8Array(len);
  for (let i = 0, j = 0; i < len; i++) {
    const n1 = charCodeToBase16(hex3.charCodeAt(j++));
    const n2 = charCodeToBase16(hex3.charCodeAt(j++));
    bytes[i] = n1 * 16 + n2;
  }
  return bytes;
}
function charCodeToBase16(char) {
  if (char >= HexChar.ZERO && char <= HexChar.NINE) return char - HexChar.ZERO;
  if (char >= HexChar.A_UP && char <= HexChar.F_UP)
    return char - (HexChar.A_UP - 10);
  if (char >= HexChar.A_LO && char <= HexChar.F_LO)
    return char - (HexChar.A_LO - 10);
  throw new Error("Invalid byte sequence.");
}
var hex = {
  encode: bytesToHex,
  decode: hexToBytes
};
function bytesToUtf8(bytes) {
  assertInstanceOf(bytes, Uint8Array);
  return new TextDecoder().decode(bytes);
}
function utf8ToBytes(str) {
  assertTypeOf(str, "string");
  return new Uint8Array(new TextEncoder().encode(str));
}
var utf8 = {
  encode: bytesToUtf8,
  decode: utf8ToBytes
};
var bigintBE = {
  /**
   * Encode a `Uint8Array` to a `BigInt`.
   */
  encode(data) {
    const hexInput = hex$1.encode(data);
    return BigInt(hexInput === "" ? "0" : `0x${hexInput}`);
  },
  /**
   * Decode a `BigInt` to a `Uint8Array`.
   */
  decode(data) {
    const hexData = data.toString(16);
    return hex$1.decode(hexData.length % 2 ? `0${hexData}` : hexData);
  }
};

// src/coders/index.ts
var base58check = base58check$1(sha256);
var base58 = base58$1;
var base64 = base64$1;

// src/hashes.ts
function ensureBytes(input) {
  return typeof input === "string" ? hex.decode(input) : input;
}
function blake2b256(message) {
  return blake2b(ensureBytes(message), { dkLen: 32 });
}
function sha256(message) {
  return sha256$1(ensureBytes(message));
}
function validateEcPoint(pointBytes) {
  if (isEmpty(pointBytes)) return false;
  switch (pointBytes[0]) {
    case 2 /* Compressed */:
    case 3 /* CompressedOdd */:
      return pointBytes.length === 33;
    case 4 /* Uncompressed */:
      return pointBytes.length === 65;
    default:
      return false;
  }
}

// src/index.ts
var randomBytes = randomBytes$1;

export { base58, base58check, base64, bigintBE, blake2b256, ensureBytes, hex, randomBytes, sha256, utf8, validateEcPoint };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.mjs.map