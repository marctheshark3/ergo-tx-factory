{"version":3,"sources":["../src/utils/assertions.ts","../src/utils/array.ts","../src/utils/bigInt.ts","../src/utils/utxo.ts","../src/utils/object.ts","../src/utils/bytes.ts","../src/types/common.ts","../src/models/collection.ts","../src/error.ts"],"names":["min","max","tokenId","Network","AddressType"],"mappings":"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","sourcesContent":["export type AssertErrorMessageInput = string | Error | (() => string);\n\n// eslint-disable-next-line @typescript-eslint/ban-types\ntype Constructable = Function;\n\ntype JSPrimitiveTypes =\n  | \"string\"\n  | \"number\"\n  | \"bigint\"\n  | \"boolean\"\n  | \"symbol\"\n  | \"undefined\"\n  | \"object\"\n  | \"function\";\n\nexport function assert(condition: boolean, error: AssertErrorMessageInput): asserts condition {\n  if (condition) return;\n\n  let err: Error | undefined = undefined;\n  switch (typeof error) {\n    case \"string\":\n      err = new Error(error);\n      break;\n    case \"function\":\n      err = new Error(error());\n      break;\n    default:\n      err = error;\n  }\n\n  throw err;\n}\n\nexport function assertTypeOf<T>(obj: T, expected: JSPrimitiveTypes): asserts obj {\n  const type = typeof obj;\n\n  if (type !== expected) {\n    throw new Error(`Expected an object of type '${expected}', got '${type}'.`);\n  }\n}\n\nconst toString = (value: unknown) => Object.prototype.toString.call(value);\nfunction getTypeName(value: unknown): string {\n  if (value === null) return \"null\";\n  const type = typeof value;\n\n  return type === \"object\" || type === \"function\" ? toString(value).slice(8, -1) : type;\n}\n\nexport function assertInstanceOf<T>(obj: T, expected: Constructable): asserts obj {\n  const condition = obj instanceof expected;\n\n  if (!condition) {\n    throw new Error(`Expected an instance of '${expected.name}', got '${getTypeName(obj)}'.`);\n  }\n}\n\nexport function isEmpty<T>(target: T | null | undefined): target is undefined | null {\n  if (!target) return true;\n\n  return Array.isArray(target) ? target.length === 0 : Object.keys(target).length === 0;\n}\n\nexport function some<T>(target: T | null | undefined): target is T {\n  return !isEmpty(target);\n}\n\nexport function isTruthy<T>(value?: T): value is NonNullable<T> {\n  return !!value;\n}\n\nexport function isFalsy<T>(value?: T): value is undefined {\n  return !value;\n}\n\nexport function isUndefined(v: unknown): v is undefined {\n  return v === undefined || v === null || Number.isNaN(v);\n}\n\nexport function isDefined<T>(v: T | undefined): v is T {\n  return !isUndefined(v);\n}\n\nexport function hasKey(o: unknown, key: PropertyKey): boolean {\n  return Object.prototype.hasOwnProperty.call(o, key);\n}\n","import { SortingDirection, SortingSelector } from \"../types\";\nimport { assert, isEmpty } from \"./assertions\";\n\ntype ObjectSelector<T> = (item: T) => T[keyof T];\n\n/**\n * Returns the first element of an array.\n * @param array\n * @throws an error if the array is empty.\n */\nexport function first(array: undefined): undefined;\nexport function first<T>(array: ArrayLike<T>): T;\nexport function first<T>(array: ArrayLike<T> | undefined): T | number | undefined {\n  if (!array) return undefined;\n  assert(array.length > 0, \"Empty array.\");\n\n  return array[0];\n}\n\n/**\n * Returns the last element of an array.\n * @param array\n * @throws an error if the array is empty.\n */\nexport function last(array: undefined): undefined;\nexport function last<T>(array: ArrayLike<T>): T;\nexport function last<T>(array: ArrayLike<T> | undefined): T | undefined {\n  if (!array) return undefined;\n  assert(array.length > 0, \"Empty array.\");\n\n  return at(array, -1);\n}\n\n/**\n * Returns the element at the specified index. Negative indices are counted from the end of the array.\n * @param array\n * @param index\n */\nexport function at(array: undefined, index: number): undefined;\nexport function at<T>(array: ArrayLike<T>, index: number): T;\nexport function at<T>(array: ArrayLike<T> | undefined, index: number): T | undefined {\n  const len = array?.length;\n  if (!len) return undefined;\n\n  if (index < 0) {\n    index += len;\n  }\n\n  return array[index];\n}\n\n/**\n * Check for duplicate elements using the equality operator\n */\nexport function hasDuplicates<T>(array: T[]): boolean {\n  return array.some((item, index) => {\n    return array.indexOf(item) !== index;\n  });\n}\n\n/**\n * Check for duplicate keys in complex elements\n */\nexport function hasDuplicatesBy<T>(array: T[], selector: ObjectSelector<T>): boolean {\n  return array.some((item, index) => {\n    return array.findIndex((x) => selector(x) === selector(item)) !== index;\n  });\n}\n\n/**\n * Turns an array into chunks of the specified size\n * @param array\n * @param size\n *\n * @example\n * ```\n * const array = [1, 2, 3, 4, 5];\n * const chunks = chunk(array, 2);\n * console.log(chunks);\n * // [[1, 2], [3, 4], [5]]\n * ```\n */\nexport function chunk<T>(array: T[], size: number): T[][] {\n  if (array.length <= size) {\n    return [array];\n  }\n\n  const chunks: T[][] = [];\n  for (let i = 0; i < array.length; i += size) {\n    chunks.push(array.slice(i, i + size));\n  }\n\n  return chunks;\n}\n\n/**\n * Sorts an array of objects by the specified property\n * @param array\n * @param iteratee\n * @param order\n *\n * @example\n * ```\n * const array = [{ name: \"John\", age: 25 }, { name: \"Jane\", age: 30 }];\n * const sorted = orderBy(array, (item) => item.age, \"desc\");\n * console.log(sorted);\n * // [{ name: \"Jane\", age: 30 }, { name: \"John\", age: 25 }]\n * ```\n */\nexport function orderBy<T>(\n  array: T[],\n  iteratee: SortingSelector<T>,\n  order: SortingDirection = \"asc\"\n): T[] {\n  return [...array].sort((a: T, b: T) => {\n    if (iteratee(a) > iteratee(b)) {\n      return order === \"asc\" ? 1 : -1;\n    } else if (iteratee(a) < iteratee(b)) {\n      return order === \"asc\" ? -1 : 1;\n    } else {\n      return 0;\n    }\n  });\n}\n\n/**\n * Checks if arrays are equal\n * @param array1\n * @param array2\n *\n * @example\n * ```\n * const array1 = [1, 2, 3];\n * const array2 = [1, 2, 3];\n * const array3 = [1, 2, 4];\n * const array4 = [1, 2, 3, 4];\n * areEqual(array1, array2); // true\n * areEqual(array1, array3); // false\n * areEqual(array1, array4); // false\n * ```\n */\nexport function areEqual<T>(array1: ArrayLike<T>, array2: ArrayLike<T>): boolean {\n  if (array1 === array2) {\n    return true;\n  }\n\n  if (array1.length != array2.length) {\n    return false;\n  }\n\n  for (let i = 0; i < array1.length; i++) {\n    if (array1[i] !== array2[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Checks if arrays are equal by the specified property\n * @param array1\n * @param array2\n * @param selector\n *\n * @example\n * ```\n * const array1 = [{ name: \"John\", age: 25 }, { name: \"Jane\", age: 30 }];\n * const array2 = [{ name: \"John\", age: 25 }, { name: \"Jane\", age: 30 }];\n * const array3 = [{ name: \"John\", age: 25 }, { name: \"Jane\", age: 31 }];\n *\n * areEqualBy(array1, array2, (item) => item.age); // true\n * areEqualBy(array1, array3, (item) => item.age); // false\n * ```\n */\nexport function areEqualBy<T>(\n  array1: ArrayLike<T>,\n  array2: ArrayLike<T>,\n  selector: ObjectSelector<T>\n): boolean {\n  if (array1 === array2) {\n    return true;\n  }\n\n  if (array1.length != array2.length) {\n    return false;\n  }\n\n  for (let i = 0; i < array1.length; i++) {\n    if (selector(array1[i]) !== selector(array2[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Checks if the array starts with the specified target\n * @param array\n * @param target\n *\n * @example\n * ```\n * const array = [1, 2, 3, 4, 5];\n * const target1 = [1, 2];\n * const target2 = [1, 3];\n *\n * startsWith(array, target1); // true\n * startsWith(array, target2); // false\n * ```\n */\nexport function startsWith<T>(array: ArrayLike<T>, target: ArrayLike<T>): boolean {\n  if (array === target) {\n    return true;\n  }\n\n  if (target.length > array.length) {\n    return false;\n  }\n\n  for (let i = 0; i < target.length; i++) {\n    if (target[i] !== array[i]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Checks if the array ends with the specified target\n * @param array\n * @param target\n *\n * @example\n * ```\n * const array = [1, 2, 3, 4, 5];\n * const target1 = [4, 5];\n * const target2 = [3, 5];\n *\n * endsWith(array, target1); // true\n * endsWith(array, target2); // false\n * ```\n */\nexport function endsWith<T>(array: ArrayLike<T>, target: ArrayLike<T>): boolean {\n  if (array === target) {\n    return true;\n  }\n\n  if (target.length > array.length) {\n    return false;\n  }\n\n  const offset = array.length - target.length;\n\n  for (let i = target.length - 1; i >= 0; i--) {\n    if (target[i] !== array[i + offset]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Makes an array unique by removing duplicate elements\n * @param array\n *\n * @example\n * ```\n * const array = [1, 2, 3, 3, 4, 5, 5];\n * const unique = uniq(array);\n * console.log(unique);\n * // [1, 2, 3, 4, 5]\n * ```\n */\nexport function uniq<T>(array: Array<T>): Array<T> {\n  if (isEmpty(array)) {\n    return array;\n  }\n\n  return Array.from(new Set(array));\n}\n\n/**\n * Makes an array unique by removing duplicate elements using the specified property\n * @param array\n * @param selector\n * @param selection\n *\n * @example\n * ```\n * const array = [{ name: \"John\", age: 25 }, { name: \"Jane\", age: 30 }, { name: \"John\", age: 30 }];\n * const unique = uniqBy(array, (item) => item.name);\n * console.log(unique);\n * // [{ name: \"John\", age: 25 }, { name: \"Jane\", age: 30 }]\n * ```\n */\nexport function uniqBy<T>(\n  array: Array<T>,\n  selector: ObjectSelector<T>,\n  selection: \"keep-first\" | \"keep-last\" = \"keep-first\"\n): Array<T> {\n  if (isEmpty(array)) {\n    return array;\n  }\n\n  return Array.from(\n    array\n      .reduce((map, e) => {\n        const key = selector(e);\n\n        if (selection === \"keep-first\" && map.has(key)) {\n          return map;\n        }\n\n        return map.set(key, e);\n      }, new Map())\n      .values()\n  );\n}\n\n/**\n * Returns the depth of an array\n * @param array\n *\n * @example\n * ```\n * const array = [1, 2, 3, [4, 5, [6, 7]]];\n * const depth = depthOf(array);\n * console.log(depth);\n * // 3\n */\nexport function depthOf(array: unknown | unknown[]): number {\n  return Array.isArray(array) ? 1 + Math.max(0, ...array.map(depthOf)) : 0;\n}\n","import { Amount } from \"../types\";\nimport { first } from \"./array\";\nimport { isEmpty, isUndefined } from \"./assertions\";\n\ntype NumberLike = string | number | bigint | boolean;\n\nexport const _0n = BigInt(0);\nexport const _1n = BigInt(1);\nexport const _7n = BigInt(7);\nexport const _10n = BigInt(10);\nexport const _63n = BigInt(63);\nexport const _127n = BigInt(127);\nexport const _128n = BigInt(128);\n\n/**\n * Ensure that the given value is a bigint\n * @param number\n */\nexport function ensureBigInt(number: NumberLike): bigint {\n  return typeof number === \"bigint\" ? number : BigInt(number);\n}\n\ntype ParsingOptions = {\n  /**\n   * Number of decimals.\n   */\n  decimals?: number;\n\n  /**\n   * Thousand mark char.\n   * Default: `.`\n   */\n  decimalMark?: string;\n};\n\n/**\n * Parse a decimal string into a bigint with options\n * @param decimalStr\n * @param options\n *\n * @example\n * undecimalize(\"129.8379183\", { decimals: 9 }) // 129837918300n\n * undecimalize(\"1\", { decimals: 2 }) // 100n\n * undecimalize(\"1\", 2) // 100n\n */\nexport function undecimalize(decimalStr: string, options?: ParsingOptions | number): bigint {\n  if (!decimalStr) {\n    return _0n;\n  }\n\n  options = typeof options == \"number\" ? { decimals: options } : options;\n  if (isUndefined(options)) {\n    options = {};\n  }\n\n  options.decimals = options.decimals || 0;\n  options.decimalMark = options.decimalMark || \".\";\n\n  const fragments = decimalStr.split(options.decimalMark);\n  if (fragments.length > 2) {\n    throw new Error(\"Invalid numeric string.\");\n  }\n\n  let [integer, decimal] = fragments;\n  integer = _removeLeadingZeros(integer);\n  const negative = integer.startsWith(\"-\") ? \"-\" : \"\";\n\n  if (!decimal) {\n    decimal = \"0\".repeat(options.decimals);\n  } else if (decimal.length < options.decimals) {\n    decimal = decimal.padEnd(options.decimals, \"0\");\n  }\n\n  return BigInt(negative + _stripNonDigits(integer + decimal));\n}\n\n/**\n * Strip all non-digits from a string\n * @param value\n */\nfunction _stripNonDigits(value: string): string {\n  return value.replace(/\\D/g, \"\");\n}\n\ntype FormattingOptions = {\n  /**\n   * Number of decimals.\n   */\n  decimals: number;\n\n  /**\n   * Thousand mark char.\n   */\n  thousandMark?: string;\n\n  /**\n   * Decimal mark char.\n   * Default: `.`\n   */\n  decimalMark?: string;\n};\n\n/**\n * Format a bigint into a decimal string with options\n * @param value\n * @param options\n *\n * @example\n * decimalize(129837918300n, { decimals: 9 }) // \"129.8379183\"\n * decimalize(100n, { decimals: 2 }) // \"1\"\n */\nexport function decimalize(value: Amount, options?: FormattingOptions | number): string {\n  value = ensureBigInt(value);\n  if (!options) {\n    return value.toString();\n  }\n\n  options = typeof options == \"number\" ? { decimals: options } : options;\n  options.decimals = options.decimals || 0;\n  options.decimalMark = options.decimalMark || \".\";\n\n  const pow = _10n ** BigInt(options.decimals);\n  const integer = value / pow;\n  const decimal = value - integer * pow;\n\n  return _buildFormattedDecimal(integer.toString(10), decimal.toString(10), options);\n}\n\n/**\n * Format a bigint percentage into a decimal string with options\n * @param value\n * @param percentage\n * @param precision\n *\n * @example\n * ```\n * percent(3498n, 1n) // 34n(1%)\n * percent(3498n, 2n) // 69n(2%)\n * percent(3498n, 10n) // 349n(10%)\n * ```\n *\n */\nexport function percent(value: bigint, percentage: bigint, precision = 2n) {\n  return (value * percentage) / 10n ** precision;\n}\n\nfunction _buildFormattedDecimal(\n  integer: string,\n  decimal: string,\n  options: FormattingOptions\n): string {\n  const integerPart = _addThousandMarks(integer, options.thousandMark);\n  const decimalPart = _stripTrailingZeros(decimal.padStart(options.decimals, \"0\"));\n\n  if (decimalPart) {\n    return `${integerPart}${options.decimalMark}${decimalPart}`;\n  } else {\n    return integerPart;\n  }\n}\n\nfunction _addThousandMarks(value: string, mark?: string): string {\n  if (!mark) {\n    return value;\n  }\n\n  return value.replace(/\\B(?=(\\d{3})+(?!\\d))/g, mark);\n}\n\nfunction _stripTrailingZeros(value: string): string {\n  if (!value.endsWith(\"0\")) {\n    return value;\n  }\n\n  return value.replace(/\\.?0+$/, \"\");\n}\n\nfunction _removeLeadingZeros(value: string): string {\n  if (!value.startsWith(\"0\")) {\n    return value;\n  }\n\n  return value.replace(/^0+\\.?/, \"\");\n}\n\n/**\n * Sum a collection of numbers by a given iteratee\n * @param collection\n * @param iteratee\n * @param condition\n *\n * @example\n * ```\n * const values = [\n *  { key: 1, value: 100n },\n *  { key: 2, value: 200n },\n *  { key: 3, value: 300n },\n *  { key: 4, value: 400n },\n *  ];\n *\n *  sumBy(values, x => x.value) // 1000n\n *  sumBy(values, x => x.value, x => x.key < 0) // 0n\n *  sumBy(values, x => x.value, x => x.key % 2 === 0) // 600n\n */\nexport function sumBy<T>(\n  collection: readonly T[],\n  iteratee: (value: T) => bigint,\n  condition?: (value: T) => boolean\n): bigint {\n  let acc = _0n;\n  if (isEmpty(collection)) {\n    return acc;\n  }\n\n  for (const item of collection) {\n    if (isUndefined(condition) || condition(item)) {\n      acc += iteratee(item);\n    }\n  }\n\n  return acc;\n}\n\n/**\n * Get the minimum value from a collection of numbers\n * @param numbers\n */\nexport function min<T extends bigint | number>(...numbers: T[]): T {\n  let min = first(numbers);\n\n  for (const num of numbers) {\n    if (num < min) {\n      min = num;\n    }\n  }\n\n  return min;\n}\n\n/**\n * Get the maximum value from a collection of numbers\n * @param numbers\n */\nexport function max<T extends bigint | number>(...numbers: T[]): T {\n  let max = first(numbers);\n\n  for (const num of numbers) {\n    if (num > max) {\n      max = num;\n    }\n  }\n\n  return max;\n}\n","import { Amount, Box, BoxCandidate, NonMandatoryRegisters, TokenAmount, TokenId } from \"../types\";\nimport { isDefined, isEmpty, isUndefined } from \"./assertions\";\nimport { ensureBigInt } from \"./bigInt\";\nimport { _0n } from \"./bigInt\";\n\nconst NANOERGS_TOKEN_ID = \"nanoErgs\";\n\n/**\n * Calculates the sum of all nanoErgs and tokens in the given boxes.\n * @param boxes\n *\n * @example\n * ```\n * const boxes = [\n *   { value: \"10\", assets: [{ tokenId: \"test\", amount: \"20\" }] },\n *   { value: 20n, assets: [{ tokenId: \"test\", amount: 30n }] }\n * ];\n *\n * const sum = utxoSum(boxes);\n * console.log(sum);\n * // { nanoErgs: 30n, tokens: [{ tokenId: \"test\", amount: 50n }] }\n * ```\n */\nexport function utxoSum(boxes: MinimalBoxAmountsArray): BoxSummary;\nexport function utxoSum(boxes: MinimalBoxAmountsArray, tokenId: TokenId): bigint;\nexport function utxoSum(boxes: MinimalBoxAmountsArray, tokenId?: TokenId): BoxSummary | bigint {\n  const balances: { [tokenId: string]: bigint } = {};\n\n  for (const box of boxes) {\n    if (isUndefined(tokenId) || tokenId === NANOERGS_TOKEN_ID) {\n      balances[NANOERGS_TOKEN_ID] = (balances[NANOERGS_TOKEN_ID] || _0n) + ensureBigInt(box.value);\n    }\n\n    if (tokenId !== NANOERGS_TOKEN_ID) {\n      for (const token of box.assets) {\n        if (isDefined(tokenId) && tokenId !== token.tokenId) {\n          continue;\n        }\n\n        balances[token.tokenId] = (balances[token.tokenId] || _0n) + ensureBigInt(token.amount);\n      }\n    }\n  }\n\n  if (isDefined(tokenId)) {\n    return balances[tokenId] || _0n;\n  }\n\n  return {\n    nanoErgs: balances[NANOERGS_TOKEN_ID] || _0n,\n    tokens: Object.keys(balances)\n      .filter((x) => x !== NANOERGS_TOKEN_ID)\n      .map((tokenId) => ({ tokenId, amount: balances[tokenId] }))\n  };\n}\n\n/**\n * Calculates the difference between two utxos or utxo sets.\n * @param minuend\n * @param subtrahend\n *\n * @example\n * ```\n * const minuend = [{ nanoErgs: 30n, tokens: [{ tokenId: \"test\", amount: 50n }] }];\n * const subtrahend = [{ nanoErgs: 10n, tokens: [{ tokenId: \"test\", amount: 20n }] }];\n * const diff = utxoDiff(minuend, subtrahend);\n * console.log(diff);\n * // { nanoErgs: 20n, tokens: [{ tokenId: \"test\", amount: 30n }] }\n * ```\n */\nexport function utxoDiff(\n  minuend: BoxSummary | Box<Amount>[],\n  subtrahend: BoxSummary | Box<Amount>[]\n): BoxSummary {\n  if (Array.isArray(minuend)) {\n    minuend = utxoSum(minuend);\n  }\n\n  if (Array.isArray(subtrahend)) {\n    subtrahend = utxoSum(subtrahend);\n  }\n\n  const tokens: TokenAmount<bigint>[] = [];\n  const nanoErgs = minuend.nanoErgs - subtrahend.nanoErgs;\n\n  for (const token of minuend.tokens) {\n    const balance =\n      token.amount - (subtrahend.tokens.find((t) => t.tokenId === token.tokenId)?.amount || _0n);\n\n    if (balance !== _0n) {\n      tokens.push({ tokenId: token.tokenId, amount: balance });\n    }\n  }\n\n  return { nanoErgs, tokens };\n}\n\nconst MIN_NON_MANDATORY_REGISTER_INDEX = 4;\nconst MAX_NON_MANDATORY_REGISTER_INDEX = 9;\n\n/**\n * Checks if the given registers are densely packed.\n * @param registers\n *\n * @example\n * ```\n * const registers = {\n *   R4: \"deadbeef\",\n *   R6: \"cafe\",\n * };\n * const result = areRegistersDenselyPacked(registers);\n * console.log(result);\n * // false\n */\nexport function areRegistersDenselyPacked(registers: NonMandatoryRegisters): boolean {\n  let lastIndex = 0;\n  for (let i = MIN_NON_MANDATORY_REGISTER_INDEX; i <= MAX_NON_MANDATORY_REGISTER_INDEX; i++) {\n    const key = `R${i}` as keyof NonMandatoryRegisters;\n    if (registers[key]) {\n      if (i === MIN_NON_MANDATORY_REGISTER_INDEX) {\n        lastIndex = i;\n        continue;\n      }\n\n      if (i - lastIndex > 1) {\n        return false;\n      }\n\n      lastIndex = i;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Filters the given utxos by the given filter parameters.\n * @param utxos\n * @param filterParams\n */\nexport function utxoFilter<T extends Amount>(utxos: Box<T>[], filterParams: UTxOFilterParams<T>) {\n  if (isEmpty(filterParams) || isEmpty(utxos)) {\n    return utxos;\n  }\n\n  const { by, max } = filterParams;\n  let filtered = utxos;\n\n  if (by) {\n    filtered = utxos.filter(by);\n    if (isEmpty(filtered)) {\n      return filtered;\n    }\n  }\n\n  if (!max) {\n    return filtered;\n  }\n\n  if (isDefined(max.aggregatedDistinctTokens)) {\n    const tokenIds = _getDistinctTokenIds(filtered, max.aggregatedDistinctTokens);\n    filtered = filtered.filter(\n      (utxo) => isEmpty(utxo.assets) || utxo.assets.every((token) => tokenIds.has(token.tokenId))\n    );\n  }\n\n  if (isDefined(max.count) && filtered.length > max.count) {\n    filtered = filtered.slice(0, max.count);\n  }\n\n  return filtered;\n}\n\nfunction _getDistinctTokenIds(utxos: Box[], max: number): Set<string> {\n  const tokenIds = new Set<string>();\n\n  for (let i = 0; i < utxos.length && tokenIds.size < max; i++) {\n    if (isEmpty(utxos[i].assets) || utxos[i].assets.length > max) {\n      continue;\n    }\n\n    for (const token of utxos[i].assets) {\n      tokenIds.add(token.tokenId);\n    }\n  }\n\n  return tokenIds;\n}\n\n/**\n * Parameters for filtering unspent transaction outputs (UTxOs).\n */\nexport type UTxOFilterParams<T extends Amount> = {\n  /**\n   * A function that returns a boolean indicating whether a given UTxO should be included in the filtered results.\n   */\n  by?: (utxo: Box<T>) => boolean;\n  /**\n   * An object specifying the maximum number of UTxOs and distinct tokens to include in the filtered results.\n   */\n  max?: {\n    /**\n     * The maximum number of UTxOs to include in the filtered results.\n     */\n    count?: number;\n    /**\n     * The maximum number of distinct tokens to include in the filtered results.\n     */\n    aggregatedDistinctTokens?: number;\n  };\n};\n\nexport type BoxSummary = {\n  nanoErgs: bigint;\n  tokens: TokenAmount<bigint>[];\n};\n\nexport type MinimalBoxAmountsArray = readonly {\n  value: Amount;\n  assets: TokenAmount<Amount>[];\n}[];\n\n/**\n * Ensures that the value and asset amounts of a given box are represented as BigInts.\n * @returns A new box object with BigInt representation for the value and asset amounts.\n */\nexport function ensureUTxOBigInt(box: Box<Amount>): Box<bigint>;\nexport function ensureUTxOBigInt(candidate: BoxCandidate<Amount>): BoxCandidate<bigint>;\nexport function ensureUTxOBigInt(\n  box: Box<Amount> | BoxCandidate<Amount>\n): BoxCandidate<bigint> | Box<bigint> {\n  return {\n    ...box,\n    value: ensureBigInt(box.value),\n    assets: box.assets.map((token) => ({\n      tokenId: token.tokenId,\n      amount: ensureBigInt(token.amount)\n    }))\n  };\n}\n","import { isEmpty, isUndefined } from \"./assertions\";\n\n/**\n * Remove undefined values from an object\n * @param value\n *\n * @example\n * ```\n * const obj = { a: 1, b: undefined };\n * const result = clearUndefined(obj);\n * console.log(result); // { a: 1 }\n * ```\n */\nexport function clearUndefined(value: Record<string, unknown>) {\n  const result: Record<string, unknown> = {};\n  for (const key in value) {\n    const val = value[key];\n    if (!isUndefined(val)) {\n      result[key] = val;\n    }\n  }\n\n  return result;\n}\n\nexport type EnsureDefaultsOptions = { keepUndefinedKeys: boolean };\n\n/**\n * Ensure that the options object has all the default values\n * @param partial\n * @param defaults\n *\n * @example\n * ```\n * const options = { a: 1 };\n * const defaults = { a: 2, b: 3 };\n * const result = ensureDefaults(options, defaults);\n * console.log(result); // { a: 1, b: 3 }\n * ```\n */\nexport function ensureDefaults<T extends object, R extends object>(\n  partial: T | undefined,\n  defaults: R,\n  options?: EnsureDefaultsOptions\n): R & T {\n  if (isEmpty(partial)) return defaults as R & T;\n  if (options?.keepUndefinedKeys) return { ...defaults, ...partial };\n\n  const merged = { ...defaults, ...partial } as Record<string, unknown>;\n  for (const key in merged) {\n    merged[key] = partial[key as keyof T] ?? defaults[key as keyof R];\n  }\n\n  return merged as R & T;\n}\n","import { assertInstanceOf } from \".\";\n\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));\n\n  let pad = 0;\n  for (const bytes of arrays) {\n    assertInstanceOf(bytes, Uint8Array);\n\n    r.set(bytes, pad);\n    pad += bytes.length;\n  }\n\n  return r;\n}\n\nexport function isHex(value?: string) {\n  if (!value || value.length % 2) return false;\n\n  if (!value.startsWith(\"0x\")) {\n    value = \"0x\" + value;\n  }\n\n  return !isNaN(Number(value));\n}\n\n/**\n * Get hex string size in bytes\n * @param hex\n * @returns the byte size if the hex string\n */\nexport function byteSizeOf(hex: string): number {\n  return hex.length / 2;\n}\n","export type HexString = string;\nexport type ErgoTreeHex = string;\nexport type Base58String = string;\nexport type Amount = string | bigint;\n\nexport type OneOrMore<T> = T | T[];\n\nexport type SortingSelector<T> = (item: T) => string | number | bigint;\nexport type SortingDirection = \"asc\" | \"desc\";\n\nexport type FilterPredicate<T> = (item: T) => boolean;\n\nexport type BuildOutputType = \"default\" | \"EIP-12\";\n\nexport enum Network {\n  Mainnet = 0x00,\n  Testnet = 0x10\n}\n\nexport enum AddressType {\n  P2PK = 1,\n  P2SH = 2,\n  P2S = 3\n}\n\nexport const ergoTreeHeaderFlags = {\n  sizeInclusion: 0x08,\n  constantSegregation: 0x10\n} as const;\n\nexport type ErgoTreeHeaderFlag = (typeof ergoTreeHeaderFlags)[keyof typeof ergoTreeHeaderFlags];\n","import { OneOrMore } from \"../types\";\nimport { isDefined } from \"../utils\";\n\nexport type CollectionAddOptions = { index?: number };\n\n/**\n * Collection abstract model\n *\n * @example\n * Define a new collection class with internal type `number` and external type `string`\n * ```\n * class TestCollection extends Collection<number, string> {\n *    protected _map(item: string | number): number {\n *      return Number(item);\n *    }\n *    // Some other methods\n *  }\n * ```\n *\n */\nexport abstract class Collection<InternalType, ExternalType> implements Iterable<InternalType> {\n  protected readonly _items: InternalType[];\n\n  constructor() {\n    this._items = [];\n  }\n\n  protected _isIndexOutOfBounds(index: number): boolean {\n    return index < 0 || index >= this._items.length;\n  }\n\n  [Symbol.iterator](): Iterator<InternalType> {\n    let counter = 0;\n\n    return {\n      next: () => {\n        return {\n          done: counter >= this.length,\n          value: this._items[counter++]\n        };\n      }\n    };\n  }\n\n  /**\n   * Number of items in the collection\n   */\n  public get length(): number {\n    return this._items.length;\n  }\n\n  /**\n   * True if the collection is empty\n   */\n  public get isEmpty(): boolean {\n    return this.length === 0;\n  }\n\n  /**\n   * Get item at index\n   * @param index\n   * @throws RangeError if index is out of bounds\n   */\n  public at(index: number): InternalType {\n    if (this._isIndexOutOfBounds(index)) {\n      throw new RangeError(`Index '${index}' is out of range.`);\n    }\n\n    return this._items[index];\n  }\n\n  /**\n   * Add item to the collection\n   * @param items\n   * @param options\n   * @returns The new length of the collection\n   */\n  public add(items: OneOrMore<ExternalType>, options?: CollectionAddOptions): number {\n    return this._addOneOrMore(items, options);\n  }\n\n  abstract remove(item: unknown): number;\n\n  /**\n   * Map external type to internal type\n   * @param item\n   * @protected\n   */\n  protected abstract _map(item: ExternalType | InternalType): InternalType;\n\n  protected _addOne(item: InternalType | ExternalType, options?: CollectionAddOptions): number {\n    if (isDefined(options) && isDefined(options.index)) {\n      if (options.index === this.length) {\n        this._items.push(this._map(item));\n\n        return this.length;\n      }\n\n      if (this._isIndexOutOfBounds(options.index)) {\n        throw new RangeError(`Index '${options.index}' is out of range.`);\n      }\n\n      this._items.splice(options.index, 0, this._map(item));\n\n      return this.length;\n    }\n\n    this._items.push(this._map(item));\n\n    return this._items.length;\n  }\n\n  protected _addOneOrMore(items: OneOrMore<ExternalType>, options?: CollectionAddOptions): number {\n    if (Array.isArray(items)) {\n      if (isDefined(options) && isDefined(options.index)) {\n        items = items.reverse();\n      }\n\n      for (const item of items) {\n        this._addOne(item, options);\n      }\n    } else {\n      this._addOne(items, options);\n    }\n\n    return this.length;\n  }\n\n  /**\n   * Get the collection as an array\n   */\n  public toArray(): InternalType[] {\n    return [...this._items];\n  }\n\n  public reduce<U>(\n    callbackFn: (\n      accumulator: U,\n      currentValue: InternalType,\n      currentIndex: number,\n      array: InternalType[]\n    ) => U,\n    initialValue: U\n  ): U {\n    return this._items.reduce(callbackFn, initialValue);\n  }\n}\n","export class FleetError extends Error {\n  constructor(message?: string, options?: ErrorOptions) {\n    super(message, options);\n\n    Object.setPrototypeOf(this, new.target.prototype);\n    this.name = new.target.name;\n  }\n}\n\nexport class NotSupportedError extends FleetError {\n  constructor(message?: string) {\n    super(message);\n  }\n}\n\nexport class BlockchainProviderError extends FleetError {\n  constructor(message?: string, options?: ErrorOptions) {\n    super(message, options);\n  }\n}\n"]}