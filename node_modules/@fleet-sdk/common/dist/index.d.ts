type HexString = string;
type ErgoTreeHex = string;
type Base58String = string;
type Amount = string | bigint;
type OneOrMore<T> = T | T[];
type SortingSelector<T> = (item: T) => string | number | bigint;
type SortingDirection = "asc" | "desc";
type FilterPredicate<T> = (item: T) => boolean;
type BuildOutputType = "default" | "EIP-12";
declare enum Network {
    Mainnet = 0,
    Testnet = 16
}
declare enum AddressType {
    P2PK = 1,
    P2SH = 2,
    P2S = 3
}
declare const ergoTreeHeaderFlags: {
    readonly sizeInclusion: 8;
    readonly constantSegregation: 16;
};
type ErgoTreeHeaderFlag = (typeof ergoTreeHeaderFlags)[keyof typeof ergoTreeHeaderFlags];

type NonMandatoryRegisters<T = HexString> = {
    R4?: T;
    R5?: T;
    R6?: T;
    R7?: T;
    R8?: T;
    R9?: T;
};

type TokenId = string;
type TokenBase<AmountType> = {
    amount: AmountType;
};
type TokenAmount<AmountType> = TokenBase<AmountType> & {
    tokenId: TokenId;
};
type NewToken<AmountType> = TokenBase<AmountType> & {
    tokenId?: TokenId;
    name?: string;
    decimals?: number;
    description?: string;
};
type TokenTargetAmount<AmountType> = {
    tokenId: TokenId;
    amount?: AmountType;
};

type ContextExtension<T = HexString> = {
    [key: number]: T | undefined;
};
type ProverResult = {
    readonly proofBytes: HexString;
    readonly extension: ContextExtension;
};
type SignedInput = {
    readonly boxId: BoxId;
    readonly spendingProof: ProverResult;
};
type UnsignedInput = {
    boxId: BoxId;
    extension: ContextExtension;
};
type EIP12UnsignedInput = UnsignedInput & {
    transactionId: TransactionId;
    index: number;
    ergoTree: ErgoTreeHex;
    creationHeight: number;
    value: string;
    assets: TokenAmount<string>[];
    additionalRegisters: NonMandatoryRegisters;
};
type EIP12UnsignedDataInput = {
    boxId: BoxId;
    transactionId: TransactionId;
    index: number;
    ergoTree: ErgoTreeHex;
    creationHeight: number;
    value: string;
    assets: TokenAmount<string>[];
    additionalRegisters: NonMandatoryRegisters;
};
type DataInput = {
    boxId: BoxId;
};

type TransactionId = string;
type UnsignedTransaction = {
    id?: TransactionId;
    inputs: UnsignedInput[];
    dataInputs: DataInput[];
    outputs: BoxCandidate<Amount>[];
};
type EIP12UnsignedTransaction = {
    id?: TransactionId;
    inputs: EIP12UnsignedInput[];
    dataInputs: EIP12UnsignedDataInput[];
    outputs: BoxCandidate<string>[];
};
type SignedTransaction = {
    readonly id: TransactionId;
    readonly inputs: SignedInput[];
    readonly dataInputs: DataInput[];
    readonly outputs: Box<string>[];
};

type BoxId = string;
type BoxBaseType<T extends Amount, R extends NonMandatoryRegisters> = {
    ergoTree: ErgoTreeHex;
    creationHeight: number;
    value: T;
    assets: TokenAmount<T>[];
    additionalRegisters: R;
};
type BoxCandidate<T extends Amount, R extends NonMandatoryRegisters = NonMandatoryRegisters> = BoxBaseType<T, R> & {
    boxId?: BoxId;
};
type Box<T extends Amount = Amount, R extends NonMandatoryRegisters = NonMandatoryRegisters> = BoxBaseType<T, R> & {
    boxId: BoxId;
    transactionId: TransactionId;
    index: number;
};

type PoWSolution = {
    pk: HexString;
    w: HexString;
    n: string;
    d: number;
};
type BlockHeaderId = string;
type BlockTransactions = {
    headerId: BlockHeaderId;
    transactions: SignedTransaction[];
};
type BlockHeader = {
    id: BlockHeaderId;
    timestamp: number;
    version: number;
    adProofsRoot: HexString;
    stateRoot: HexString;
    transactionsRoot: HexString;
    nBits: number;
    extensionHash: HexString;
    powSolutions: PoWSolution;
    height: number;
    difficulty: string;
    parentId: BlockHeaderId;
    votes: string;
    size?: number;
    extensionId?: HexString;
    transactionsId?: HexString;
    adProofsId?: HexString;
};
type Block = {
    header: BlockHeader;
    blockTransactions: BlockTransactions;
    adProofs: unknown;
    extension: unknown;
    size: number;
};

type ObjectSelector<T> = (item: T) => T[keyof T];
/**
 * Returns the first element of an array.
 * @param array
 * @throws an error if the array is empty.
 */
declare function first(array: undefined): undefined;
declare function first<T>(array: ArrayLike<T>): T;
/**
 * Returns the last element of an array.
 * @param array
 * @throws an error if the array is empty.
 */
declare function last(array: undefined): undefined;
declare function last<T>(array: ArrayLike<T>): T;
/**
 * Returns the element at the specified index. Negative indices are counted from the end of the array.
 * @param array
 * @param index
 */
declare function at(array: undefined, index: number): undefined;
declare function at<T>(array: ArrayLike<T>, index: number): T;
/**
 * Check for duplicate elements using the equality operator
 */
declare function hasDuplicates<T>(array: T[]): boolean;
/**
 * Check for duplicate keys in complex elements
 */
declare function hasDuplicatesBy<T>(array: T[], selector: ObjectSelector<T>): boolean;
/**
 * Turns an array into chunks of the specified size
 * @param array
 * @param size
 *
 * @example
 * ```
 * const array = [1, 2, 3, 4, 5];
 * const chunks = chunk(array, 2);
 * console.log(chunks);
 * // [[1, 2], [3, 4], [5]]
 * ```
 */
declare function chunk<T>(array: T[], size: number): T[][];
/**
 * Sorts an array of objects by the specified property
 * @param array
 * @param iteratee
 * @param order
 *
 * @example
 * ```
 * const array = [{ name: "John", age: 25 }, { name: "Jane", age: 30 }];
 * const sorted = orderBy(array, (item) => item.age, "desc");
 * console.log(sorted);
 * // [{ name: "Jane", age: 30 }, { name: "John", age: 25 }]
 * ```
 */
declare function orderBy<T>(array: T[], iteratee: SortingSelector<T>, order?: SortingDirection): T[];
/**
 * Checks if arrays are equal
 * @param array1
 * @param array2
 *
 * @example
 * ```
 * const array1 = [1, 2, 3];
 * const array2 = [1, 2, 3];
 * const array3 = [1, 2, 4];
 * const array4 = [1, 2, 3, 4];
 * areEqual(array1, array2); // true
 * areEqual(array1, array3); // false
 * areEqual(array1, array4); // false
 * ```
 */
declare function areEqual<T>(array1: ArrayLike<T>, array2: ArrayLike<T>): boolean;
/**
 * Checks if arrays are equal by the specified property
 * @param array1
 * @param array2
 * @param selector
 *
 * @example
 * ```
 * const array1 = [{ name: "John", age: 25 }, { name: "Jane", age: 30 }];
 * const array2 = [{ name: "John", age: 25 }, { name: "Jane", age: 30 }];
 * const array3 = [{ name: "John", age: 25 }, { name: "Jane", age: 31 }];
 *
 * areEqualBy(array1, array2, (item) => item.age); // true
 * areEqualBy(array1, array3, (item) => item.age); // false
 * ```
 */
declare function areEqualBy<T>(array1: ArrayLike<T>, array2: ArrayLike<T>, selector: ObjectSelector<T>): boolean;
/**
 * Checks if the array starts with the specified target
 * @param array
 * @param target
 *
 * @example
 * ```
 * const array = [1, 2, 3, 4, 5];
 * const target1 = [1, 2];
 * const target2 = [1, 3];
 *
 * startsWith(array, target1); // true
 * startsWith(array, target2); // false
 * ```
 */
declare function startsWith<T>(array: ArrayLike<T>, target: ArrayLike<T>): boolean;
/**
 * Checks if the array ends with the specified target
 * @param array
 * @param target
 *
 * @example
 * ```
 * const array = [1, 2, 3, 4, 5];
 * const target1 = [4, 5];
 * const target2 = [3, 5];
 *
 * endsWith(array, target1); // true
 * endsWith(array, target2); // false
 * ```
 */
declare function endsWith<T>(array: ArrayLike<T>, target: ArrayLike<T>): boolean;
/**
 * Makes an array unique by removing duplicate elements
 * @param array
 *
 * @example
 * ```
 * const array = [1, 2, 3, 3, 4, 5, 5];
 * const unique = uniq(array);
 * console.log(unique);
 * // [1, 2, 3, 4, 5]
 * ```
 */
declare function uniq<T>(array: Array<T>): Array<T>;
/**
 * Makes an array unique by removing duplicate elements using the specified property
 * @param array
 * @param selector
 * @param selection
 *
 * @example
 * ```
 * const array = [{ name: "John", age: 25 }, { name: "Jane", age: 30 }, { name: "John", age: 30 }];
 * const unique = uniqBy(array, (item) => item.name);
 * console.log(unique);
 * // [{ name: "John", age: 25 }, { name: "Jane", age: 30 }]
 * ```
 */
declare function uniqBy<T>(array: Array<T>, selector: ObjectSelector<T>, selection?: "keep-first" | "keep-last"): Array<T>;
/**
 * Returns the depth of an array
 * @param array
 *
 * @example
 * ```
 * const array = [1, 2, 3, [4, 5, [6, 7]]];
 * const depth = depthOf(array);
 * console.log(depth);
 * // 3
 */
declare function depthOf(array: unknown | unknown[]): number;

type NumberLike = string | number | bigint | boolean;
declare const _0n: bigint;
declare const _1n: bigint;
declare const _7n: bigint;
declare const _10n: bigint;
declare const _63n: bigint;
declare const _127n: bigint;
declare const _128n: bigint;
/**
 * Ensure that the given value is a bigint
 * @param number
 */
declare function ensureBigInt(number: NumberLike): bigint;
type ParsingOptions = {
    /**
     * Number of decimals.
     */
    decimals?: number;
    /**
     * Thousand mark char.
     * Default: `.`
     */
    decimalMark?: string;
};
/**
 * Parse a decimal string into a bigint with options
 * @param decimalStr
 * @param options
 *
 * @example
 * undecimalize("129.8379183", { decimals: 9 }) // 129837918300n
 * undecimalize("1", { decimals: 2 }) // 100n
 * undecimalize("1", 2) // 100n
 */
declare function undecimalize(decimalStr: string, options?: ParsingOptions | number): bigint;
type FormattingOptions = {
    /**
     * Number of decimals.
     */
    decimals: number;
    /**
     * Thousand mark char.
     */
    thousandMark?: string;
    /**
     * Decimal mark char.
     * Default: `.`
     */
    decimalMark?: string;
};
/**
 * Format a bigint into a decimal string with options
 * @param value
 * @param options
 *
 * @example
 * decimalize(129837918300n, { decimals: 9 }) // "129.8379183"
 * decimalize(100n, { decimals: 2 }) // "1"
 */
declare function decimalize(value: Amount, options?: FormattingOptions | number): string;
/**
 * Format a bigint percentage into a decimal string with options
 * @param value
 * @param percentage
 * @param precision
 *
 * @example
 * ```
 * percent(3498n, 1n) // 34n(1%)
 * percent(3498n, 2n) // 69n(2%)
 * percent(3498n, 10n) // 349n(10%)
 * ```
 *
 */
declare function percent(value: bigint, percentage: bigint, precision?: bigint): bigint;
/**
 * Sum a collection of numbers by a given iteratee
 * @param collection
 * @param iteratee
 * @param condition
 *
 * @example
 * ```
 * const values = [
 *  { key: 1, value: 100n },
 *  { key: 2, value: 200n },
 *  { key: 3, value: 300n },
 *  { key: 4, value: 400n },
 *  ];
 *
 *  sumBy(values, x => x.value) // 1000n
 *  sumBy(values, x => x.value, x => x.key < 0) // 0n
 *  sumBy(values, x => x.value, x => x.key % 2 === 0) // 600n
 */
declare function sumBy<T>(collection: readonly T[], iteratee: (value: T) => bigint, condition?: (value: T) => boolean): bigint;
/**
 * Get the minimum value from a collection of numbers
 * @param numbers
 */
declare function min<T extends bigint | number>(...numbers: T[]): T;
/**
 * Get the maximum value from a collection of numbers
 * @param numbers
 */
declare function max<T extends bigint | number>(...numbers: T[]): T;

/**
 * Calculates the sum of all nanoErgs and tokens in the given boxes.
 * @param boxes
 *
 * @example
 * ```
 * const boxes = [
 *   { value: "10", assets: [{ tokenId: "test", amount: "20" }] },
 *   { value: 20n, assets: [{ tokenId: "test", amount: 30n }] }
 * ];
 *
 * const sum = utxoSum(boxes);
 * console.log(sum);
 * // { nanoErgs: 30n, tokens: [{ tokenId: "test", amount: 50n }] }
 * ```
 */
declare function utxoSum(boxes: MinimalBoxAmountsArray): BoxSummary;
declare function utxoSum(boxes: MinimalBoxAmountsArray, tokenId: TokenId): bigint;
/**
 * Calculates the difference between two utxos or utxo sets.
 * @param minuend
 * @param subtrahend
 *
 * @example
 * ```
 * const minuend = [{ nanoErgs: 30n, tokens: [{ tokenId: "test", amount: 50n }] }];
 * const subtrahend = [{ nanoErgs: 10n, tokens: [{ tokenId: "test", amount: 20n }] }];
 * const diff = utxoDiff(minuend, subtrahend);
 * console.log(diff);
 * // { nanoErgs: 20n, tokens: [{ tokenId: "test", amount: 30n }] }
 * ```
 */
declare function utxoDiff(minuend: BoxSummary | Box<Amount>[], subtrahend: BoxSummary | Box<Amount>[]): BoxSummary;
/**
 * Checks if the given registers are densely packed.
 * @param registers
 *
 * @example
 * ```
 * const registers = {
 *   R4: "deadbeef",
 *   R6: "cafe",
 * };
 * const result = areRegistersDenselyPacked(registers);
 * console.log(result);
 * // false
 */
declare function areRegistersDenselyPacked(registers: NonMandatoryRegisters): boolean;
/**
 * Filters the given utxos by the given filter parameters.
 * @param utxos
 * @param filterParams
 */
declare function utxoFilter<T extends Amount>(utxos: Box<T>[], filterParams: UTxOFilterParams<T>): Box<T>[];
/**
 * Parameters for filtering unspent transaction outputs (UTxOs).
 */
type UTxOFilterParams<T extends Amount> = {
    /**
     * A function that returns a boolean indicating whether a given UTxO should be included in the filtered results.
     */
    by?: (utxo: Box<T>) => boolean;
    /**
     * An object specifying the maximum number of UTxOs and distinct tokens to include in the filtered results.
     */
    max?: {
        /**
         * The maximum number of UTxOs to include in the filtered results.
         */
        count?: number;
        /**
         * The maximum number of distinct tokens to include in the filtered results.
         */
        aggregatedDistinctTokens?: number;
    };
};
type BoxSummary = {
    nanoErgs: bigint;
    tokens: TokenAmount<bigint>[];
};
type MinimalBoxAmountsArray = readonly {
    value: Amount;
    assets: TokenAmount<Amount>[];
}[];
/**
 * Ensures that the value and asset amounts of a given box are represented as BigInts.
 * @returns A new box object with BigInt representation for the value and asset amounts.
 */
declare function ensureUTxOBigInt(box: Box<Amount>): Box<bigint>;
declare function ensureUTxOBigInt(candidate: BoxCandidate<Amount>): BoxCandidate<bigint>;

/**
 * Remove undefined values from an object
 * @param value
 *
 * @example
 * ```
 * const obj = { a: 1, b: undefined };
 * const result = clearUndefined(obj);
 * console.log(result); // { a: 1 }
 * ```
 */
declare function clearUndefined(value: Record<string, unknown>): Record<string, unknown>;
type EnsureDefaultsOptions = {
    keepUndefinedKeys: boolean;
};
/**
 * Ensure that the options object has all the default values
 * @param partial
 * @param defaults
 *
 * @example
 * ```
 * const options = { a: 1 };
 * const defaults = { a: 2, b: 3 };
 * const result = ensureDefaults(options, defaults);
 * console.log(result); // { a: 1, b: 3 }
 * ```
 */
declare function ensureDefaults<T extends object, R extends object>(partial: T | undefined, defaults: R, options?: EnsureDefaultsOptions): R & T;

type AssertErrorMessageInput = string | Error | (() => string);
type Constructable = Function;
type JSPrimitiveTypes = "string" | "number" | "bigint" | "boolean" | "symbol" | "undefined" | "object" | "function";
declare function assert(condition: boolean, error: AssertErrorMessageInput): asserts condition;
declare function assertTypeOf<T>(obj: T, expected: JSPrimitiveTypes): asserts obj;
declare function assertInstanceOf<T>(obj: T, expected: Constructable): asserts obj;
declare function isEmpty<T>(target: T | null | undefined): target is undefined | null;
declare function some<T>(target: T | null | undefined): target is T;
declare function isTruthy<T>(value?: T): value is NonNullable<T>;
declare function isFalsy<T>(value?: T): value is undefined;
declare function isUndefined(v: unknown): v is undefined;
declare function isDefined<T>(v: T | undefined): v is T;
declare function hasKey(o: unknown, key: PropertyKey): boolean;

declare function concatBytes(...arrays: Uint8Array[]): Uint8Array;
declare function isHex(value?: string): boolean;
/**
 * Get hex string size in bytes
 * @param hex
 * @returns the byte size if the hex string
 */
declare function byteSizeOf(hex: string): number;

type CollectionAddOptions = {
    index?: number;
};
/**
 * Collection abstract model
 *
 * @example
 * Define a new collection class with internal type `number` and external type `string`
 * ```
 * class TestCollection extends Collection<number, string> {
 *    protected _map(item: string | number): number {
 *      return Number(item);
 *    }
 *    // Some other methods
 *  }
 * ```
 *
 */
declare abstract class Collection<InternalType, ExternalType> implements Iterable<InternalType> {
    protected readonly _items: InternalType[];
    constructor();
    protected _isIndexOutOfBounds(index: number): boolean;
    [Symbol.iterator](): Iterator<InternalType>;
    /**
     * Number of items in the collection
     */
    get length(): number;
    /**
     * True if the collection is empty
     */
    get isEmpty(): boolean;
    /**
     * Get item at index
     * @param index
     * @throws RangeError if index is out of bounds
     */
    at(index: number): InternalType;
    /**
     * Add item to the collection
     * @param items
     * @param options
     * @returns The new length of the collection
     */
    add(items: OneOrMore<ExternalType>, options?: CollectionAddOptions): number;
    abstract remove(item: unknown): number;
    /**
     * Map external type to internal type
     * @param item
     * @protected
     */
    protected abstract _map(item: ExternalType | InternalType): InternalType;
    protected _addOne(item: InternalType | ExternalType, options?: CollectionAddOptions): number;
    protected _addOneOrMore(items: OneOrMore<ExternalType>, options?: CollectionAddOptions): number;
    /**
     * Get the collection as an array
     */
    toArray(): InternalType[];
    reduce<U>(callbackFn: (accumulator: U, currentValue: InternalType, currentIndex: number, array: InternalType[]) => U, initialValue: U): U;
}

declare class FleetError extends Error {
    constructor(message?: string, options?: ErrorOptions);
}
declare class NotSupportedError extends FleetError {
    constructor(message?: string);
}
declare class BlockchainProviderError extends FleetError {
    constructor(message?: string, options?: ErrorOptions);
}

export { AddressType, Amount, AssertErrorMessageInput, Base58String, Block, BlockHeader, BlockHeaderId, BlockTransactions, BlockchainProviderError, Box, BoxCandidate, BoxId, BoxSummary, BuildOutputType, Collection, CollectionAddOptions, ContextExtension, DataInput, EIP12UnsignedDataInput, EIP12UnsignedInput, EIP12UnsignedTransaction, EnsureDefaultsOptions, ErgoTreeHeaderFlag, ErgoTreeHex, FilterPredicate, FleetError, HexString, MinimalBoxAmountsArray, Network, NewToken, NonMandatoryRegisters, NotSupportedError, OneOrMore, PoWSolution, ProverResult, SignedInput, SignedTransaction, SortingDirection, SortingSelector, TokenAmount, TokenId, TokenTargetAmount, TransactionId, UTxOFilterParams, UnsignedInput, UnsignedTransaction, _0n, _10n, _127n, _128n, _1n, _63n, _7n, areEqual, areEqualBy, areRegistersDenselyPacked, assert, assertInstanceOf, assertTypeOf, at, byteSizeOf, chunk, clearUndefined, concatBytes, decimalize, depthOf, endsWith, ensureBigInt, ensureDefaults, ensureUTxOBigInt, ergoTreeHeaderFlags, first, hasDuplicates, hasDuplicatesBy, hasKey, isDefined, isEmpty, isFalsy, isHex, isTruthy, isUndefined, last, max, min, orderBy, percent, some, startsWith, sumBy, undecimalize, uniq, uniqBy, utxoDiff, utxoFilter, utxoSum };
