'use strict';

// src/utils/assertions.ts
function assert(condition, error) {
  if (condition)
    return;
  let err = void 0;
  switch (typeof error) {
    case "string":
      err = new Error(error);
      break;
    case "function":
      err = new Error(error());
      break;
    default:
      err = error;
  }
  throw err;
}
function assertTypeOf(obj, expected) {
  const type = typeof obj;
  if (type !== expected) {
    throw new Error(`Expected an object of type '${expected}', got '${type}'.`);
  }
}
var toString = (value) => Object.prototype.toString.call(value);
function getTypeName(value) {
  if (value === null)
    return "null";
  const type = typeof value;
  return type === "object" || type === "function" ? toString(value).slice(8, -1) : type;
}
function assertInstanceOf(obj, expected) {
  const condition = obj instanceof expected;
  if (!condition) {
    throw new Error(`Expected an instance of '${expected.name}', got '${getTypeName(obj)}'.`);
  }
}
function isEmpty(target) {
  if (!target)
    return true;
  return Array.isArray(target) ? target.length === 0 : Object.keys(target).length === 0;
}
function some(target) {
  return !isEmpty(target);
}
function isTruthy(value) {
  return !!value;
}
function isFalsy(value) {
  return !value;
}
function isUndefined(v) {
  return v === void 0 || v === null || Number.isNaN(v);
}
function isDefined(v) {
  return !isUndefined(v);
}
function hasKey(o, key) {
  return Object.prototype.hasOwnProperty.call(o, key);
}

// src/utils/array.ts
function first(array) {
  if (!array)
    return void 0;
  assert(array.length > 0, "Empty array.");
  return array[0];
}
function last(array) {
  if (!array)
    return void 0;
  assert(array.length > 0, "Empty array.");
  return at(array, -1);
}
function at(array, index) {
  const len = array?.length;
  if (!len)
    return void 0;
  if (index < 0) {
    index += len;
  }
  return array[index];
}
function hasDuplicates(array) {
  return array.some((item, index) => {
    return array.indexOf(item) !== index;
  });
}
function hasDuplicatesBy(array, selector) {
  return array.some((item, index) => {
    return array.findIndex((x) => selector(x) === selector(item)) !== index;
  });
}
function chunk(array, size) {
  if (array.length <= size) {
    return [array];
  }
  const chunks = [];
  for (let i = 0; i < array.length; i += size) {
    chunks.push(array.slice(i, i + size));
  }
  return chunks;
}
function orderBy(array, iteratee, order = "asc") {
  return [...array].sort((a, b) => {
    if (iteratee(a) > iteratee(b)) {
      return order === "asc" ? 1 : -1;
    } else if (iteratee(a) < iteratee(b)) {
      return order === "asc" ? -1 : 1;
    } else {
      return 0;
    }
  });
}
function areEqual(array1, array2) {
  if (array1 === array2) {
    return true;
  }
  if (array1.length != array2.length) {
    return false;
  }
  for (let i = 0; i < array1.length; i++) {
    if (array1[i] !== array2[i]) {
      return false;
    }
  }
  return true;
}
function areEqualBy(array1, array2, selector) {
  if (array1 === array2) {
    return true;
  }
  if (array1.length != array2.length) {
    return false;
  }
  for (let i = 0; i < array1.length; i++) {
    if (selector(array1[i]) !== selector(array2[i])) {
      return false;
    }
  }
  return true;
}
function startsWith(array, target) {
  if (array === target) {
    return true;
  }
  if (target.length > array.length) {
    return false;
  }
  for (let i = 0; i < target.length; i++) {
    if (target[i] !== array[i]) {
      return false;
    }
  }
  return true;
}
function endsWith(array, target) {
  if (array === target) {
    return true;
  }
  if (target.length > array.length) {
    return false;
  }
  const offset = array.length - target.length;
  for (let i = target.length - 1; i >= 0; i--) {
    if (target[i] !== array[i + offset]) {
      return false;
    }
  }
  return true;
}
function uniq(array) {
  if (isEmpty(array)) {
    return array;
  }
  return Array.from(new Set(array));
}
function uniqBy(array, selector, selection = "keep-first") {
  if (isEmpty(array)) {
    return array;
  }
  return Array.from(
    array.reduce((map, e) => {
      const key = selector(e);
      if (selection === "keep-first" && map.has(key)) {
        return map;
      }
      return map.set(key, e);
    }, /* @__PURE__ */ new Map()).values()
  );
}
function depthOf(array) {
  return Array.isArray(array) ? 1 + Math.max(0, ...array.map(depthOf)) : 0;
}

// src/utils/bigInt.ts
var _0n = BigInt(0);
var _1n = BigInt(1);
var _7n = BigInt(7);
var _10n = BigInt(10);
var _63n = BigInt(63);
var _127n = BigInt(127);
var _128n = BigInt(128);
function ensureBigInt(number) {
  return typeof number === "bigint" ? number : BigInt(number);
}
function undecimalize(decimalStr, options) {
  if (!decimalStr) {
    return _0n;
  }
  options = typeof options == "number" ? { decimals: options } : options;
  if (isUndefined(options)) {
    options = {};
  }
  options.decimals = options.decimals || 0;
  options.decimalMark = options.decimalMark || ".";
  const fragments = decimalStr.split(options.decimalMark);
  if (fragments.length > 2) {
    throw new Error("Invalid numeric string.");
  }
  let [integer, decimal] = fragments;
  integer = _removeLeadingZeros(integer);
  const negative = integer.startsWith("-") ? "-" : "";
  if (!decimal) {
    decimal = "0".repeat(options.decimals);
  } else if (decimal.length < options.decimals) {
    decimal = decimal.padEnd(options.decimals, "0");
  }
  return BigInt(negative + _stripNonDigits(integer + decimal));
}
function _stripNonDigits(value) {
  return value.replace(/\D/g, "");
}
function decimalize(value, options) {
  value = ensureBigInt(value);
  if (!options) {
    return value.toString();
  }
  options = typeof options == "number" ? { decimals: options } : options;
  options.decimals = options.decimals || 0;
  options.decimalMark = options.decimalMark || ".";
  const pow = _10n ** BigInt(options.decimals);
  const integer = value / pow;
  const decimal = value - integer * pow;
  return _buildFormattedDecimal(integer.toString(10), decimal.toString(10), options);
}
function percent(value, percentage, precision = 2n) {
  return value * percentage / 10n ** precision;
}
function _buildFormattedDecimal(integer, decimal, options) {
  const integerPart = _addThousandMarks(integer, options.thousandMark);
  const decimalPart = _stripTrailingZeros(decimal.padStart(options.decimals, "0"));
  if (decimalPart) {
    return `${integerPart}${options.decimalMark}${decimalPart}`;
  } else {
    return integerPart;
  }
}
function _addThousandMarks(value, mark) {
  if (!mark) {
    return value;
  }
  return value.replace(/\B(?=(\d{3})+(?!\d))/g, mark);
}
function _stripTrailingZeros(value) {
  if (!value.endsWith("0")) {
    return value;
  }
  return value.replace(/\.?0+$/, "");
}
function _removeLeadingZeros(value) {
  if (!value.startsWith("0")) {
    return value;
  }
  return value.replace(/^0+\.?/, "");
}
function sumBy(collection, iteratee, condition) {
  let acc = _0n;
  if (isEmpty(collection)) {
    return acc;
  }
  for (const item of collection) {
    if (isUndefined(condition) || condition(item)) {
      acc += iteratee(item);
    }
  }
  return acc;
}
function min(...numbers) {
  let min2 = first(numbers);
  for (const num of numbers) {
    if (num < min2) {
      min2 = num;
    }
  }
  return min2;
}
function max(...numbers) {
  let max2 = first(numbers);
  for (const num of numbers) {
    if (num > max2) {
      max2 = num;
    }
  }
  return max2;
}

// src/utils/utxo.ts
var NANOERGS_TOKEN_ID = "nanoErgs";
function utxoSum(boxes, tokenId) {
  const balances = {};
  for (const box of boxes) {
    if (isUndefined(tokenId) || tokenId === NANOERGS_TOKEN_ID) {
      balances[NANOERGS_TOKEN_ID] = (balances[NANOERGS_TOKEN_ID] || _0n) + ensureBigInt(box.value);
    }
    if (tokenId !== NANOERGS_TOKEN_ID) {
      for (const token of box.assets) {
        if (isDefined(tokenId) && tokenId !== token.tokenId) {
          continue;
        }
        balances[token.tokenId] = (balances[token.tokenId] || _0n) + ensureBigInt(token.amount);
      }
    }
  }
  if (isDefined(tokenId)) {
    return balances[tokenId] || _0n;
  }
  return {
    nanoErgs: balances[NANOERGS_TOKEN_ID] || _0n,
    tokens: Object.keys(balances).filter((x) => x !== NANOERGS_TOKEN_ID).map((tokenId2) => ({ tokenId: tokenId2, amount: balances[tokenId2] }))
  };
}
function utxoDiff(minuend, subtrahend) {
  if (Array.isArray(minuend)) {
    minuend = utxoSum(minuend);
  }
  if (Array.isArray(subtrahend)) {
    subtrahend = utxoSum(subtrahend);
  }
  const tokens = [];
  const nanoErgs = minuend.nanoErgs - subtrahend.nanoErgs;
  for (const token of minuend.tokens) {
    const balance = token.amount - (subtrahend.tokens.find((t) => t.tokenId === token.tokenId)?.amount || _0n);
    if (balance !== _0n) {
      tokens.push({ tokenId: token.tokenId, amount: balance });
    }
  }
  return { nanoErgs, tokens };
}
var MIN_NON_MANDATORY_REGISTER_INDEX = 4;
var MAX_NON_MANDATORY_REGISTER_INDEX = 9;
function areRegistersDenselyPacked(registers) {
  let lastIndex = 0;
  for (let i = MIN_NON_MANDATORY_REGISTER_INDEX; i <= MAX_NON_MANDATORY_REGISTER_INDEX; i++) {
    const key = `R${i}`;
    if (registers[key]) {
      if (i === MIN_NON_MANDATORY_REGISTER_INDEX) {
        lastIndex = i;
        continue;
      }
      if (i - lastIndex > 1) {
        return false;
      }
      lastIndex = i;
    }
  }
  return true;
}
function utxoFilter(utxos, filterParams) {
  if (isEmpty(filterParams) || isEmpty(utxos)) {
    return utxos;
  }
  const { by, max: max2 } = filterParams;
  let filtered = utxos;
  if (by) {
    filtered = utxos.filter(by);
    if (isEmpty(filtered)) {
      return filtered;
    }
  }
  if (!max2) {
    return filtered;
  }
  if (isDefined(max2.aggregatedDistinctTokens)) {
    const tokenIds = _getDistinctTokenIds(filtered, max2.aggregatedDistinctTokens);
    filtered = filtered.filter(
      (utxo) => isEmpty(utxo.assets) || utxo.assets.every((token) => tokenIds.has(token.tokenId))
    );
  }
  if (isDefined(max2.count) && filtered.length > max2.count) {
    filtered = filtered.slice(0, max2.count);
  }
  return filtered;
}
function _getDistinctTokenIds(utxos, max2) {
  const tokenIds = /* @__PURE__ */ new Set();
  for (let i = 0; i < utxos.length && tokenIds.size < max2; i++) {
    if (isEmpty(utxos[i].assets) || utxos[i].assets.length > max2) {
      continue;
    }
    for (const token of utxos[i].assets) {
      tokenIds.add(token.tokenId);
    }
  }
  return tokenIds;
}
function ensureUTxOBigInt(box) {
  return {
    ...box,
    value: ensureBigInt(box.value),
    assets: box.assets.map((token) => ({
      tokenId: token.tokenId,
      amount: ensureBigInt(token.amount)
    }))
  };
}

// src/utils/object.ts
function clearUndefined(value) {
  const result = {};
  for (const key in value) {
    const val = value[key];
    if (!isUndefined(val)) {
      result[key] = val;
    }
  }
  return result;
}
function ensureDefaults(partial, defaults, options) {
  if (isEmpty(partial))
    return defaults;
  if (options?.keepUndefinedKeys)
    return { ...defaults, ...partial };
  const merged = { ...defaults, ...partial };
  for (const key in merged) {
    merged[key] = partial[key] ?? defaults[key];
  }
  return merged;
}

// src/utils/bytes.ts
function concatBytes(...arrays) {
  const r = new Uint8Array(arrays.reduce((sum, a) => sum + a.length, 0));
  let pad = 0;
  for (const bytes of arrays) {
    assertInstanceOf(bytes, Uint8Array);
    r.set(bytes, pad);
    pad += bytes.length;
  }
  return r;
}
function isHex(value) {
  if (!value || value.length % 2)
    return false;
  if (!value.startsWith("0x")) {
    value = "0x" + value;
  }
  return !isNaN(Number(value));
}
function byteSizeOf(hex) {
  return hex.length / 2;
}

// src/types/common.ts
var Network = /* @__PURE__ */ ((Network2) => {
  Network2[Network2["Mainnet"] = 0] = "Mainnet";
  Network2[Network2["Testnet"] = 16] = "Testnet";
  return Network2;
})(Network || {});
var AddressType = /* @__PURE__ */ ((AddressType2) => {
  AddressType2[AddressType2["P2PK"] = 1] = "P2PK";
  AddressType2[AddressType2["P2SH"] = 2] = "P2SH";
  AddressType2[AddressType2["P2S"] = 3] = "P2S";
  return AddressType2;
})(AddressType || {});
var ergoTreeHeaderFlags = {
  sizeInclusion: 8,
  constantSegregation: 16
};

// src/models/collection.ts
var Collection = class {
  _items;
  constructor() {
    this._items = [];
  }
  _isIndexOutOfBounds(index) {
    return index < 0 || index >= this._items.length;
  }
  [Symbol.iterator]() {
    let counter = 0;
    return {
      next: () => {
        return {
          done: counter >= this.length,
          value: this._items[counter++]
        };
      }
    };
  }
  /**
   * Number of items in the collection
   */
  get length() {
    return this._items.length;
  }
  /**
   * True if the collection is empty
   */
  get isEmpty() {
    return this.length === 0;
  }
  /**
   * Get item at index
   * @param index
   * @throws RangeError if index is out of bounds
   */
  at(index) {
    if (this._isIndexOutOfBounds(index)) {
      throw new RangeError(`Index '${index}' is out of range.`);
    }
    return this._items[index];
  }
  /**
   * Add item to the collection
   * @param items
   * @param options
   * @returns The new length of the collection
   */
  add(items, options) {
    return this._addOneOrMore(items, options);
  }
  _addOne(item, options) {
    if (isDefined(options) && isDefined(options.index)) {
      if (options.index === this.length) {
        this._items.push(this._map(item));
        return this.length;
      }
      if (this._isIndexOutOfBounds(options.index)) {
        throw new RangeError(`Index '${options.index}' is out of range.`);
      }
      this._items.splice(options.index, 0, this._map(item));
      return this.length;
    }
    this._items.push(this._map(item));
    return this._items.length;
  }
  _addOneOrMore(items, options) {
    if (Array.isArray(items)) {
      if (isDefined(options) && isDefined(options.index)) {
        items = items.reverse();
      }
      for (const item of items) {
        this._addOne(item, options);
      }
    } else {
      this._addOne(items, options);
    }
    return this.length;
  }
  /**
   * Get the collection as an array
   */
  toArray() {
    return [...this._items];
  }
  reduce(callbackFn, initialValue) {
    return this._items.reduce(callbackFn, initialValue);
  }
};

// src/error.ts
var FleetError = class extends Error {
  constructor(message, options) {
    super(message, options);
    Object.setPrototypeOf(this, new.target.prototype);
    this.name = new.target.name;
  }
};
var NotSupportedError = class extends FleetError {
  constructor(message) {
    super(message);
  }
};
var BlockchainProviderError = class extends FleetError {
  constructor(message, options) {
    super(message, options);
  }
};

exports.AddressType = AddressType;
exports.BlockchainProviderError = BlockchainProviderError;
exports.Collection = Collection;
exports.FleetError = FleetError;
exports.Network = Network;
exports.NotSupportedError = NotSupportedError;
exports._0n = _0n;
exports._10n = _10n;
exports._127n = _127n;
exports._128n = _128n;
exports._1n = _1n;
exports._63n = _63n;
exports._7n = _7n;
exports.areEqual = areEqual;
exports.areEqualBy = areEqualBy;
exports.areRegistersDenselyPacked = areRegistersDenselyPacked;
exports.assert = assert;
exports.assertInstanceOf = assertInstanceOf;
exports.assertTypeOf = assertTypeOf;
exports.at = at;
exports.byteSizeOf = byteSizeOf;
exports.chunk = chunk;
exports.clearUndefined = clearUndefined;
exports.concatBytes = concatBytes;
exports.decimalize = decimalize;
exports.depthOf = depthOf;
exports.endsWith = endsWith;
exports.ensureBigInt = ensureBigInt;
exports.ensureDefaults = ensureDefaults;
exports.ensureUTxOBigInt = ensureUTxOBigInt;
exports.ergoTreeHeaderFlags = ergoTreeHeaderFlags;
exports.first = first;
exports.hasDuplicates = hasDuplicates;
exports.hasDuplicatesBy = hasDuplicatesBy;
exports.hasKey = hasKey;
exports.isDefined = isDefined;
exports.isEmpty = isEmpty;
exports.isFalsy = isFalsy;
exports.isHex = isHex;
exports.isTruthy = isTruthy;
exports.isUndefined = isUndefined;
exports.last = last;
exports.max = max;
exports.min = min;
exports.orderBy = orderBy;
exports.percent = percent;
exports.some = some;
exports.startsWith = startsWith;
exports.sumBy = sumBy;
exports.undecimalize = undecimalize;
exports.uniq = uniq;
exports.uniqBy = uniqBy;
exports.utxoDiff = utxoDiff;
exports.utxoFilter = utxoFilter;
exports.utxoSum = utxoSum;
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.js.map