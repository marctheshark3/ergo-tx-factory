import { Box, TokenTargetAmount, FilterPredicate, OneOrMore, BoxId, SortingSelector, SortingDirection, Amount, BoxCandidate, Network, HexString, AddressType, Base58String, NonMandatoryRegisters, TokenAmount, ContextExtension, BuildOutputType, UnsignedInput, EIP12UnsignedInput, DataInput, EIP12UnsignedDataInput, BoxSummary, UnsignedTransaction, EIP12UnsignedTransaction, CollectionAddOptions, TokenId, Collection, NewToken, ErgoTreeHex } from '@fleet-sdk/common';
export { AddressType, Amount, Box, Network, TokenAmount } from '@fleet-sdk/common';
import { SigmaByteWriter, SConstant as SConstant$1 } from '@fleet-sdk/serializer';
export { SBigInt, SBool, SByte, SColl, SCollType, SGroupElement, SInt, SLong, SShort, SSigmaProp, SType, SUnit } from '@fleet-sdk/serializer';
import { ByteInput } from '@fleet-sdk/crypto';

interface ISelectionStrategy {
    select(inputs: Box<bigint>[], target?: SelectionTarget): Box<bigint>[];
}

type SelectorFunction = (inputs: Box<bigint>[], target?: SelectionTarget) => Box<bigint>[];
/**
 * Custom selection strategy supports custom selections implementations.
 */
declare class CustomSelectionStrategy implements ISelectionStrategy {
    private readonly _selector;
    constructor(selector: SelectorFunction);
    select(inputs: Box<bigint>[], target?: SelectionTarget): Box<bigint>[];
}

type SelectionTarget = {
    nanoErgs?: bigint;
    tokens?: TokenTargetAmount<bigint>[];
};
declare class BoxSelector<T extends Box<bigint>> {
    private readonly _inputs;
    private _strategy?;
    private _ensureFilterPredicate?;
    private _selector?;
    private _sortDirection?;
    private _ensureInclusionBoxIds?;
    constructor(inputs: T[]);
    defineStrategy(strategy: ISelectionStrategy | SelectorFunction): BoxSelector<T>;
    select(target: SelectionTarget): T[];
    private _deepCloneTarget;
    private _getUnreachedTargets;
    ensureInclusion(predicate: FilterPredicate<Box<bigint>>): BoxSelector<T>;
    ensureInclusion(boxIds: OneOrMore<BoxId>): BoxSelector<T>;
    ensureInclusion(filter: "all"): BoxSelector<T>;
    orderBy(selector: SortingSelector<Box<bigint>>, direction?: SortingDirection): BoxSelector<T>;
    private _isISelectionStrategyImplementation;
    static buildTargetFrom(boxes: Box<Amount>[] | BoxCandidate<Amount>[]): SelectionTarget;
}

/**
 * Accumulative selection strategy accumulates inputs until the target amounts
 * value is reached, skipping detrimental inputs.
 */
declare class AccumulativeSelectionStrategy implements ISelectionStrategy {
    private _inputs;
    select(inputs: Box<bigint>[], target: SelectionTarget): Box<bigint>[];
    private _selectTokens;
    private _select;
}

/**
 * The Cherry Pick strategy accumulates inputs until the target amounts trying
 * to pick inputs with as less as possible unused tokens.
 */
declare class CherryPickSelectionStrategy extends AccumulativeSelectionStrategy {
    select(inputs: Box<bigint>[], target: SelectionTarget): Box<bigint>[];
}

/**
 * Ergo address model
 *
 * @example
 * Convert address to ErgoTree hex string
 * ```
 * const address = new Address("9eZ24iqjKywjzAti9RnWWTR3CiNnLJDAcd2MenKodcAfzc8AFTu");
 * console.log(address.ergoTree);
 * ```
 *
 * @example
 * Convert ErgoTree hex string to address string
 * ```
 * const ergoTree = "0008cd026dc059d64a50d0dbf07755c2c4a4e557e3df8afa7141868b3ab200643d437ee7"
 * const address = Address.fromErgoTree(ergoTree).toString();
 * ```
 */
declare class ErgoAddress {
    #private;
    get network(): Network;
    /**
     * ErgoTree hex string
     */
    get ergoTree(): HexString;
    get type(): AddressType;
    /**
     * New instance from ErgoTree bytes
     * @param ergoTree ErgoTree bytes
     */
    constructor(ergoTree: Uint8Array, network?: Network);
    /**
     * Create a new instance from an ErgoTree
     * @param ergoTree ErgoTree hex string
     */
    static fromErgoTree(ergoTree: ByteInput, network?: Network): ErgoAddress;
    /**
     * Create a new instance from a public key
     * @param publicKey Public key hex string
     */
    static fromPublicKey(publicKey: ByteInput, network?: Network): ErgoAddress;
    static fromHash(hash: HexString | Uint8Array, network?: Network): ErgoAddress;
    /**
     * Create a new checked instance from an address string
     * @param encodedAddress Address encoded as base58
     */
    static decode(encodedAddress: Base58String): ErgoAddress;
    static decodeUnsafe(encodedAddress: Base58String): ErgoAddress;
    static fromBase58(address: Base58String, unsafe?: boolean): ErgoAddress;
    /**
     * Validate an address
     * @param address Address bytes or string
     * @deprecated Use `validateAddress()` function instead
     */
    static validate(address: Base58String): boolean;
    static getNetworkType(address: Base58String): Network;
    static getAddressType(address: Base58String): AddressType;
    getPublicKeys(): Uint8Array[];
    toP2SH(network?: Network): Base58String;
    /**
     * Encode address as base58 string
     */
    encode(network?: Network): Base58String;
    /**
     * Encode address as base58 string
     */
    toString(network?: Network): Base58String;
}

declare class ErgoBox<R extends NonMandatoryRegisters = NonMandatoryRegisters> {
    boxId: string;
    value: bigint;
    ergoTree: string;
    creationHeight: number;
    assets: TokenAmount<bigint>[];
    additionalRegisters: R;
    transactionId: string;
    index: number;
    constructor(box: Box<Amount, R>);
    isValid(): boolean;
    static validate(box: Box<Amount> | ErgoBox): boolean;
}

type InputType<T> = T extends "default" ? UnsignedInput : EIP12UnsignedInput;
type DataInputType<T> = T extends "default" ? DataInput : EIP12UnsignedDataInput;
type InputBox<R extends NonMandatoryRegisters> = Box<Amount, R> & {
    extension?: ContextExtension;
};
type ContextExtensionInput = ContextExtension<ConstantInput>;
declare class ErgoUnsignedInput<R extends NonMandatoryRegisters = NonMandatoryRegisters> extends ErgoBox<R> {
    #private;
    get extension(): ContextExtension | undefined;
    constructor(box: InputBox<R>);
    setContextExtension(extension: ContextExtensionInput): ErgoUnsignedInput;
    /**
     * @deprecated use `setContextExtension` instead.
     */
    setContextVars(extension: ContextExtensionInput): ErgoUnsignedInput;
    toUnsignedInputObject<T extends BuildOutputType>(type: T): InputType<T>;
    toPlainObject<T extends BuildOutputType>(type: T): DataInputType<T>;
}

type Input = ErgoUnsignedInput;
type Output = BoxCandidate<bigint>;
type ReadOnlyInputs = readonly Input[];
type ReadOnlyOutputs = readonly Output[];
type TransactionType<T> = T extends "default" ? UnsignedTransaction : EIP12UnsignedTransaction;
declare class ErgoUnsignedTransaction {
    private readonly _inputs;
    private readonly _dataInputs;
    private readonly _outputs;
    constructor(inputs: Input[], dataInputs: Input[], outputs: Output[]);
    get id(): string;
    get inputs(): ReadOnlyInputs;
    get dataInputs(): ReadOnlyInputs;
    get outputs(): ReadOnlyOutputs;
    get burning(): BoxSummary;
    toPlainObject(): UnsignedTransaction;
    toPlainObject<T extends BuildOutputType>(outputType: T): TransactionType<T>;
    toEIP12Object(): EIP12UnsignedTransaction;
    toBytes(): Uint8Array;
}

declare const MAX_TOKENS_PER_BOX = 120;
type TokenAddOptions = CollectionAddOptions & {
    sum?: boolean;
};
type OutputToken<T extends Amount = Amount> = {
    tokenId?: TokenId;
    amount: T;
};
declare class TokensCollection extends Collection<OutputToken<bigint>, OutputToken> {
    #private;
    constructor();
    constructor(token: TokenAmount<Amount>);
    constructor(tokens: TokenAmount<Amount>[]);
    constructor(tokens: TokenAmount<Amount>[], options: TokenAddOptions);
    get minting(): NewToken<bigint> | undefined;
    protected _map(token: OutputToken): OutputToken<bigint>;
    protected _addOne(token: OutputToken, options?: TokenAddOptions): number;
    add(items: OneOrMore<TokenAmount<Amount>>, options?: TokenAddOptions): number;
    mint(token: NewToken<Amount>): number;
    private _sum;
    remove(tokenId: TokenId, amount?: Amount): number;
    remove(index: number, amount?: Amount): number;
    contains(tokenId: string): boolean;
    toArray(): TokenAmount<bigint>[];
    toArray(mintingTokenId: string): TokenAmount<bigint>[];
    toArray(mintingTokenId?: string): TokenAmount<bigint>[];
}

declare class InputsCollection extends Collection<ErgoUnsignedInput, Box<Amount>> {
    constructor();
    constructor(box: Box<Amount>);
    constructor(boxes: Box<Amount>[]);
    protected _map(input: Box<Amount> | ErgoUnsignedInput): ErgoUnsignedInput;
    protected _addOne(box: Box<Amount>): number;
    remove(boxId: BoxId): number;
    remove(index: number): number;
}

declare class OutputsCollection extends Collection<OutputBuilder, OutputBuilder> {
    constructor(outputs?: OneOrMore<OutputBuilder>);
    protected _map(output: OutputBuilder): OutputBuilder;
    remove(output: OutputBuilder): number;
    remove(index: number): number;
    clone(): OutputsCollection;
    sum(basis?: SelectionTarget | BoxSummary): BoxSummary;
}

declare class ErgoTree {
    private _bytes;
    constructor(input: HexString | Uint8Array);
    get header(): number;
    get version(): number;
    get hasSegregatedConstants(): boolean;
    get hasSize(): boolean;
    toBytes(): Uint8Array;
    toHex(): HexString;
    toAddress(network?: Network): ErgoAddress;
}

/**
Matches a JSON object.

This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. Don't use this as a direct return type as the user would have to double-cast it: `jsonObject as unknown as CustomResponse`. Instead, you could extend your CustomResponse type from it to ensure your type only uses JSON-compatible types: `interface CustomResponse extends JsonObject { â€¦ }`.

@category JSON
*/
type JsonObject = {[Key in string]: JsonValue} & {[Key in string]?: JsonValue | undefined};

/**
Matches a JSON array.

@category JSON
*/
type JsonArray = JsonValue[] | readonly JsonValue[];

/**
Matches any valid JSON primitive value.

@category JSON
*/
type JsonPrimitive = string | number | boolean | null;

/**
Matches any valid JSON value.

@see `Jsonify` if you need to transform a type to one that is assignable to `JsonValue`.

@category JSON
*/
type JsonValue = JsonPrimitive | JsonObject | JsonArray;

declare global {
	// eslint-disable-next-line @typescript-eslint/consistent-type-definitions -- It has to be an `interface` so that it can be merged.
	interface SymbolConstructor {
		readonly observable: symbol;
	}
}

type NetworkOptions = {
    network?: Network;
};
type ErgoMessageFromHashOptions = NetworkOptions & {
    hash: ByteInput;
};
type MessageData = Uint8Array | JsonValue | JsonObject;
type ErgoMessageFromDataOptions = NetworkOptions & {
    data: MessageData;
};
type ErgoMessageOptions = ErgoMessageFromHashOptions | ErgoMessageFromDataOptions;
declare const MessageType: {
    readonly Hash: 0;
    readonly Binary: 1;
    readonly String: 2;
    readonly Json: 3;
};
type MessageType = (typeof MessageType)[keyof typeof MessageType];
declare class ErgoMessage {
    #private;
    constructor(options: ErgoMessageOptions);
    get hash(): Uint8Array;
    get type(): MessageType;
    get network(): Network;
    static decode(encodedHash: Base58String): ErgoMessage;
    static fromBase58(encodedHash: Base58String): ErgoMessage;
    static fromData(data: MessageData, network?: Network): ErgoMessage;
    encode(network?: Network): string;
    toString(network?: Network): string;
    setNetwork(network: Network): ErgoMessage;
    getData<T extends MessageData = MessageData>(): T | undefined;
    serialize(): SigmaByteWriter;
    verify(message: MessageData): boolean;
}

/**
 * Validates a Base58 encoded address.
 *
 * @param encodedAddress - The Base58 encoded address to validate.
 * @returns A boolean indicating whether the address is valid or not.
 */
declare function validateAddress(encodedAddress: Base58String): boolean;

declare const BOX_VALUE_PER_BYTE: bigint;
declare const SAFE_MIN_BOX_VALUE: bigint;
type BoxValueEstimationCallback = (outputBuilder: OutputBuilder) => bigint;
declare function estimateMinBoxValue(valuePerByte?: bigint): BoxValueEstimationCallback;
declare class OutputBuilder {
    private readonly _address;
    private readonly _tokens;
    private _value;
    private _valueEstimator?;
    private _creationHeight?;
    private _registers;
    constructor(value: Amount | BoxValueEstimationCallback, recipient: ErgoAddress | ErgoTree | string, creationHeight?: number);
    get value(): bigint;
    get address(): ErgoAddress;
    get ergoTree(): ErgoTreeHex;
    get creationHeight(): number | undefined;
    get assets(): TokensCollection;
    get additionalRegisters(): NonMandatoryRegisters;
    get minting(): NewToken<bigint> | undefined;
    setValue(value: Amount | BoxValueEstimationCallback): OutputBuilder;
    addTokens(tokens: OneOrMore<TokenAmount<Amount>> | TokensCollection, options?: TokenAddOptions): OutputBuilder;
    addNfts(...tokenIds: TokenId[]): OutputBuilder;
    mintToken(token: NewToken<Amount>): OutputBuilder;
    setCreationHeight(height: number, options?: {
        replace: boolean;
    }): OutputBuilder;
    setAdditionalRegisters<T extends AdditionalRegistersInput>(registers: SequentialNonMandatoryRegisters<T>): OutputBuilder;
    eject(ejector: (context: {
        tokens: TokensCollection;
    }) => void): OutputBuilder;
    build(transactionInputs?: UnsignedInput[] | Box<Amount>[]): BoxCandidate<bigint>;
    estimateSize(value?: bigint): number;
}
type ConstantInput = SConstant$1 | HexString;
type AdditionalRegistersInput = NonMandatoryRegisters<ConstantInput>;
type OnlyR4Register<T = HexString> = {
    R4: T;
} & NonMandatoryRegisters<T>;
type R4ToR5Registers<T = HexString> = {
    R4: T;
    R5: T;
} & NonMandatoryRegisters<T>;
type R4ToR6Registers<T = HexString> = {
    R4: T;
    R5: T;
    R6: T;
} & NonMandatoryRegisters<T>;
type R4ToR7Registers<T = HexString> = {
    R4: T;
    R5: T;
    R6: T;
    R7: T;
} & NonMandatoryRegisters<T>;
type R4ToR8Registers<T = HexString> = {
    R4: T;
    R5: T;
    R6: T;
    R7: T;
    R8: T;
} & NonMandatoryRegisters<T>;
type R4ToR9Registers<T = HexString> = {
    R4: T;
    R5: T;
    R6: T;
    R7: T;
    R8: T;
    R9: T;
} & NonMandatoryRegisters<T>;
type SequentialNonMandatoryRegisters<T extends AdditionalRegistersInput> = T extends {
    R9: ConstantInput;
} ? R4ToR9Registers<ConstantInput> : T extends {
    R8: ConstantInput;
} ? R4ToR8Registers<ConstantInput> : T extends {
    R7: ConstantInput;
} ? R4ToR7Registers<ConstantInput> : T extends {
    R6: ConstantInput;
} ? R4ToR6Registers<ConstantInput> : T extends {
    R5: ConstantInput;
} ? R4ToR5Registers<ConstantInput> : T extends {
    R4: ConstantInput;
} ? OnlyR4Register<ConstantInput> : T;

type FleetPluginContext = {
    /**
     * Add and ensures selection of one or more inputs to the inputs list
     * @param inputs
     * @returns new list length
     */
    addInputs: (inputs: OneOrMore<Box<Amount>>) => number;
    /**
     * Add one or more data inputs to the data inputs list
     * @param dataInputs
     * @returns new list length
     */
    addDataInputs: (dataInputs: OneOrMore<Box<Amount>>, options?: CollectionAddOptions) => number;
    /**
     * Add one or more outputs to the outputs list
     * @param outputs
     * @param options
     * @returns new list length
     */
    addOutputs: (outputs: OneOrMore<OutputBuilder>, options?: CollectionAddOptions) => number;
    /**
     * Burn tokens
     * @param tokens
     * @throws Burning tokens thought a plugin, requires explicitly permission
     * from {@link TransactionBuilder.configure}, if token burning is not allowed
     * it will thrown a {@link NotAllowedTokenBurning} exception.
     */
    burnTokens: (tokens: OneOrMore<TokenAmount<Amount>>) => void;
    /**
     * Set transaction fee amount
     * @param amount amount in nanoergs
     */
    setFee: (amount: Amount) => void;
};

declare class TransactionBuilderSettings {
    private _maxDistinctTokensPerChangeBox;
    private _allowTokenBurning;
    private _allowTokenBurningFromPlugins;
    private _isolateErgOnChange;
    constructor();
    get maxTokensPerChangeBox(): number;
    get canBurnTokens(): boolean;
    get canBurnTokensFromPlugins(): boolean;
    get shouldIsolateErgOnChange(): boolean;
    /**
     * Define max number of distinct tokens per change box
     */
    setMaxTokensPerChangeBox(max: number): TransactionBuilderSettings;
    /**
     * Allows or denies token burning from all contexts
     */
    allowTokenBurning(allow?: boolean): TransactionBuilderSettings;
    /**
     * Allows or denies token burning **only** from plugins context.
     */
    allowTokenBurningFromPlugins(allow?: boolean): TransactionBuilderSettings;
    /**
     * If true, it creates an exclusive change box only for ERG.
     * This setting is especially useful for Ledger devices to
     * help on avoiding to hit the max tokens limit per transaction.
     */
    isolateErgOnChange(isolate?: boolean): TransactionBuilderSettings;
}

type SelectorSettings = Omit<BoxSelector<Box<bigint>>, "select">;
type ConfigureCallback = (settings: TransactionBuilderSettings) => void;
type SelectorCallback = (selector: SelectorSettings) => void;
type FleetPlugin = (context: FleetPluginContext) => void;
type CollectionLike<T> = {
    toArray(): T[];
};
declare const RECOMMENDED_MIN_FEE_VALUE: bigint;
declare const FEE_CONTRACT = "1005040004000e36100204a00b08cd0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798ea02d192a39a8cc7a701730073011001020402d19683030193a38cc7b2a57300000193c2b2a57301007473027303830108cdeeac93b1a57304";
type EjectorContext = {
    inputs: InputsCollection;
    dataInputs: InputsCollection;
    outputs: OutputsCollection;
    burning: TokensCollection | undefined;
    settings: TransactionBuilderSettings;
    selection: (selectorCallBack: SelectorCallback) => void;
};
declare class TransactionBuilder {
    private readonly _inputs;
    private readonly _dataInputs;
    private readonly _outputs;
    private readonly _settings;
    private readonly _creationHeight;
    private _selectorCallbacks?;
    private _changeAddress?;
    private _feeAmount?;
    private _burning?;
    private _plugins?;
    constructor(creationHeight: number);
    get inputs(): InputsCollection;
    get dataInputs(): InputsCollection;
    get outputs(): OutputsCollection;
    get changeAddress(): ErgoAddress | undefined;
    get fee(): bigint | undefined;
    get burning(): TokensCollection | undefined;
    get settings(): TransactionBuilderSettings;
    get creationHeight(): number;
    /**
     * Syntax sugar to be used in composition with another methods
     *
     * @example
     * ```
     * new TransactionBuilder(height)
     *   .from(inputs)
     *   .and.from(otherInputs);
     * ```
     */
    get and(): TransactionBuilder;
    from(inputs: OneOrMore<Box<Amount>> | CollectionLike<Box<Amount>>): TransactionBuilder;
    to(outputs: OneOrMore<OutputBuilder>, options?: CollectionAddOptions): TransactionBuilder;
    withDataFrom(dataInputs: OneOrMore<Box<Amount>>, options?: CollectionAddOptions): TransactionBuilder;
    sendChangeTo(address: ErgoAddress | Base58String | HexString): TransactionBuilder;
    payFee(amount: Amount): TransactionBuilder;
    payMinFee(): TransactionBuilder;
    burnTokens(tokens: OneOrMore<TokenAmount<Amount>>): TransactionBuilder;
    configure(callback: ConfigureCallback): TransactionBuilder;
    configureSelector(selectorCallback: SelectorCallback): TransactionBuilder;
    extend(plugins: FleetPlugin): TransactionBuilder;
    eject(ejector: (context: EjectorContext) => void): TransactionBuilder;
    build(): ErgoUnsignedTransaction;
    private _isMinting;
    private _isMoreThanOneTokenBeingMinted;
    private _isTheSameTokenBeingMintedFromOutsideTheMintingBox;
    private _getMintingTokenId;
}

declare class DuplicateInputError extends Error {
    constructor(boxId: string);
}

declare class DuplicateInputSelectionError extends Error {
    constructor();
}

declare class InsufficientInputs extends Error {
    readonly unreached: SelectionTarget;
    constructor(unreached: SelectionTarget);
}

declare class InsufficientTokenAmount extends Error {
}

declare class InvalidAddress extends Error {
    constructor(address: string);
}

declare class InvalidInput extends Error {
    constructor(boxId: string);
}

declare class InvalidRegistersPacking extends Error {
    constructor();
}

declare class MalformedTransaction extends Error {
    constructor(message: string);
}

declare class MaxTokensOverflow extends Error {
    constructor();
}

declare class NotAllowedTokenBurning extends Error {
    constructor();
}

declare class NotFoundError extends Error {
}

declare class UndefinedCreationHeight extends Error {
    constructor();
}

declare class UndefinedMintingContext extends Error {
    constructor();
}

/**
 * @deprecated Use {@link @fleet-sdk/serializer} instead.
 * This function will be removed from core package in v1.0.0.
 */
declare function SConstant(constant: SConstant$1): HexString;
/**
 * @deprecated Use {@link @fleet-sdk/serializer} instead.
 * This function will be removed from core package in v1.0.0.
 */
declare function SParse<T>(bytes: HexString | Uint8Array): T;

export { AccumulativeSelectionStrategy, type AdditionalRegistersInput, BOX_VALUE_PER_BYTE, BoxSelector, type BoxValueEstimationCallback, CherryPickSelectionStrategy, type CollectionLike, type ConfigureCallback, type ConstantInput, CustomSelectionStrategy, DuplicateInputError, DuplicateInputSelectionError, ErgoAddress, ErgoBox, ErgoMessage, type ErgoMessageFromDataOptions, type ErgoMessageFromHashOptions, type ErgoMessageOptions, ErgoTree, ErgoUnsignedInput, ErgoUnsignedTransaction, FEE_CONTRACT, type FleetPlugin, InputsCollection, InsufficientInputs, InsufficientTokenAmount, InvalidAddress, InvalidInput, InvalidRegistersPacking, MAX_TOKENS_PER_BOX, MalformedTransaction, MaxTokensOverflow, type MessageData, MessageType, type NetworkOptions, NotAllowedTokenBurning, NotFoundError, type OnlyR4Register, OutputBuilder, type OutputToken, OutputsCollection, type R4ToR5Registers, type R4ToR6Registers, type R4ToR7Registers, type R4ToR8Registers, type R4ToR9Registers, RECOMMENDED_MIN_FEE_VALUE, SAFE_MIN_BOX_VALUE, SConstant, SParse, type SelectorCallback, type SequentialNonMandatoryRegisters, type TokenAddOptions, TokensCollection, TransactionBuilder, UndefinedCreationHeight, UndefinedMintingContext, estimateMinBoxValue, validateAddress };
