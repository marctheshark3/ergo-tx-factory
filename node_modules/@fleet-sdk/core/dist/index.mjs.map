{"version":3,"sources":["../src/builder/selector/boxSelector.ts","../src/errors/duplicateInputSelectionError.ts","../src/errors/insufficientInputs.ts","../src/builder/selector/strategies/accumulativeSelectionStrategy.ts","../src/builder/selector/strategies/customSelectionStrategy.ts","../src/builder/selector/strategies/cherryPickSelectionStrategy.ts","../src/builder/outputBuilder.ts","../src/errors/duplicateInputError.ts","../src/errors/insufficientTokenAmount.ts","../src/errors/invalidAddress.ts","../src/errors/invalidInput.ts","../src/errors/invalidRegistersPacking.ts","../src/errors/malformedTransaction.ts","../src/models/collections/tokensCollection.ts","../src/errors/maxTokensOverflow.ts","../src/errors/notAllowedTokenBurning.ts","../src/errors/notFoundError.ts","../src/errors/undefinedCreationHeight.ts","../src/errors/undefinedMintingContext.ts","../src/models/ergoAddress.ts","../src/models/utils.ts","../src/models/ergoBox.ts","../src/models/ergoUnsignedInput.ts","../src/models/ergoUnsignedTransaction.ts","../src/models/collections/inputsCollection.ts","../src/models/collections/outputsCollection.ts","../src/models/ergoTree.ts","../src/models/ergoMessage.ts","../src/builder/transactionBuilder.ts","../src/errors/nonStandardizedMinting.ts","../src/builder/pluginContext.ts","../src/builder/transactionBuilderSettings.ts","../src/constantSerializer.ts","../src/index.ts"],"names":["_0n","isEmpty","isUndefined","some","sumBy","utxoSum","orderBy","ensureBigInt","isDefined","isHex","utf8","AddressType","concatBytes","first","base58","blake2b256","validateEcPoint","hex","Collection","Network","areEqual","ensureBytes","SigmaByteWriter","utxoDiff","SByte","SColl"],"mappings":"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","sourcesContent":["import {\n  _0n,\n  type Amount,\n  type Box,\n  type BoxCandidate,\n  type BoxId,\n  ensureBigInt,\n  type FilterPredicate,\n  first,\n  hasDuplicatesBy,\n  isEmpty,\n  isUndefined,\n  type OneOrMore,\n  orderBy,\n  some,\n  type SortingDirection,\n  type SortingSelector,\n  sumBy,\n  type TokenTargetAmount,\n  utxoSum\n} from \"@fleet-sdk/common\";\nimport { DuplicateInputSelectionError } from \"../../errors/duplicateInputSelectionError\";\nimport { InsufficientInputs } from \"../../errors/insufficientInputs\";\nimport type { ISelectionStrategy } from \"./strategies/ISelectionStrategy\";\nimport { AccumulativeSelectionStrategy } from \"./strategies/accumulativeSelectionStrategy\";\nimport {\n  CustomSelectionStrategy,\n  type SelectorFunction\n} from \"./strategies/customSelectionStrategy\";\n\nexport type SelectionTarget = {\n  nanoErgs?: bigint;\n  tokens?: TokenTargetAmount<bigint>[];\n};\n\nexport class BoxSelector<T extends Box<bigint>> {\n  private readonly _inputs: Box<bigint>[];\n  private _strategy?: ISelectionStrategy;\n  private _ensureFilterPredicate?: FilterPredicate<Box<bigint>>;\n  private _selector?: SortingSelector<Box<bigint>>;\n  private _sortDirection?: SortingDirection;\n  private _ensureInclusionBoxIds?: Set<BoxId>;\n\n  constructor(inputs: T[]) {\n    this._inputs = inputs;\n  }\n\n  public defineStrategy(\n    strategy: ISelectionStrategy | SelectorFunction\n  ): BoxSelector<T> {\n    if (this._isISelectionStrategyImplementation(strategy)) {\n      this._strategy = strategy;\n    } else {\n      this._strategy = new CustomSelectionStrategy(strategy);\n    }\n\n    return this;\n  }\n\n  public select(target: SelectionTarget): T[] {\n    if (!this._strategy) {\n      this._strategy = new AccumulativeSelectionStrategy();\n    }\n\n    const remaining = this._deepCloneTarget(target);\n    let unselected = [...this._inputs];\n    let selected: Box<bigint>[] = [];\n\n    const predicate = this._ensureFilterPredicate;\n    const inclusion = this._ensureInclusionBoxIds;\n\n    if (predicate) {\n      if (inclusion) {\n        selected = unselected.filter(\n          (box) => predicate(box) || inclusion.has(box.boxId)\n        );\n      } else {\n        selected = unselected.filter(predicate);\n      }\n    } else if (inclusion) {\n      selected = unselected.filter((box) => inclusion.has(box.boxId));\n    }\n\n    if (some(selected)) {\n      unselected = unselected.filter(\n        (box) => !selected.some((sel) => sel.boxId === box.boxId)\n      );\n\n      if (remaining.nanoErgs && remaining.nanoErgs > _0n) {\n        remaining.nanoErgs -= sumBy(selected, (input) => input.value);\n      }\n\n      if (\n        some(remaining.tokens) &&\n        selected.some((input) => !isEmpty(input.assets))\n      ) {\n        for (const t of remaining.tokens) {\n          if (t.amount && t.amount > _0n) {\n            t.amount -= utxoSum(selected, t.tokenId);\n          }\n        }\n      }\n    }\n\n    if (this._selector) {\n      unselected = orderBy(\n        unselected,\n        this._selector,\n        this._sortDirection || \"asc\"\n      );\n    }\n\n    selected = selected.concat(this._strategy.select(unselected, remaining));\n\n    if (hasDuplicatesBy(selected, (item) => item.boxId)) {\n      throw new DuplicateInputSelectionError();\n    }\n\n    const unreached = this._getUnreachedTargets(selected, target);\n    if (unreached.nanoErgs || some(unreached.tokens)) {\n      throw new InsufficientInputs(unreached);\n    }\n\n    return selected as T[];\n  }\n\n  private _deepCloneTarget(target: SelectionTarget): SelectionTarget {\n    return {\n      nanoErgs: target.nanoErgs,\n      tokens: target.tokens\n        ? target.tokens.map((t) => ({ tokenId: t.tokenId, amount: t.amount }))\n        : undefined\n    };\n  }\n\n  private _getUnreachedTargets(\n    inputs: Box<bigint>[],\n    target: SelectionTarget\n  ): SelectionTarget {\n    const unreached: SelectionTarget = {\n      nanoErgs: undefined,\n      tokens: undefined\n    };\n    const selectedNanoergs = sumBy(inputs, (input) => input.value);\n\n    if (target.nanoErgs && target.nanoErgs > selectedNanoergs) {\n      unreached.nanoErgs = target.nanoErgs - selectedNanoergs;\n    }\n\n    if (isEmpty(target.tokens)) {\n      return unreached;\n    }\n\n    for (const tokenTarget of target.tokens) {\n      const totalSelected = utxoSum(inputs, tokenTarget.tokenId);\n      if (tokenTarget.amount && tokenTarget.amount > totalSelected) {\n        if (tokenTarget.tokenId === first(inputs).boxId) {\n          continue;\n        }\n\n        if (isUndefined(unreached.tokens)) {\n          unreached.tokens = [];\n        }\n\n        unreached.tokens.push({\n          tokenId: tokenTarget.tokenId,\n          amount: tokenTarget.amount - totalSelected\n        });\n      }\n    }\n\n    return unreached;\n  }\n\n  public ensureInclusion(\n    predicate: FilterPredicate<Box<bigint>>\n  ): BoxSelector<T>;\n  public ensureInclusion(boxIds: OneOrMore<BoxId>): BoxSelector<T>;\n  public ensureInclusion(filter: \"all\"): BoxSelector<T>;\n  public ensureInclusion(\n    predicateOrBoxIds: FilterPredicate<Box<bigint>> | OneOrMore<BoxId> | \"all\"\n  ): BoxSelector<T> {\n    if (typeof predicateOrBoxIds === \"function\") {\n      this._ensureFilterPredicate = predicateOrBoxIds;\n    } else if (predicateOrBoxIds === \"all\") {\n      this._ensureFilterPredicate = (box) => box.value > 0n;\n    } else {\n      if (isUndefined(this._ensureInclusionBoxIds)) {\n        this._ensureInclusionBoxIds = new Set();\n      }\n\n      if (Array.isArray(predicateOrBoxIds)) {\n        for (const boxId of predicateOrBoxIds) {\n          this._ensureInclusionBoxIds.add(boxId);\n        }\n      } else {\n        this._ensureInclusionBoxIds.add(predicateOrBoxIds);\n      }\n    }\n\n    return this;\n  }\n\n  public orderBy(\n    selector: SortingSelector<Box<bigint>>,\n    direction?: SortingDirection\n  ): BoxSelector<T> {\n    this._selector = selector;\n    this._sortDirection = direction;\n\n    return this;\n  }\n\n  private _isISelectionStrategyImplementation(\n    obj: unknown\n  ): obj is ISelectionStrategy {\n    if ((obj as ISelectionStrategy).select) {\n      return true;\n    }\n\n    return false;\n  }\n\n  public static buildTargetFrom(\n    boxes: Box<Amount>[] | BoxCandidate<Amount>[]\n  ): SelectionTarget {\n    const tokens: { [tokenId: string]: bigint } = {};\n    let nanoErgs = _0n;\n\n    for (const box of boxes) {\n      nanoErgs += ensureBigInt(box.value);\n      for (const token of box.assets) {\n        tokens[token.tokenId] =\n          (tokens[token.tokenId] || _0n) + ensureBigInt(token.amount);\n      }\n    }\n\n    return {\n      nanoErgs,\n      tokens: Object.keys(tokens).map((tokenId) => ({\n        tokenId,\n        amount: tokens[tokenId]\n      }))\n    };\n  }\n}\n","export class DuplicateInputSelectionError extends Error {\n  constructor() {\n    super(\n      \"One or more inputs was selected more than one time by the current selection strategy.\"\n    );\n  }\n}\n","import { some } from \"@fleet-sdk/common\";\nimport type { SelectionTarget } from \"../builder/selector/boxSelector\";\n\nexport class InsufficientInputs extends Error {\n  readonly unreached: SelectionTarget;\n\n  constructor(unreached: SelectionTarget) {\n    const strings = [];\n    if (unreached.nanoErgs) {\n      strings.push(buildString(\"nanoErgs\", unreached.nanoErgs));\n    }\n\n    if (some(unreached.tokens)) {\n      for (const token of unreached.tokens) {\n        strings.push(buildString(token.tokenId, token.amount));\n      }\n    }\n\n    super(`Insufficient inputs:${strings.join()}`);\n\n    this.unreached = unreached;\n  }\n}\n\nfunction buildString(tokenId: string, amount?: bigint): string {\n  return `\\n  > ${tokenId}: ${amount?.toString()}`;\n}\n","import {\n  type Box,\n  isDefined,\n  some,\n  type TokenId,\n  type TokenTargetAmount\n} from \"@fleet-sdk/common\";\nimport { _0n, isEmpty, isUndefined, sumBy, utxoSum } from \"@fleet-sdk/common\";\nimport type { SelectionTarget } from \"../boxSelector\";\nimport type { ISelectionStrategy } from \"./ISelectionStrategy\";\n\n/**\n * Accumulative selection strategy accumulates inputs until the target amounts\n * value is reached, skipping detrimental inputs.\n */\nexport class AccumulativeSelectionStrategy implements ISelectionStrategy {\n  private _inputs!: Box<bigint>[];\n\n  select(inputs: Box<bigint>[], target: SelectionTarget): Box<bigint>[] {\n    this._inputs = inputs;\n\n    let selection: Box<bigint>[] = [];\n    if (some(target.tokens)) {\n      selection = this._selectTokens(target.tokens);\n    }\n\n    const selectedNanoErgs = sumBy(selection, (input) => input.value);\n    if (\n      (isUndefined(target.nanoErgs) && isEmpty(target.tokens)) ||\n      (isDefined(target.nanoErgs) && selectedNanoErgs < target.nanoErgs)\n    ) {\n      const targetAmount = isDefined(target.nanoErgs)\n        ? target.nanoErgs - selectedNanoErgs\n        : undefined;\n\n      selection = selection.concat(this._select(targetAmount));\n    }\n\n    return selection;\n  }\n\n  private _selectTokens(targets: TokenTargetAmount<bigint>[]): Box<bigint>[] {\n    let selection: Box<bigint>[] = [];\n\n    for (const target of targets) {\n      const targetAmount = isDefined(target.amount)\n        ? target.amount - utxoSum(selection, target.tokenId)\n        : undefined;\n\n      if (targetAmount && targetAmount <= _0n) {\n        continue;\n      }\n\n      selection = selection.concat(this._select(targetAmount, target.tokenId));\n    }\n\n    return selection;\n  }\n\n  private _select(target?: bigint, tokenId?: TokenId): Box<bigint>[] {\n    const inputs = this._inputs;\n    let acc = _0n;\n    let selection: Box<bigint>[] = [];\n\n    if (isUndefined(target)) {\n      if (tokenId) {\n        selection = inputs.filter((x) =>\n          x.assets.some((asset) => asset.tokenId === tokenId)\n        );\n      } else {\n        selection = inputs;\n      }\n    } else {\n      for (let i = 0; i < inputs.length && acc < target; i++) {\n        if (tokenId) {\n          for (const token of inputs[i].assets) {\n            if (token.tokenId !== tokenId) {\n              continue;\n            }\n\n            acc += token.amount;\n            selection.push(inputs[i]);\n          }\n        } else {\n          acc += inputs[i].value;\n          selection.push(inputs[i]);\n        }\n      }\n    }\n\n    if (some(selection)) {\n      this._inputs = this._inputs.filter((input) => !selection.includes(input));\n    }\n\n    return selection;\n  }\n}\n","import type { Box } from \"@fleet-sdk/common\";\nimport type { SelectionTarget } from \"../boxSelector\";\nimport type { ISelectionStrategy } from \"./ISelectionStrategy\";\n\nexport type SelectorFunction = (\n  inputs: Box<bigint>[],\n  target?: SelectionTarget\n) => Box<bigint>[];\n\n/**\n * Custom selection strategy supports custom selections implementations.\n */\nexport class CustomSelectionStrategy implements ISelectionStrategy {\n  private readonly _selector: SelectorFunction;\n\n  constructor(selector: SelectorFunction) {\n    this._selector = selector;\n  }\n\n  select(inputs: Box<bigint>[], target?: SelectionTarget): Box<bigint>[] {\n    return this._selector(inputs, target);\n  }\n}\n","import { type Box, orderBy } from \"@fleet-sdk/common\";\nimport type { SelectionTarget } from \"../boxSelector\";\nimport { AccumulativeSelectionStrategy } from \"./accumulativeSelectionStrategy\";\n\n/**\n * The Cherry Pick strategy accumulates inputs until the target amounts trying\n * to pick inputs with as less as possible unused tokens.\n */\nexport class CherryPickSelectionStrategy extends AccumulativeSelectionStrategy {\n  public override select(\n    inputs: Box<bigint>[],\n    target: SelectionTarget\n  ): Box<bigint>[] {\n    const orderedInputs = orderBy(\n      inputs,\n      (x) => new Set(x.assets.map((asset) => asset.tokenId)).size,\n      \"asc\"\n    );\n\n    return super.select(orderedInputs, target);\n  }\n}\n","import {\n  _0n,\n  _1n,\n  type Amount,\n  areRegistersDenselyPacked,\n  assert,\n  type Box,\n  type BoxCandidate,\n  ensureBigInt,\n  type ErgoTreeHex,\n  type HexString,\n  isDefined,\n  isEmpty,\n  isHex,\n  isUndefined,\n  type NewToken,\n  type NonMandatoryRegisters,\n  type OneOrMore,\n  type TokenAmount,\n  type TokenId,\n  type UnsignedInput\n} from \"@fleet-sdk/common\";\nimport { utf8 } from \"@fleet-sdk/crypto\";\nimport {\n  estimateBoxSize,\n  SByte,\n  SColl,\n  type SConstant\n} from \"@fleet-sdk/serializer\";\nimport { InvalidRegistersPacking, UndefinedCreationHeight } from \"../errors\";\nimport { ErgoAddress, ErgoTree } from \"../models\";\nimport {\n  type TokenAddOptions,\n  TokensCollection\n} from \"../models/collections/tokensCollection\";\n\nexport const BOX_VALUE_PER_BYTE = BigInt(360);\nexport const SAFE_MIN_BOX_VALUE = BigInt(1000000);\n\nexport type BoxValueEstimationCallback = (\n  outputBuilder: OutputBuilder\n) => bigint;\n\nexport function estimateMinBoxValue(\n  valuePerByte = BOX_VALUE_PER_BYTE\n): BoxValueEstimationCallback {\n  return (output) => {\n    return BigInt(output.estimateSize()) * valuePerByte;\n  };\n}\n\nconst DUMB_TOKEN_ID =\n  \"0000000000000000000000000000000000000000000000000000000000000000\";\n\nexport class OutputBuilder {\n  private readonly _address: ErgoAddress;\n  private readonly _tokens: TokensCollection;\n  private _value!: bigint;\n  private _valueEstimator?: BoxValueEstimationCallback;\n  private _creationHeight?: number;\n  private _registers: NonMandatoryRegisters;\n\n  constructor(\n    value: Amount | BoxValueEstimationCallback,\n    recipient: ErgoAddress | ErgoTree | string,\n    creationHeight?: number\n  ) {\n    this.setValue(value);\n\n    this._creationHeight = creationHeight;\n    this._tokens = new TokensCollection();\n    this._registers = {};\n\n    if (typeof recipient === \"string\") {\n      this._address = isHex(recipient)\n        ? ErgoAddress.fromErgoTree(recipient)\n        : ErgoAddress.fromBase58(recipient);\n    } else if (recipient instanceof ErgoTree) {\n      this._address = recipient.toAddress();\n    } else {\n      this._address = recipient;\n    }\n  }\n\n  public get value(): bigint {\n    return isDefined(this._valueEstimator)\n      ? this._valueEstimator(this)\n      : this._value;\n  }\n\n  public get address(): ErgoAddress {\n    return this._address;\n  }\n\n  public get ergoTree(): ErgoTreeHex {\n    return this._address.ergoTree;\n  }\n\n  public get creationHeight(): number | undefined {\n    return this._creationHeight;\n  }\n\n  public get assets(): TokensCollection {\n    return this._tokens;\n  }\n\n  public get additionalRegisters(): NonMandatoryRegisters {\n    return this._registers;\n  }\n\n  public get minting(): NewToken<bigint> | undefined {\n    return this.assets.minting;\n  }\n\n  public setValue(value: Amount | BoxValueEstimationCallback): OutputBuilder {\n    if (typeof value === \"function\") {\n      this._valueEstimator = value;\n    } else {\n      this._value = ensureBigInt(value);\n      this._valueEstimator = undefined;\n\n      if (this._value <= _0n) {\n        throw new Error(\n          \"An UTxO cannot be created without a minimum required amount.\"\n        );\n      }\n    }\n\n    return this;\n  }\n\n  public addTokens(\n    tokens: OneOrMore<TokenAmount<Amount>> | TokensCollection,\n    options?: TokenAddOptions\n  ): OutputBuilder {\n    if (tokens instanceof TokensCollection) {\n      this._tokens.add(tokens.toArray(), options);\n    } else {\n      this._tokens.add(tokens, options);\n    }\n\n    return this;\n  }\n\n  public addNfts(...tokenIds: TokenId[]): OutputBuilder {\n    const tokens = tokenIds.map((tokenId) => ({ tokenId, amount: _1n }));\n\n    return this.addTokens(tokens);\n  }\n\n  public mintToken(token: NewToken<Amount>): OutputBuilder {\n    this.assets.mint(token);\n    return this;\n  }\n\n  public setCreationHeight(\n    height: number,\n    options?: { replace: boolean }\n  ): OutputBuilder {\n    if (\n      isUndefined(options) ||\n      options.replace === true ||\n      (options.replace === false && isUndefined(this._creationHeight))\n    ) {\n      this._creationHeight = height;\n    }\n\n    return this;\n  }\n\n  public setAdditionalRegisters<T extends AdditionalRegistersInput>(\n    registers: SequentialNonMandatoryRegisters<T>\n  ): OutputBuilder {\n    const hexRegisters: NonMandatoryRegisters = {};\n    for (const key in registers) {\n      const r = registers[key] as ConstantInput;\n      if (!r) continue;\n\n      hexRegisters[key as keyof NonMandatoryRegisters] =\n        typeof r === \"string\" ? r : r.toHex();\n    }\n\n    if (!areRegistersDenselyPacked(hexRegisters))\n      throw new InvalidRegistersPacking();\n    this._registers = hexRegisters;\n\n    return this;\n  }\n\n  public eject(\n    ejector: (context: { tokens: TokensCollection }) => void\n  ): OutputBuilder {\n    ejector({ tokens: this._tokens });\n    return this;\n  }\n\n  public build(\n    transactionInputs?: UnsignedInput[] | Box<Amount>[]\n  ): BoxCandidate<bigint> {\n    let tokens: TokenAmount<bigint>[];\n\n    if (this.minting) {\n      const mintingTokenId = transactionInputs\n        ? transactionInputs[0]?.boxId\n        : undefined;\n      tokens = this.assets.toArray(mintingTokenId);\n\n      if (isEmpty(this.additionalRegisters)) {\n        this.setAdditionalRegisters({\n          R4: SColl(SByte, utf8.decode(this.minting.name || \"\")),\n          R5: SColl(SByte, utf8.decode(this.minting.description || \"\")),\n          R6: SColl(\n            SByte,\n            utf8.decode(this.minting.decimals?.toString() || \"0\")\n          )\n        });\n      }\n    } else {\n      tokens = this.assets.toArray();\n    }\n\n    if (isUndefined(this.creationHeight)) throw new UndefinedCreationHeight();\n\n    return {\n      value: this.value,\n      ergoTree: this.ergoTree,\n      creationHeight: this.creationHeight,\n      assets: tokens,\n      additionalRegisters: this.additionalRegisters\n    };\n  }\n\n  estimateSize(value = SAFE_MIN_BOX_VALUE): number {\n    assert(!!this.creationHeight, \"Creation height must be set\");\n\n    const plainBoxObject: BoxCandidate<bigint> = {\n      value,\n      ergoTree: this.ergoTree,\n      creationHeight: this.creationHeight,\n      assets: this._tokens.toArray(DUMB_TOKEN_ID),\n      additionalRegisters: this.additionalRegisters\n    };\n\n    return estimateBoxSize(plainBoxObject);\n  }\n}\n\nexport type ConstantInput = SConstant | HexString;\n\nexport type AdditionalRegistersInput = NonMandatoryRegisters<ConstantInput>;\n\nexport type OnlyR4Register<T = HexString> = {\n  R4: T;\n} & NonMandatoryRegisters<T>;\n\nexport type R4ToR5Registers<T = HexString> = {\n  R4: T;\n  R5: T;\n} & NonMandatoryRegisters<T>;\n\nexport type R4ToR6Registers<T = HexString> = {\n  R4: T;\n  R5: T;\n  R6: T;\n} & NonMandatoryRegisters<T>;\n\nexport type R4ToR7Registers<T = HexString> = {\n  R4: T;\n  R5: T;\n  R6: T;\n  R7: T;\n} & NonMandatoryRegisters<T>;\n\nexport type R4ToR8Registers<T = HexString> = {\n  R4: T;\n  R5: T;\n  R6: T;\n  R7: T;\n  R8: T;\n} & NonMandatoryRegisters<T>;\n\nexport type R4ToR9Registers<T = HexString> = {\n  R4: T;\n  R5: T;\n  R6: T;\n  R7: T;\n  R8: T;\n  R9: T;\n} & NonMandatoryRegisters<T>;\n\nexport type SequentialNonMandatoryRegisters<\n  T extends AdditionalRegistersInput\n> = T extends {\n  R9: ConstantInput;\n}\n  ? R4ToR9Registers<ConstantInput>\n  : T extends { R8: ConstantInput }\n    ? R4ToR8Registers<ConstantInput>\n    : T extends { R7: ConstantInput }\n      ? R4ToR7Registers<ConstantInput>\n      : T extends { R6: ConstantInput }\n        ? R4ToR6Registers<ConstantInput>\n        : T extends { R5: ConstantInput }\n          ? R4ToR5Registers<ConstantInput>\n          : T extends { R4: ConstantInput }\n            ? OnlyR4Register<ConstantInput>\n            : T;\n","export class DuplicateInputError extends Error {\n  constructor(boxId: string) {\n    super(`Box '${boxId}' is already included.`);\n  }\n}\n","export class InsufficientTokenAmount extends Error {}\n","export class InvalidAddress extends Error {\n  constructor(address: string) {\n    super(`Invalid Ergo address: ${address}`);\n  }\n}\n","export class InvalidInput extends Error {\n  constructor(boxId: string) {\n    super(`Invalid input: ${boxId}`);\n  }\n}\n","export class InvalidRegistersPacking extends Error {\n  constructor() {\n    super(\n      `Registers should be densely packed. This means that it's not possible to use a register like 'R7' without filling 'R6', 'R5' and 'R4', for example.`\n    );\n  }\n}\n","export class MalformedTransaction extends Error {\n  constructor(message: string) {\n    super(`Malformed transaction: ${message}`);\n  }\n}\n","import {\n  type Amount,\n  Collection,\n  type CollectionAddOptions,\n  FleetError,\n  isDefined,\n  isUndefined,\n  type NewToken,\n  type OneOrMore,\n  type TokenAmount,\n  type TokenId\n} from \"@fleet-sdk/common\";\nimport { ensureBigInt } from \"@fleet-sdk/common\";\nimport { NotFoundError, UndefinedMintingContext } from \"../../errors\";\nimport { InsufficientTokenAmount } from \"../../errors/insufficientTokenAmount\";\nimport { MaxTokensOverflow } from \"../../errors/maxTokensOverflow\";\n\nexport const MAX_TOKENS_PER_BOX = 120;\n\nexport type TokenAddOptions = CollectionAddOptions & { sum?: boolean };\nexport type OutputToken<T extends Amount = Amount> = {\n  tokenId?: TokenId;\n  amount: T;\n};\n\ntype MintingData = { index: number; metadata: NewToken<Amount> };\n\nexport class TokensCollection extends Collection<\n  OutputToken<bigint>,\n  OutputToken\n> {\n  #minting: MintingData | undefined;\n\n  constructor();\n  constructor(token: TokenAmount<Amount>);\n  constructor(tokens: TokenAmount<Amount>[]);\n  constructor(tokens: TokenAmount<Amount>[], options: TokenAddOptions);\n  constructor(\n    tokens?: OneOrMore<TokenAmount<Amount>>,\n    options?: TokenAddOptions\n  ) {\n    super();\n\n    if (isDefined(tokens)) {\n      this.add(tokens, options);\n    }\n  }\n\n  public get minting(): NewToken<bigint> | undefined {\n    if (!this.#minting) return undefined;\n    return {\n      ...this.#minting.metadata,\n      amount: this._items[this.#minting.index].amount\n    };\n  }\n\n  protected override _map(token: OutputToken): OutputToken<bigint> {\n    return { tokenId: token.tokenId, amount: ensureBigInt(token.amount) };\n  }\n\n  protected override _addOne(\n    token: OutputToken,\n    options?: TokenAddOptions\n  ): number {\n    if (isUndefined(options) || (options.sum && isUndefined(options.index))) {\n      if (this._sum(this._map(token))) return this.length;\n    }\n\n    if (this._items.length >= MAX_TOKENS_PER_BOX) throw new MaxTokensOverflow();\n    super._addOne(token, options);\n\n    return this.length;\n  }\n\n  public override add(\n    items: OneOrMore<TokenAmount<Amount>>,\n    options?: TokenAddOptions\n  ): number {\n    if (Array.isArray(items)) {\n      if (items.some((x) => !x.tokenId))\n        throw new FleetError(\"TokenID is required.\");\n    } else if (!items.tokenId) {\n      throw new FleetError(\"TokenID is required.\");\n    }\n\n    return super.add(items, options);\n  }\n\n  public mint(token: NewToken<Amount>): number {\n    if (isDefined(this.#minting)) {\n      throw new FleetError(\n        \"Only one minting token is allowed per transaction.\"\n      );\n    }\n\n    const len = super.add({ tokenId: token.tokenId, amount: token.amount });\n    this.#minting = { index: len - 1, metadata: token };\n    return this.length;\n  }\n\n  private _sum(token: OutputToken<bigint>): boolean {\n    for (const t of this._items) {\n      if (t.tokenId === token.tokenId) {\n        t.amount += token.amount;\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  public remove(tokenId: TokenId, amount?: Amount): number;\n  public remove(index: number, amount?: Amount): number;\n  public remove(tokenIdOrIndex: TokenId | number, amount?: Amount): number {\n    let index = -1;\n    if (typeof tokenIdOrIndex === \"number\") {\n      if (this._isIndexOutOfBounds(tokenIdOrIndex)) {\n        throw new RangeError(`Index '${tokenIdOrIndex}' is out of range.`);\n      }\n\n      index = tokenIdOrIndex;\n    } else {\n      index = this._items.findIndex(\n        (token) => token.tokenId === tokenIdOrIndex\n      );\n\n      if (this._isIndexOutOfBounds(index)) {\n        throw new NotFoundError(\n          `TokenId '${tokenIdOrIndex}' not found in assets collection.`\n        );\n      }\n    }\n\n    if (amount && index > -1) {\n      const bigAmount = ensureBigInt(amount);\n      const token = this._items[index];\n\n      if (bigAmount > token.amount) {\n        throw new InsufficientTokenAmount(\n          \"Insufficient token amount to perform a subtraction operation.\"\n        );\n      }\n\n      if (bigAmount < token.amount) {\n        token.amount -= bigAmount;\n        return this.length;\n      }\n    }\n\n    this._items.splice(index, 1);\n    return this.length;\n  }\n\n  contains(tokenId: string): boolean {\n    return this._items.some((x) => x.tokenId === tokenId);\n  }\n\n  toArray(): TokenAmount<bigint>[];\n  toArray(mintingTokenId: string): TokenAmount<bigint>[];\n  toArray(mintingTokenId?: string): TokenAmount<bigint>[];\n  toArray(mintingTokenId?: string): OutputToken[] {\n    if (this.minting) {\n      if (!mintingTokenId) throw new UndefinedMintingContext();\n\n      return this._items.map((x) => ({\n        tokenId: x.tokenId ? x.tokenId : mintingTokenId,\n        amount: x.amount\n      }));\n    }\n\n    return super.toArray();\n  }\n}\n","import { MAX_TOKENS_PER_BOX } from \"../models/collections/tokensCollection\";\n\nexport class MaxTokensOverflow extends Error {\n  constructor() {\n    super(\n      `A box must contain no more than ${MAX_TOKENS_PER_BOX} distinct tokens.`\n    );\n  }\n}\n","export class NotAllowedTokenBurning extends Error {\n  constructor() {\n    super(\n      \"This transaction is trying to burn tokens. If that's your intention you must explicitly allow token burning on TransactionBuilder.configure() method. If no, a change address should be provided.\"\n    );\n  }\n}\n","export class NotFoundError extends Error {}\n","export class UndefinedCreationHeight extends Error {\n  constructor() {\n    super(\n      \"Minting context is undefined. Transaction's inputs must be included in order to determine minting token id.\"\n    );\n  }\n}\n","export class UndefinedMintingContext extends Error {\n  constructor() {\n    super(\"Creation Height is undefined.\");\n  }\n}\n","import {\n  AddressType,\n  type Base58String,\n  type HexString,\n  Network\n} from \"@fleet-sdk/common\";\nimport { concatBytes, endsWith, first, startsWith } from \"@fleet-sdk/common\";\nimport {\n  base58,\n  blake2b256,\n  type ByteInput,\n  ensureBytes,\n  hex,\n  validateEcPoint\n} from \"@fleet-sdk/crypto\";\nimport { InvalidAddress } from \"../errors/invalidAddress\";\nimport {\n  BLAKE_256_HASH_LENGTH,\n  encodeAddress,\n  getAddressType,\n  getNetworkType,\n  unpackAddress,\n  type UnpackedAddress,\n  validateAddress,\n  validateUnpackedAddress\n} from \"./utils\";\n\nconst P2PK_ERGOTREE_PREFIX = hex.decode(\"0008cd\");\nconst P2PK_ERGOTREE_LENGTH = 36;\n\nconst P2SH_ERGOTREE_SUFFIX = hex.decode(\"d40801\");\nconst P2SH_ERGOTREE_PREFIX = hex.decode(\"00ea02d193b4cbe4e3010e040004300e18\");\nconst P2SH_ERGOTREE_LENGTH = 44;\nconst P2SH_HASH_LENGTH = 24;\n\nfunction getErgoTreeType(ergoTree: Uint8Array): AddressType {\n  if (\n    ergoTree.length === P2PK_ERGOTREE_LENGTH &&\n    startsWith(ergoTree, P2PK_ERGOTREE_PREFIX)\n  ) {\n    return AddressType.P2PK;\n  }\n\n  if (\n    ergoTree.length === P2SH_ERGOTREE_LENGTH &&\n    startsWith(ergoTree, P2SH_ERGOTREE_PREFIX) &&\n    endsWith(ergoTree, P2SH_ERGOTREE_SUFFIX)\n  ) {\n    return AddressType.P2SH;\n  }\n\n  return AddressType.P2S;\n}\n\n/**\n * Ergo address model\n *\n * @example\n * Convert address to ErgoTree hex string\n * ```\n * const address = new Address(\"9eZ24iqjKywjzAti9RnWWTR3CiNnLJDAcd2MenKodcAfzc8AFTu\");\n * console.log(address.ergoTree);\n * ```\n *\n * @example\n * Convert ErgoTree hex string to address string\n * ```\n * const ergoTree = \"0008cd026dc059d64a50d0dbf07755c2c4a4e557e3df8afa7141868b3ab200643d437ee7\"\n * const address = Address.fromErgoTree(ergoTree).toString();\n * ```\n */\nexport class ErgoAddress {\n  #ergoTree: Uint8Array;\n  #network: Network;\n  #type: AddressType;\n\n  public get network(): Network {\n    return this.#network;\n  }\n\n  /**\n   * ErgoTree hex string\n   */\n  public get ergoTree(): HexString {\n    return hex.encode(this.#ergoTree);\n  }\n\n  public get type(): AddressType {\n    return this.#type;\n  }\n\n  /**\n   * New instance from ErgoTree bytes\n   * @param ergoTree ErgoTree bytes\n   */\n  public constructor(ergoTree: Uint8Array, network: Network = Network.Mainnet) {\n    this.#ergoTree = ergoTree;\n    this.#network = network;\n    this.#type = getErgoTreeType(ergoTree);\n  }\n\n  /**\n   * Create a new instance from an ErgoTree\n   * @param ergoTree ErgoTree hex string\n   */\n  public static fromErgoTree(\n    ergoTree: ByteInput,\n    network?: Network\n  ): ErgoAddress {\n    return new ErgoAddress(ensureBytes(ergoTree), network);\n  }\n\n  /**\n   * Create a new instance from a public key\n   * @param publicKey Public key hex string\n   */\n  public static fromPublicKey(\n    publicKey: ByteInput,\n    network?: Network\n  ): ErgoAddress {\n    const bytes = ensureBytes(publicKey);\n    if (!validateEcPoint(bytes)) throw new Error(\"The Public Key is invalid.\");\n\n    const ergoTree = concatBytes(P2PK_ERGOTREE_PREFIX, bytes);\n    return new ErgoAddress(ergoTree, network);\n  }\n\n  public static fromHash(\n    hash: HexString | Uint8Array,\n    network?: Network\n  ): ErgoAddress {\n    let bytes = ensureBytes(hash);\n\n    if (bytes.length === BLAKE_256_HASH_LENGTH) {\n      bytes = bytes.subarray(0, P2SH_HASH_LENGTH);\n    } else if (bytes.length !== P2SH_HASH_LENGTH) {\n      throw Error(`Invalid hash length: ${bytes.length}`);\n    }\n\n    const ergoTree = concatBytes(\n      P2SH_ERGOTREE_PREFIX,\n      bytes,\n      P2SH_ERGOTREE_SUFFIX\n    );\n\n    return new ErgoAddress(ergoTree, network);\n  }\n\n  /**\n   * Create a new checked instance from an address string\n   * @param encodedAddress Address encoded as base58\n   */\n  public static decode(encodedAddress: Base58String): ErgoAddress {\n    const bytes = base58.decode(encodedAddress);\n    const unpacked = unpackAddress(bytes);\n    if (!validateUnpackedAddress(unpacked))\n      throw new InvalidAddress(encodedAddress);\n\n    return ErgoAddress.#fromUnpacked(unpacked);\n  }\n\n  public static decodeUnsafe(encodedAddress: Base58String): ErgoAddress {\n    return ErgoAddress.#fromUnpacked(\n      unpackAddress(base58.decode(encodedAddress))\n    );\n  }\n\n  static fromBase58(address: Base58String, unsafe = false): ErgoAddress {\n    return unsafe\n      ? ErgoAddress.decodeUnsafe(address)\n      : ErgoAddress.decode(address);\n  }\n\n  static #fromUnpacked(unpacked: UnpackedAddress) {\n    switch (unpacked.type) {\n      case AddressType.P2PK:\n        return ErgoAddress.fromPublicKey(unpacked.body, unpacked.network);\n      case AddressType.P2SH:\n        return ErgoAddress.fromHash(unpacked.body, unpacked.network);\n      case AddressType.ADH:\n        throw new Error(\"Invalid address type\");\n      default:\n        return new ErgoAddress(unpacked.body, unpacked.network);\n    }\n  }\n\n  /**\n   * Validate an address\n   * @param address Address bytes or string\n   * @deprecated Use `validateAddress()` function instead\n   */\n  public static validate(address: Base58String): boolean {\n    return validateAddress(address);\n  }\n\n  public static getNetworkType(address: Base58String): Network {\n    return getNetworkType(base58.decode(address));\n  }\n\n  public static getAddressType(address: Base58String): AddressType {\n    return getAddressType(base58.decode(address));\n  }\n\n  public getPublicKeys(): Uint8Array[] {\n    if (this.type === AddressType.P2PK) {\n      return [this.#ergoTree.subarray(P2PK_ERGOTREE_PREFIX.length)];\n    }\n\n    return [];\n  }\n\n  public toP2SH(network?: Network): Base58String {\n    if (this.type === AddressType.P2SH) return this.encode();\n\n    const hash = blake2b256(this.#ergoTree).subarray(0, P2SH_HASH_LENGTH);\n    return encodeAddress(network ?? this.#network, AddressType.P2SH, hash);\n  }\n\n  /**\n   * Encode address as base58 string\n   */\n  public encode(network?: Network): Base58String {\n    let body: Uint8Array;\n    if (this.type === AddressType.P2PK) {\n      body = first(this.getPublicKeys());\n    } else if (this.type === AddressType.P2SH) {\n      body = this.#ergoTree.subarray(\n        P2SH_ERGOTREE_PREFIX.length,\n        P2SH_ERGOTREE_PREFIX.length + P2SH_HASH_LENGTH\n      );\n    } else {\n      body = this.#ergoTree;\n    }\n\n    return encodeAddress(network ?? this.#network, this.#type, body);\n  }\n\n  /**\n   * Encode address as base58 string\n   */\n  public toString(network?: Network): Base58String {\n    return this.encode(network ?? this.#network);\n  }\n}\n","import {\n  AddressType,\n  areEqual,\n  type Base58String,\n  concatBytes,\n  first,\n  isEmpty,\n  type Network\n} from \"@fleet-sdk/common\";\nimport { base58, blake2b256, validateEcPoint } from \"@fleet-sdk/crypto\";\nimport { SigmaByteWriter } from \"@fleet-sdk/serializer\";\n\nexport const CHECKSUM_LENGTH = 4;\nexport const BLAKE_256_HASH_LENGTH = 32;\n\nexport type UnpackedAddress = {\n  head: Uint8Array;\n  body: Uint8Array;\n  checksum: Uint8Array;\n  network: Network;\n  type: AddressType;\n};\n\nexport function getNetworkType(addressBytes: Uint8Array): Network {\n  return first(addressBytes) & 0xf0;\n}\n\nexport function getAddressType(addressBytes: Uint8Array): AddressType {\n  return first(addressBytes) & 0x0f;\n}\n\n/**\n * Unpacks the given bytes into an UnpackedAddress object.\n *\n * @param bytes - The bytes to unpack.\n * @returns The UnpackedAddress object containing the unpacked data.\n */\nexport function unpackAddress(bytes: Uint8Array): UnpackedAddress {\n  return {\n    head: bytes.subarray(0, 1),\n    body: bytes.subarray(1, bytes.length - CHECKSUM_LENGTH),\n    checksum: bytes.subarray(bytes.length - CHECKSUM_LENGTH, bytes.length),\n    network: getNetworkType(bytes),\n    type: getAddressType(bytes)\n  };\n}\n\nexport function encodeAddress(\n  network: Network,\n  type: AddressType,\n  content: Uint8Array\n): Base58String {\n  return new SigmaByteWriter(1 /** head */ + content.length + CHECKSUM_LENGTH)\n    .write(network + type)\n    .writeBytes(content)\n    .writeChecksum(CHECKSUM_LENGTH)\n    .encode(base58);\n}\n\nexport function validateUnpackedAddress(unpacked: UnpackedAddress): boolean {\n  const content = concatBytes(unpacked.head, unpacked.body);\n  if (isEmpty(unpacked.body)) return false;\n  if (unpacked.type === AddressType.P2PK && !validateEcPoint(unpacked.body))\n    return false;\n\n  const checksum = blake2b256(content).subarray(0, CHECKSUM_LENGTH);\n  return areEqual(checksum, unpacked.checksum);\n}\n\n/**\n * Validates a Base58 encoded address.\n *\n * @param encodedAddress - The Base58 encoded address to validate.\n * @returns A boolean indicating whether the address is valid or not.\n */\nexport function validateAddress(encodedAddress: Base58String): boolean {\n  return validateUnpackedAddress(unpackAddress(base58.decode(encodedAddress)));\n}\n","import type {\n  Amount,\n  Box,\n  NonMandatoryRegisters,\n  TokenAmount\n} from \"@fleet-sdk/common\";\nimport { ensureBigInt } from \"@fleet-sdk/common\";\nimport { blake2b256, hex } from \"@fleet-sdk/crypto\";\nimport { serializeBox } from \"@fleet-sdk/serializer\";\n\nexport class ErgoBox<R extends NonMandatoryRegisters = NonMandatoryRegisters> {\n  boxId!: string;\n  value!: bigint;\n  ergoTree!: string;\n  creationHeight!: number;\n  assets!: TokenAmount<bigint>[];\n  additionalRegisters!: R;\n  transactionId!: string;\n  index!: number;\n\n  constructor(box: Box<Amount, R>) {\n    this.boxId = box.boxId;\n    this.ergoTree = box.ergoTree;\n    this.creationHeight = box.creationHeight;\n    this.value = ensureBigInt(box.value);\n    this.assets = box.assets.map((asset) => ({\n      tokenId: asset.tokenId,\n      amount: ensureBigInt(asset.amount)\n    }));\n    this.additionalRegisters = box.additionalRegisters;\n    this.transactionId = box.transactionId;\n    this.index = box.index;\n  }\n\n  public isValid(): boolean {\n    return ErgoBox.validate(this);\n  }\n\n  static validate(box: Box<Amount> | ErgoBox): boolean {\n    const bytes = serializeBox(box).toBytes();\n    const hash = hex.encode(blake2b256(bytes));\n\n    return box.boxId === hash;\n  }\n}\n","import type {\n  Amount,\n  Box,\n  BuildOutputType,\n  ContextExtension,\n  DataInput,\n  EIP12UnsignedDataInput,\n  EIP12UnsignedInput,\n  NonMandatoryRegisters,\n  UnsignedInput\n} from \"@fleet-sdk/common\";\nimport type { ConstantInput } from \"../builder\";\nimport { ErgoBox } from \"./ergoBox\";\n\ntype InputType<T> = T extends \"default\" ? UnsignedInput : EIP12UnsignedInput;\ntype DataInputType<T> = T extends \"default\"\n  ? DataInput\n  : EIP12UnsignedDataInput;\ntype InputBox<R extends NonMandatoryRegisters> = Box<Amount, R> & {\n  extension?: ContextExtension;\n};\ntype ContextExtensionInput = ContextExtension<ConstantInput>;\n\nexport class ErgoUnsignedInput<\n  R extends NonMandatoryRegisters = NonMandatoryRegisters\n> extends ErgoBox<R> {\n  #extension?: ContextExtension;\n\n  public get extension(): ContextExtension | undefined {\n    return this.#extension;\n  }\n\n  constructor(box: InputBox<R>) {\n    super(box);\n\n    if (box.extension) {\n      this.setContextVars(box.extension);\n    }\n  }\n\n  public setContextExtension(\n    extension: ContextExtensionInput\n  ): ErgoUnsignedInput {\n    const vars: ContextExtension = {};\n    for (const key in extension) {\n      const c = extension[key] as ConstantInput;\n      if (!c) continue;\n\n      vars[key as unknown as keyof ContextExtension] =\n        typeof c === \"string\" ? c : c.toHex();\n    }\n\n    this.#extension = vars;\n\n    return this;\n  }\n\n  /**\n   * @deprecated use `setContextExtension` instead.\n   */\n  public setContextVars(extension: ContextExtensionInput): ErgoUnsignedInput {\n    return this.setContextExtension(extension);\n  }\n\n  public toUnsignedInputObject<T extends BuildOutputType>(\n    type: T\n  ): InputType<T> {\n    return {\n      ...this.toPlainObject(type),\n      extension: this.#extension || {}\n    } as InputType<T>;\n  }\n\n  public toPlainObject<T extends BuildOutputType>(type: T): DataInputType<T> {\n    if (type === \"EIP-12\") {\n      return {\n        boxId: this.boxId,\n        value: this.value.toString(),\n        ergoTree: this.ergoTree,\n        creationHeight: this.creationHeight,\n        assets: this.assets.map((asset) => ({\n          tokenId: asset.tokenId,\n          amount: asset.amount.toString()\n        })),\n        additionalRegisters: this.additionalRegisters,\n        transactionId: this.transactionId,\n        index: this.index\n      } as DataInputType<T>;\n    }\n\n    return { boxId: this.boxId } as DataInputType<T>;\n  }\n}\n","import {\n  type BoxCandidate,\n  type BoxSummary,\n  type BuildOutputType,\n  type EIP12UnsignedTransaction,\n  type UnsignedTransaction,\n  utxoDiff,\n  utxoSum\n} from \"@fleet-sdk/common\";\nimport { blake2b256, hex } from \"@fleet-sdk/crypto\";\nimport { serializeTransaction } from \"@fleet-sdk/serializer\";\nimport type { ErgoUnsignedInput } from \"./ergoUnsignedInput\";\n\ntype Input = ErgoUnsignedInput;\ntype Output = BoxCandidate<bigint>;\ntype ReadOnlyInputs = readonly Input[];\ntype ReadOnlyOutputs = readonly Output[];\n\ntype TransactionType<T> = T extends \"default\"\n  ? UnsignedTransaction\n  : EIP12UnsignedTransaction;\n\nexport class ErgoUnsignedTransaction {\n  private readonly _inputs!: ReadOnlyInputs;\n  private readonly _dataInputs!: ReadOnlyInputs;\n  private readonly _outputs!: ReadOnlyOutputs;\n\n  constructor(inputs: Input[], dataInputs: Input[], outputs: Output[]) {\n    this._inputs = Object.freeze(inputs);\n    this._dataInputs = Object.freeze(dataInputs);\n    this._outputs = Object.freeze(outputs);\n  }\n\n  get id(): string {\n    return hex.encode(blake2b256(this.toBytes()));\n  }\n\n  get inputs(): ReadOnlyInputs {\n    return this._inputs;\n  }\n\n  get dataInputs(): ReadOnlyInputs {\n    return this._dataInputs;\n  }\n\n  get outputs(): ReadOnlyOutputs {\n    return this._outputs;\n  }\n\n  get burning(): BoxSummary {\n    return utxoDiff(utxoSum(this.inputs), utxoSum(this.outputs));\n  }\n\n  toPlainObject(): UnsignedTransaction;\n  toPlainObject<T extends BuildOutputType>(outputType: T): TransactionType<T>;\n  toPlainObject<T extends BuildOutputType>(outputType?: T): TransactionType<T> {\n    return {\n      inputs: this.inputs.map((input) =>\n        input.toUnsignedInputObject(outputType || \"default\")\n      ),\n      dataInputs: this.dataInputs.map((input) =>\n        input.toPlainObject(outputType || \"default\")\n      ),\n      outputs: this.outputs.map((output) => _stringifyBoxAmounts(output))\n    } as TransactionType<T>;\n  }\n\n  toEIP12Object(): EIP12UnsignedTransaction {\n    return this.toPlainObject(\"EIP-12\");\n  }\n\n  toBytes(): Uint8Array {\n    return serializeTransaction({\n      inputs: this.inputs.map((input) =>\n        input.toUnsignedInputObject(\"default\")\n      ),\n      dataInputs: this.dataInputs.map((input) =>\n        input.toPlainObject(\"default\")\n      ),\n      outputs: this.outputs\n    }).toBytes();\n  }\n}\n\nfunction _stringifyBoxAmounts<T>(output: BoxCandidate<bigint>): T {\n  return {\n    ...output,\n    value: output.value.toString(),\n    assets: output.assets.map((token) => ({\n      tokenId: token.tokenId,\n      amount: token.amount.toString()\n    }))\n  } as T;\n}\n","import {\n  type Amount,\n  type Box,\n  type BoxId,\n  Collection,\n  type OneOrMore\n} from \"@fleet-sdk/common\";\nimport { isDefined } from \"@fleet-sdk/common\";\nimport { DuplicateInputError, NotFoundError } from \"../../errors\";\nimport { ErgoUnsignedInput } from \"../ergoUnsignedInput\";\n\nexport class InputsCollection extends Collection<\n  ErgoUnsignedInput,\n  Box<Amount>\n> {\n  constructor();\n  constructor(box: Box<Amount>);\n  constructor(boxes: Box<Amount>[]);\n  constructor(boxes?: OneOrMore<Box<Amount>>) {\n    super();\n\n    if (isDefined(boxes)) {\n      this.add(boxes);\n    }\n  }\n\n  protected override _map(\n    input: Box<Amount> | ErgoUnsignedInput\n  ): ErgoUnsignedInput {\n    return input instanceof ErgoUnsignedInput\n      ? input\n      : new ErgoUnsignedInput(input);\n  }\n\n  protected override _addOne(box: Box<Amount>): number {\n    if (this._items.some((item) => item.boxId === box.boxId)) {\n      throw new DuplicateInputError(box.boxId);\n    }\n\n    return super._addOne(box);\n  }\n\n  public remove(boxId: BoxId): number;\n  public remove(index: number): number;\n  public remove(boxIdOrIndex: BoxId | number): number {\n    let index = -1;\n    if (typeof boxIdOrIndex === \"number\") {\n      if (this._isIndexOutOfBounds(boxIdOrIndex)) {\n        throw new RangeError(`Index '${boxIdOrIndex}' is out of range.`);\n      }\n\n      index = boxIdOrIndex;\n    } else {\n      index = this._items.findIndex((box) => box.boxId === boxIdOrIndex);\n\n      if (this._isIndexOutOfBounds(index)) {\n        throw new NotFoundError(\n          \"The input you are trying to remove is not present in the inputs collection.\"\n        );\n      }\n    }\n\n    this._items.splice(index, 1);\n\n    return this.length;\n  }\n}\n","import {\n  _0n,\n  type BoxSummary,\n  Collection,\n  isDefined,\n  isUndefined,\n  type OneOrMore,\n  some\n} from \"@fleet-sdk/common\";\nimport type { OutputBuilder } from \"../../builder/outputBuilder\";\nimport type { SelectionTarget } from \"../../builder/selector/boxSelector\";\nimport { NotFoundError } from \"../../errors\";\n\nfunction setSum<K>(map: Map<K, bigint>, key: K, value: bigint) {\n  return map.set(key, (map.get(key) || _0n) + value);\n}\n\nexport class OutputsCollection extends Collection<\n  OutputBuilder,\n  OutputBuilder\n> {\n  constructor(outputs?: OneOrMore<OutputBuilder>) {\n    super();\n\n    if (isDefined(outputs)) {\n      this.add(outputs);\n    }\n  }\n\n  protected _map(output: OutputBuilder) {\n    return output;\n  }\n\n  remove(output: OutputBuilder): number;\n  remove(index: number): number;\n  remove(outputs: OutputBuilder | number): number {\n    let index = -1;\n    if (typeof outputs === \"number\") {\n      if (this._isIndexOutOfBounds(outputs)) {\n        throw new RangeError(`Index '${outputs}' is out of range.`);\n      }\n\n      index = outputs;\n    } else {\n      index = this._items.lastIndexOf(outputs);\n\n      if (this._isIndexOutOfBounds(index)) {\n        throw new NotFoundError(\n          \"The output you are trying to remove is not present in the outputs collection.\"\n        );\n      }\n    }\n\n    this._items.splice(index, 1);\n\n    return this.length;\n  }\n\n  clone(): OutputsCollection {\n    return new OutputsCollection(this._items);\n  }\n\n  sum(basis?: SelectionTarget | BoxSummary): BoxSummary {\n    const tokens = new Map<string, bigint>();\n    let nanoErgs = _0n;\n\n    if (basis) {\n      if (basis.nanoErgs) {\n        nanoErgs = basis.nanoErgs;\n      }\n\n      if (some(basis.tokens)) {\n        for (const token of basis.tokens) {\n          if (isUndefined(token.amount)) continue;\n\n          setSum(tokens, token.tokenId, token.amount);\n        }\n      }\n    }\n\n    for (const box of this._items) {\n      nanoErgs += box.value;\n      for (const token of box.assets) {\n        if (token.tokenId) setSum(tokens, token.tokenId, token.amount);\n      }\n    }\n\n    return {\n      nanoErgs,\n      tokens: Array.from(tokens, ([tokenId, amount]) => ({ tokenId, amount }))\n    };\n  }\n}\n","import {\n  ergoTreeHeaderFlags,\n  type HexString,\n  Network\n} from \"@fleet-sdk/common\";\nimport { hex } from \"@fleet-sdk/crypto\";\nimport { ErgoAddress } from \"./ergoAddress\";\n\nconst VERSION_MASK = 0x07;\n\nexport class ErgoTree {\n  private _bytes: Uint8Array;\n\n  constructor(input: HexString | Uint8Array) {\n    if (typeof input === \"string\") {\n      this._bytes = hex.decode(input);\n    } else {\n      this._bytes = input;\n    }\n  }\n\n  get header(): number {\n    return this._bytes[0];\n  }\n\n  get version(): number {\n    return this.header & VERSION_MASK;\n  }\n\n  get hasSegregatedConstants(): boolean {\n    return (this.header & ergoTreeHeaderFlags.constantSegregation) !== 0;\n  }\n\n  get hasSize(): boolean {\n    return (this.header & ergoTreeHeaderFlags.sizeInclusion) !== 0;\n  }\n\n  toBytes(): Uint8Array {\n    return this._bytes;\n  }\n\n  toHex(): HexString {\n    return hex.encode(this.toBytes());\n  }\n\n  toAddress(network = Network.Mainnet): ErgoAddress {\n    return ErgoAddress.fromErgoTree(this.toHex(), network);\n  }\n}\n","import {\n  AddressType,\n  areEqual,\n  type Base58String,\n  isHex,\n  Network\n} from \"@fleet-sdk/common\";\nimport {\n  base58,\n  blake2b256,\n  type ByteInput,\n  ensureBytes,\n  hex,\n  utf8\n} from \"@fleet-sdk/crypto\";\nimport { SigmaByteWriter } from \"@fleet-sdk/serializer\";\nimport type { JsonObject, JsonValue } from \"type-fest\";\nimport { encodeAddress, unpackAddress, validateUnpackedAddress } from \"./utils\";\n\nconst SERIALIZED_HASH_LENGTH = 34; // invalidation byte (1) + network type (1) + hash (32)\n\nexport type NetworkOptions = {\n  network?: Network;\n};\n\nexport type ErgoMessageFromHashOptions = NetworkOptions & {\n  hash: ByteInput;\n};\n\nexport type MessageData = Uint8Array | JsonValue | JsonObject;\n\nexport type ErgoMessageFromDataOptions = NetworkOptions & {\n  data: MessageData;\n};\n\nexport type ErgoMessageOptions =\n  | ErgoMessageFromHashOptions\n  | ErgoMessageFromDataOptions;\n\nexport const MessageType = {\n  Hash: 0,\n  Binary: 1,\n  String: 2,\n  Json: 3\n} as const;\n\nexport type MessageType = (typeof MessageType)[keyof typeof MessageType];\n\nexport class ErgoMessage {\n  #data?: Uint8Array;\n  #type: MessageType;\n  #hash: Uint8Array;\n  #network: Network;\n\n  constructor(options: ErgoMessageOptions) {\n    if (\"data\" in options) {\n      [this.#data, this.#type] = this.#decodeData(options.data);\n      this.#hash = blake2b256(this.#data);\n    } else if (\"hash\" in options) {\n      this.#hash = ensureBytes(options.hash);\n      this.#type = MessageType.Hash;\n    } else {\n      throw new Error(\"Either hash or message data must be provided\");\n    }\n\n    this.#network = options.network ?? Network.Mainnet;\n  }\n\n  get hash(): Uint8Array {\n    return this.#hash;\n  }\n\n  get type(): MessageType {\n    return this.#type;\n  }\n\n  get network(): Network {\n    return this.#network;\n  }\n\n  #decodeData(data: MessageData): [Uint8Array, MessageType] {\n    if (typeof data === \"string\") {\n      return isHex(data)\n        ? [hex.decode(data), MessageType.Binary]\n        : [utf8.decode(data), MessageType.String];\n    }\n    if (data instanceof Uint8Array) return [data, MessageType.Binary];\n    return [utf8.decode(JSON.stringify(data)), MessageType.Json];\n  }\n\n  static decode(encodedHash: Base58String): ErgoMessage {\n    const unpacked = unpackAddress(base58.decode(encodedHash));\n    if (unpacked.type !== AddressType.ADH)\n      throw new Error(\"Invalid message type\");\n    if (!validateUnpackedAddress(unpacked))\n      throw new Error(\"Invalid encoded message hash\");\n\n    return new ErgoMessage({ hash: unpacked.body, network: unpacked.network });\n  }\n\n  static fromBase58(encodedHash: Base58String): ErgoMessage {\n    return ErgoMessage.decode(encodedHash);\n  }\n\n  static fromData(data: MessageData, network?: Network): ErgoMessage {\n    return new ErgoMessage({ data, network });\n  }\n\n  encode(network?: Network): string {\n    return encodeAddress(network ?? this.#network, AddressType.ADH, this.hash);\n  }\n\n  toString(network?: Network): string {\n    return this.encode(network);\n  }\n\n  setNetwork(network: Network): ErgoMessage {\n    this.#network = network;\n    return this;\n  }\n\n  getData<T extends MessageData = MessageData>(): T | undefined {\n    if (!this.#data) return;\n    switch (this.#type) {\n      case MessageType.String:\n        return utf8.encode(this.#data) as T;\n      case MessageType.Json:\n        return JSON.parse(utf8.encode(this.#data)) as T;\n      default:\n        return this.#data as T;\n    }\n  }\n\n  serialize(): SigmaByteWriter {\n    return new SigmaByteWriter(SERIALIZED_HASH_LENGTH)\n      .write(0x0) // invalidation byte, see: https://github.com/ergoplatform/eips/blob/master/eip-0044.md#why-prefix-it-with-0x0\n      .write(this.#network)\n      .writeBytes(this.#hash);\n  }\n\n  verify(message: MessageData): boolean {\n    const [data] = this.#decodeData(message);\n    return areEqual(this.#hash, blake2b256(data));\n  }\n}\n","import {\n  _0n,\n  type Amount,\n  type Base58String,\n  type Box,\n  byteSizeOf,\n  chunk,\n  type CollectionAddOptions,\n  ensureBigInt,\n  first,\n  type HexString,\n  isDefined,\n  isHex,\n  isUndefined,\n  Network,\n  type OneOrMore,\n  some,\n  type TokenAmount,\n  utxoDiff,\n  utxoSum\n} from \"@fleet-sdk/common\";\nimport { estimateVLQSize } from \"@fleet-sdk/serializer\";\nimport {\n  InvalidInput,\n  MalformedTransaction,\n  NotAllowedTokenBurning\n} from \"../errors\";\nimport { NonStandardizedMinting } from \"../errors/nonStandardizedMinting\";\nimport {\n  ErgoAddress,\n  InputsCollection,\n  OutputsCollection,\n  TokensCollection\n} from \"../models\";\nimport { ErgoUnsignedTransaction } from \"../models/ergoUnsignedTransaction\";\nimport {\n  BOX_VALUE_PER_BYTE,\n  estimateMinBoxValue,\n  OutputBuilder,\n  SAFE_MIN_BOX_VALUE\n} from \"./outputBuilder\";\nimport { createPluginContext, type FleetPluginContext } from \"./pluginContext\";\nimport { BoxSelector } from \"./selector\";\nimport { TransactionBuilderSettings } from \"./transactionBuilderSettings\";\n\ntype PluginListItem = { execute: FleetPlugin; pending: boolean };\ntype SelectorSettings = Omit<BoxSelector<Box<bigint>>, \"select\">;\nexport type ConfigureCallback = (settings: TransactionBuilderSettings) => void;\nexport type SelectorCallback = (selector: SelectorSettings) => void;\nexport type FleetPlugin = (context: FleetPluginContext) => void;\nexport type CollectionLike<T> = { toArray(): T[] };\n\nexport const RECOMMENDED_MIN_FEE_VALUE = BigInt(1100000);\nexport const FEE_CONTRACT =\n  \"1005040004000e36100204a00b08cd0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798ea02d192a39a8cc7a701730073011001020402d19683030193a38cc7b2a57300000193c2b2a57301007473027303830108cdeeac93b1a57304\";\n\ntype EjectorContext = {\n  inputs: InputsCollection;\n  dataInputs: InputsCollection;\n  outputs: OutputsCollection;\n  burning: TokensCollection | undefined;\n  settings: TransactionBuilderSettings;\n  selection: (selectorCallBack: SelectorCallback) => void;\n};\n\nexport class TransactionBuilder {\n  private readonly _inputs!: InputsCollection;\n  private readonly _dataInputs!: InputsCollection;\n  private readonly _outputs!: OutputsCollection;\n  private readonly _settings!: TransactionBuilderSettings;\n  private readonly _creationHeight!: number;\n\n  private _selectorCallbacks?: SelectorCallback[];\n  private _changeAddress?: ErgoAddress;\n  private _feeAmount?: bigint;\n  private _burning?: TokensCollection;\n  private _plugins?: PluginListItem[];\n\n  constructor(creationHeight: number) {\n    this._inputs = new InputsCollection();\n    this._dataInputs = new InputsCollection();\n    this._outputs = new OutputsCollection();\n    this._settings = new TransactionBuilderSettings();\n    this._creationHeight = creationHeight;\n  }\n\n  public get inputs(): InputsCollection {\n    return this._inputs;\n  }\n\n  public get dataInputs(): InputsCollection {\n    return this._dataInputs;\n  }\n\n  public get outputs(): OutputsCollection {\n    return this._outputs;\n  }\n\n  public get changeAddress(): ErgoAddress | undefined {\n    return this._changeAddress;\n  }\n\n  public get fee(): bigint | undefined {\n    return this._feeAmount;\n  }\n\n  public get burning(): TokensCollection | undefined {\n    return this._burning;\n  }\n\n  public get settings(): TransactionBuilderSettings {\n    return this._settings;\n  }\n\n  public get creationHeight(): number {\n    return this._creationHeight;\n  }\n\n  /**\n   * Syntax sugar to be used in composition with another methods\n   *\n   * @example\n   * ```\n   * new TransactionBuilder(height)\n   *   .from(inputs)\n   *   .and.from(otherInputs);\n   * ```\n   */\n  public get and(): TransactionBuilder {\n    return this;\n  }\n\n  public from(\n    inputs: OneOrMore<Box<Amount>> | CollectionLike<Box<Amount>>\n  ): TransactionBuilder {\n    this._inputs.add(isCollectionLike(inputs) ? inputs.toArray() : inputs);\n    return this;\n  }\n\n  public to(\n    outputs: OneOrMore<OutputBuilder>,\n    options?: CollectionAddOptions\n  ): TransactionBuilder {\n    this._outputs.add(outputs, options);\n\n    return this;\n  }\n\n  public withDataFrom(\n    dataInputs: OneOrMore<Box<Amount>>,\n    options?: CollectionAddOptions\n  ): TransactionBuilder {\n    this._dataInputs.add(dataInputs, options);\n\n    return this;\n  }\n\n  public sendChangeTo(\n    address: ErgoAddress | Base58String | HexString\n  ): TransactionBuilder {\n    if (typeof address === \"string\") {\n      this._changeAddress = isHex(address)\n        ? ErgoAddress.fromErgoTree(address, Network.Mainnet)\n        : ErgoAddress.fromBase58(address);\n    } else {\n      this._changeAddress = address;\n    }\n\n    return this;\n  }\n\n  public payFee(amount: Amount): TransactionBuilder {\n    this._feeAmount = ensureBigInt(amount);\n\n    return this;\n  }\n\n  public payMinFee(): TransactionBuilder {\n    this.payFee(RECOMMENDED_MIN_FEE_VALUE);\n\n    return this;\n  }\n\n  public burnTokens(\n    tokens: OneOrMore<TokenAmount<Amount>>\n  ): TransactionBuilder {\n    if (!this._burning) {\n      this._burning = new TokensCollection();\n    }\n    this._burning.add(tokens);\n\n    return this;\n  }\n\n  public configure(callback: ConfigureCallback): TransactionBuilder {\n    callback(this._settings);\n\n    return this;\n  }\n\n  public configureSelector(\n    selectorCallback: SelectorCallback\n  ): TransactionBuilder {\n    if (isUndefined(this._selectorCallbacks)) {\n      this._selectorCallbacks = [];\n    }\n\n    this._selectorCallbacks.push(selectorCallback);\n\n    return this;\n  }\n\n  public extend(plugins: FleetPlugin): TransactionBuilder {\n    if (!this._plugins) {\n      this._plugins = [];\n    }\n    this._plugins.push({ execute: plugins, pending: true });\n\n    return this;\n  }\n\n  public eject(ejector: (context: EjectorContext) => void): TransactionBuilder {\n    ejector({\n      inputs: this.inputs,\n      dataInputs: this.dataInputs,\n      outputs: this.outputs,\n      burning: this.burning,\n      settings: this.settings,\n      selection: (selectorCallback: SelectorCallback) => {\n        this.configureSelector(selectorCallback);\n      }\n    });\n\n    return this;\n  }\n\n  public build(): ErgoUnsignedTransaction {\n    if (some(this._plugins)) {\n      const context = createPluginContext(this);\n      for (const plugin of this._plugins) {\n        if (plugin.pending) {\n          plugin.execute(context);\n          plugin.pending = false;\n        }\n      }\n    }\n\n    if (this._isMinting()) {\n      if (this._isMoreThanOneTokenBeingMinted()) {\n        throw new MalformedTransaction(\n          \"only one token can be minted per transaction.\"\n        );\n      }\n\n      if (this._isTheSameTokenBeingMintedFromOutsideTheMintingBox()) {\n        throw new NonStandardizedMinting(\n          \"EIP-4 tokens cannot be minted from outside of the minting box.\"\n        );\n      }\n    }\n\n    this.outputs\n      .toArray()\n      .map((output) =>\n        output.setCreationHeight(this._creationHeight, { replace: false })\n      );\n    const outputs = this.outputs.clone();\n\n    if (isDefined(this._feeAmount)) {\n      outputs.add(new OutputBuilder(this._feeAmount, FEE_CONTRACT));\n    }\n\n    const selector = new BoxSelector(this.inputs.toArray());\n    if (some(this._selectorCallbacks)) {\n      for (const selectorCallBack of this._selectorCallbacks) {\n        selectorCallBack(selector);\n      }\n    }\n\n    const target = some(this._burning)\n      ? outputs.sum({ tokens: this._burning.toArray() })\n      : outputs.sum();\n    let inputs = selector.select(target);\n\n    if (isDefined(this._changeAddress)) {\n      let change = utxoDiff(utxoSum(inputs), target);\n      const changeBoxes: OutputBuilder[] = [];\n\n      if (some(change.tokens)) {\n        let minRequiredNanoErgs = estimateMinChangeValue({\n          changeAddress: this._changeAddress,\n          creationHeight: this._creationHeight,\n          tokens: change.tokens,\n          maxTokensPerBox: this.settings.maxTokensPerChangeBox,\n          baseIndex: this.outputs.length + 1\n        });\n\n        while (minRequiredNanoErgs > change.nanoErgs) {\n          inputs = selector.select({\n            nanoErgs: target.nanoErgs + minRequiredNanoErgs,\n            tokens: target.tokens\n          });\n\n          change = utxoDiff(utxoSum(inputs), target);\n          minRequiredNanoErgs = estimateMinChangeValue({\n            changeAddress: this._changeAddress,\n            creationHeight: this._creationHeight,\n            tokens: change.tokens,\n            maxTokensPerBox: this.settings.maxTokensPerChangeBox,\n            baseIndex: this.outputs.length + 1\n          });\n        }\n\n        const chunkedTokens = chunk(\n          change.tokens,\n          this._settings.maxTokensPerChangeBox\n        );\n        for (const tokens of chunkedTokens) {\n          const output = new OutputBuilder(\n            estimateMinBoxValue(),\n            this._changeAddress,\n            this._creationHeight\n          ).addTokens(tokens);\n\n          change.nanoErgs -= output.value;\n          changeBoxes.push(output);\n        }\n      }\n\n      if (change.nanoErgs > _0n) {\n        if (some(changeBoxes)) {\n          if (this.settings.shouldIsolateErgOnChange) {\n            outputs.add(\n              new OutputBuilder(change.nanoErgs, this._changeAddress)\n            );\n          } else {\n            const firstChangeBox = first(changeBoxes);\n            firstChangeBox.setValue(firstChangeBox.value + change.nanoErgs);\n          }\n\n          outputs.add(changeBoxes);\n        } else {\n          outputs.add(new OutputBuilder(change.nanoErgs, this._changeAddress));\n        }\n      }\n    }\n\n    for (const input of inputs) {\n      if (!input.isValid()) {\n        throw new InvalidInput(input.boxId);\n      }\n    }\n\n    const unsignedTransaction = new ErgoUnsignedTransaction(\n      inputs,\n      this.dataInputs.toArray(),\n      outputs\n        .toArray()\n        .map((output) =>\n          output\n            .setCreationHeight(this._creationHeight, { replace: false })\n            .build(inputs)\n        )\n    );\n\n    let burning = unsignedTransaction.burning;\n    if (burning.nanoErgs > _0n) {\n      throw new MalformedTransaction(\"it's not possible to burn ERG.\");\n    }\n\n    if (some(burning.tokens) && some(this._burning)) {\n      burning = utxoDiff(burning, {\n        nanoErgs: _0n,\n        tokens: this._burning.toArray()\n      });\n    }\n\n    if (!this._settings.canBurnTokens && some(burning.tokens)) {\n      throw new NotAllowedTokenBurning();\n    }\n\n    return unsignedTransaction;\n  }\n\n  private _isMinting(): boolean {\n    for (const output of this._outputs) {\n      if (output.minting) return true;\n    }\n\n    return false;\n  }\n\n  private _isMoreThanOneTokenBeingMinted(): boolean {\n    let mintingCount = 0;\n\n    for (const output of this._outputs) {\n      if (isDefined(output.minting)) {\n        mintingCount++;\n        if (mintingCount > 1) return true;\n      }\n    }\n\n    return false;\n  }\n\n  private _isTheSameTokenBeingMintedFromOutsideTheMintingBox(): boolean {\n    const mintingTokenId = this._getMintingTokenId();\n    if (isUndefined(mintingTokenId)) return false;\n\n    let count = 0;\n    for (const output of this._outputs) {\n      if (output.assets.contains(mintingTokenId)) {\n        count++;\n        if (count > 1) return true;\n      }\n    }\n\n    return false;\n  }\n\n  private _getMintingTokenId(): string | undefined {\n    let tokenId = undefined;\n    for (const output of this._outputs) {\n      if (output.minting) {\n        tokenId = output.minting.tokenId;\n        break;\n      }\n    }\n\n    return tokenId;\n  }\n}\n\nfunction isCollectionLike<T>(obj: unknown): obj is CollectionLike<T> {\n  return (obj as CollectionLike<T>).toArray !== undefined;\n}\n\ntype ChangeEstimationParams = {\n  changeAddress: ErgoAddress;\n  creationHeight: number;\n  tokens: TokenAmount<bigint>[];\n  baseIndex: number;\n  maxTokensPerBox: number;\n};\n\nfunction estimateMinChangeValue(params: ChangeEstimationParams): bigint {\n  const size = BigInt(estimateChangeSize(params));\n\n  return size * BOX_VALUE_PER_BYTE;\n}\n\nfunction estimateChangeSize({\n  changeAddress,\n  creationHeight,\n  tokens,\n  baseIndex,\n  maxTokensPerBox\n}: ChangeEstimationParams): number {\n  const neededBoxes = Math.ceil(tokens.length / maxTokensPerBox);\n  let size = 0;\n  size += estimateVLQSize(SAFE_MIN_BOX_VALUE);\n  size += byteSizeOf(changeAddress.ergoTree);\n  size += estimateVLQSize(creationHeight);\n  size += estimateVLQSize(0); // empty registers length\n  size += 32; // BLAKE 256 hash length\n\n  size = size * neededBoxes;\n  for (let i = 0; i < neededBoxes; i++) {\n    size += estimateVLQSize(baseIndex + i);\n  }\n\n  for (const token of tokens) {\n    size += byteSizeOf(token.tokenId) + estimateVLQSize(token.amount);\n  }\n\n  if (tokens.length > maxTokensPerBox) {\n    if (tokens.length % maxTokensPerBox > 0) {\n      size +=\n        estimateVLQSize(maxTokensPerBox) *\n        Math.floor(tokens.length / maxTokensPerBox);\n      size += estimateVLQSize(tokens.length % maxTokensPerBox);\n    } else {\n      size += estimateVLQSize(maxTokensPerBox) * neededBoxes;\n    }\n  } else {\n    size += estimateVLQSize(tokens.length);\n  }\n\n  return size;\n}\n","export class NonStandardizedMinting extends Error {}\n","import type {\n  Amount,\n  Box,\n  CollectionAddOptions,\n  OneOrMore,\n  TokenAmount\n} from \"@fleet-sdk/common\";\nimport {\n  NotAllowedTokenBurning,\n  type OutputBuilder,\n  type TransactionBuilder\n} from \"..\";\n\nexport type FleetPluginContext = {\n  /**\n   * Add and ensures selection of one or more inputs to the inputs list\n   * @param inputs\n   * @returns new list length\n   */\n  addInputs: (inputs: OneOrMore<Box<Amount>>) => number;\n\n  /**\n   * Add one or more data inputs to the data inputs list\n   * @param dataInputs\n   * @returns new list length\n   */\n  addDataInputs: (\n    dataInputs: OneOrMore<Box<Amount>>,\n    options?: CollectionAddOptions\n  ) => number;\n\n  /**\n   * Add one or more outputs to the outputs list\n   * @param outputs\n   * @param options\n   * @returns new list length\n   */\n  addOutputs: (\n    outputs: OneOrMore<OutputBuilder>,\n    options?: CollectionAddOptions\n  ) => number;\n\n  /**\n   * Burn tokens\n   * @param tokens\n   * @throws Burning tokens thought a plugin, requires explicitly permission\n   * from {@link TransactionBuilder.configure}, if token burning is not allowed\n   * it will thrown a {@link NotAllowedTokenBurning} exception.\n   */\n  burnTokens: (tokens: OneOrMore<TokenAmount<Amount>>) => void;\n\n  /**\n   * Set transaction fee amount\n   * @param amount amount in nanoergs\n   */\n  setFee: (amount: Amount) => void;\n};\n\nexport function createPluginContext(\n  transactionBuilder: TransactionBuilder\n): FleetPluginContext {\n  return {\n    addInputs: (inputs) =>\n      transactionBuilder\n        .from(inputs)\n        .configureSelector((selector) =>\n          selector.ensureInclusion(\n            Array.isArray(inputs)\n              ? inputs.map((input) => input.boxId)\n              : inputs.boxId\n          )\n        ).inputs.length,\n    addOutputs: (outputs, options) =>\n      transactionBuilder.to(outputs, options).outputs.length,\n    addDataInputs: (dataInputs, options) =>\n      transactionBuilder.withDataFrom(dataInputs, options).dataInputs.length,\n    burnTokens: (tokens) => {\n      if (!transactionBuilder.settings.canBurnTokensFromPlugins) {\n        throw new NotAllowedTokenBurning();\n      }\n      transactionBuilder.burnTokens(tokens);\n    },\n    setFee: (amount) => transactionBuilder.payFee(amount)\n  };\n}\n","import { MAX_TOKENS_PER_BOX } from \"../models\";\n\nexport class TransactionBuilderSettings {\n  private _maxDistinctTokensPerChangeBox: number;\n  private _allowTokenBurning: boolean;\n  private _allowTokenBurningFromPlugins: boolean;\n  private _isolateErgOnChange: boolean;\n\n  constructor() {\n    this._maxDistinctTokensPerChangeBox = MAX_TOKENS_PER_BOX;\n    this._allowTokenBurning = false;\n    this._allowTokenBurningFromPlugins = false;\n    this._isolateErgOnChange = false;\n  }\n\n  public get maxTokensPerChangeBox(): number {\n    return this._maxDistinctTokensPerChangeBox;\n  }\n\n  public get canBurnTokens(): boolean {\n    return this._allowTokenBurning;\n  }\n\n  public get canBurnTokensFromPlugins(): boolean {\n    return this.canBurnTokens || this._allowTokenBurningFromPlugins;\n  }\n\n  public get shouldIsolateErgOnChange(): boolean {\n    return this._isolateErgOnChange;\n  }\n\n  /**\n   * Define max number of distinct tokens per change box\n   */\n  public setMaxTokensPerChangeBox(max: number): TransactionBuilderSettings {\n    this._maxDistinctTokensPerChangeBox = max;\n\n    return this;\n  }\n\n  /**\n   * Allows or denies token burning from all contexts\n   */\n  public allowTokenBurning(allow = true): TransactionBuilderSettings {\n    this._allowTokenBurning = allow;\n\n    return this;\n  }\n\n  /**\n   * Allows or denies token burning **only** from plugins context.\n   */\n  public allowTokenBurningFromPlugins(\n    allow = true\n  ): TransactionBuilderSettings {\n    this._allowTokenBurningFromPlugins = allow;\n\n    return this;\n  }\n\n  /**\n   * If true, it creates an exclusive change box only for ERG.\n   * This setting is especially useful for Ledger devices to\n   * help on avoiding to hit the max tokens limit per transaction.\n   */\n  public isolateErgOnChange(isolate = true): TransactionBuilderSettings {\n    this._isolateErgOnChange = isolate;\n\n    return this;\n  }\n}\n","import type { HexString } from \"@fleet-sdk/common\";\nimport {\n  SBigInt,\n  SBool,\n  SByte,\n  SColl,\n  SCollType,\n  SConstant as SerSConstant,\n  SGroupElement,\n  SInt,\n  SLong,\n  SShort,\n  SSigmaProp,\n  SType,\n  SUnit\n} from \"@fleet-sdk/serializer\";\n\n/**\n * @deprecated Use {@link @fleet-sdk/serializer} instead.\n * This function will be removed from core package in v1.0.0.\n */\nexport function SConstant(constant: SerSConstant): HexString {\n  return constant.toHex();\n}\n\n/**\n * @deprecated Use {@link @fleet-sdk/serializer} instead.\n * This function will be removed from core package in v1.0.0.\n */\nexport function SParse<T>(bytes: HexString | Uint8Array): T {\n  return SerSConstant.from<T>(bytes).data;\n}\n\nexport {\n  SBigInt,\n  SBool,\n  SByte,\n  SCollType,\n  SColl,\n  SGroupElement,\n  SInt,\n  SLong,\n  SShort,\n  SSigmaProp,\n  SType,\n  SUnit\n};\n","export * from \"./builder\";\nexport * from \"./models\";\nexport * from \"./errors\";\nexport * from \"./constantSerializer\";\nexport { AddressType, Network } from \"@fleet-sdk/common\";\nexport type { Box, Amount, TokenAmount } from \"@fleet-sdk/common\";\n"]}