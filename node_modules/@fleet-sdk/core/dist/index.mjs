import { some, sumBy, isUndefined, isEmpty, isDefined, utxoSum, _0n, orderBy, hasDuplicatesBy, first, ensureBigInt, Collection, FleetError, Network, concatBytes, AddressType, utxoDiff, ergoTreeHeaderFlags, isHex, areEqual, _1n, areRegistersDenselyPacked, assert, chunk, byteSizeOf, startsWith, endsWith } from '@fleet-sdk/common';
export { AddressType, Network } from '@fleet-sdk/common';
import { hex, base58, ensureBytes, validateEcPoint, blake2b256, utf8 } from '@fleet-sdk/crypto';
import { serializeBox, serializeTransaction, SigmaByteWriter, SColl, SByte, estimateBoxSize, estimateVLQSize, SConstant as SConstant$1 } from '@fleet-sdk/serializer';
export { SBigInt, SBool, SByte, SColl, SCollType, SGroupElement, SInt, SLong, SShort, SSigmaProp, SType, SUnit } from '@fleet-sdk/serializer';

// src/builder/selector/boxSelector.ts

// src/errors/duplicateInputSelectionError.ts
var DuplicateInputSelectionError = class extends Error {
  constructor() {
    super(
      "One or more inputs was selected more than one time by the current selection strategy."
    );
  }
};
var InsufficientInputs = class extends Error {
  unreached;
  constructor(unreached) {
    const strings = [];
    if (unreached.nanoErgs) {
      strings.push(buildString("nanoErgs", unreached.nanoErgs));
    }
    if (some(unreached.tokens)) {
      for (const token of unreached.tokens) {
        strings.push(buildString(token.tokenId, token.amount));
      }
    }
    super(`Insufficient inputs:${strings.join()}`);
    this.unreached = unreached;
  }
};
function buildString(tokenId, amount) {
  return `
  > ${tokenId}: ${amount?.toString()}`;
}
var AccumulativeSelectionStrategy = class {
  _inputs;
  select(inputs, target) {
    this._inputs = inputs;
    let selection = [];
    if (some(target.tokens)) {
      selection = this._selectTokens(target.tokens);
    }
    const selectedNanoErgs = sumBy(selection, (input) => input.value);
    if (isUndefined(target.nanoErgs) && isEmpty(target.tokens) || isDefined(target.nanoErgs) && selectedNanoErgs < target.nanoErgs) {
      const targetAmount = isDefined(target.nanoErgs) ? target.nanoErgs - selectedNanoErgs : void 0;
      selection = selection.concat(this._select(targetAmount));
    }
    return selection;
  }
  _selectTokens(targets) {
    let selection = [];
    for (const target of targets) {
      const targetAmount = isDefined(target.amount) ? target.amount - utxoSum(selection, target.tokenId) : void 0;
      if (targetAmount && targetAmount <= _0n) {
        continue;
      }
      selection = selection.concat(this._select(targetAmount, target.tokenId));
    }
    return selection;
  }
  _select(target, tokenId) {
    const inputs = this._inputs;
    let acc = _0n;
    let selection = [];
    if (isUndefined(target)) {
      if (tokenId) {
        selection = inputs.filter(
          (x) => x.assets.some((asset) => asset.tokenId === tokenId)
        );
      } else {
        selection = inputs;
      }
    } else {
      for (let i = 0; i < inputs.length && acc < target; i++) {
        if (tokenId) {
          for (const token of inputs[i].assets) {
            if (token.tokenId !== tokenId) {
              continue;
            }
            acc += token.amount;
            selection.push(inputs[i]);
          }
        } else {
          acc += inputs[i].value;
          selection.push(inputs[i]);
        }
      }
    }
    if (some(selection)) {
      this._inputs = this._inputs.filter((input) => !selection.includes(input));
    }
    return selection;
  }
};

// src/builder/selector/strategies/customSelectionStrategy.ts
var CustomSelectionStrategy = class {
  _selector;
  constructor(selector) {
    this._selector = selector;
  }
  select(inputs, target) {
    return this._selector(inputs, target);
  }
};

// src/builder/selector/boxSelector.ts
var BoxSelector = class {
  _inputs;
  _strategy;
  _ensureFilterPredicate;
  _selector;
  _sortDirection;
  _ensureInclusionBoxIds;
  constructor(inputs) {
    this._inputs = inputs;
  }
  defineStrategy(strategy) {
    if (this._isISelectionStrategyImplementation(strategy)) {
      this._strategy = strategy;
    } else {
      this._strategy = new CustomSelectionStrategy(strategy);
    }
    return this;
  }
  select(target) {
    if (!this._strategy) {
      this._strategy = new AccumulativeSelectionStrategy();
    }
    const remaining = this._deepCloneTarget(target);
    let unselected = [...this._inputs];
    let selected = [];
    const predicate = this._ensureFilterPredicate;
    const inclusion = this._ensureInclusionBoxIds;
    if (predicate) {
      if (inclusion) {
        selected = unselected.filter(
          (box) => predicate(box) || inclusion.has(box.boxId)
        );
      } else {
        selected = unselected.filter(predicate);
      }
    } else if (inclusion) {
      selected = unselected.filter((box) => inclusion.has(box.boxId));
    }
    if (some(selected)) {
      unselected = unselected.filter(
        (box) => !selected.some((sel) => sel.boxId === box.boxId)
      );
      if (remaining.nanoErgs && remaining.nanoErgs > _0n) {
        remaining.nanoErgs -= sumBy(selected, (input) => input.value);
      }
      if (some(remaining.tokens) && selected.some((input) => !isEmpty(input.assets))) {
        for (const t of remaining.tokens) {
          if (t.amount && t.amount > _0n) {
            t.amount -= utxoSum(selected, t.tokenId);
          }
        }
      }
    }
    if (this._selector) {
      unselected = orderBy(
        unselected,
        this._selector,
        this._sortDirection || "asc"
      );
    }
    selected = selected.concat(this._strategy.select(unselected, remaining));
    if (hasDuplicatesBy(selected, (item) => item.boxId)) {
      throw new DuplicateInputSelectionError();
    }
    const unreached = this._getUnreachedTargets(selected, target);
    if (unreached.nanoErgs || some(unreached.tokens)) {
      throw new InsufficientInputs(unreached);
    }
    return selected;
  }
  _deepCloneTarget(target) {
    return {
      nanoErgs: target.nanoErgs,
      tokens: target.tokens ? target.tokens.map((t) => ({ tokenId: t.tokenId, amount: t.amount })) : void 0
    };
  }
  _getUnreachedTargets(inputs, target) {
    const unreached = {
      nanoErgs: void 0,
      tokens: void 0
    };
    const selectedNanoergs = sumBy(inputs, (input) => input.value);
    if (target.nanoErgs && target.nanoErgs > selectedNanoergs) {
      unreached.nanoErgs = target.nanoErgs - selectedNanoergs;
    }
    if (isEmpty(target.tokens)) {
      return unreached;
    }
    for (const tokenTarget of target.tokens) {
      const totalSelected = utxoSum(inputs, tokenTarget.tokenId);
      if (tokenTarget.amount && tokenTarget.amount > totalSelected) {
        if (tokenTarget.tokenId === first(inputs).boxId) {
          continue;
        }
        if (isUndefined(unreached.tokens)) {
          unreached.tokens = [];
        }
        unreached.tokens.push({
          tokenId: tokenTarget.tokenId,
          amount: tokenTarget.amount - totalSelected
        });
      }
    }
    return unreached;
  }
  ensureInclusion(predicateOrBoxIds) {
    if (typeof predicateOrBoxIds === "function") {
      this._ensureFilterPredicate = predicateOrBoxIds;
    } else if (predicateOrBoxIds === "all") {
      this._ensureFilterPredicate = (box) => box.value > 0n;
    } else {
      if (isUndefined(this._ensureInclusionBoxIds)) {
        this._ensureInclusionBoxIds = /* @__PURE__ */ new Set();
      }
      if (Array.isArray(predicateOrBoxIds)) {
        for (const boxId of predicateOrBoxIds) {
          this._ensureInclusionBoxIds.add(boxId);
        }
      } else {
        this._ensureInclusionBoxIds.add(predicateOrBoxIds);
      }
    }
    return this;
  }
  orderBy(selector, direction) {
    this._selector = selector;
    this._sortDirection = direction;
    return this;
  }
  _isISelectionStrategyImplementation(obj) {
    if (obj.select) {
      return true;
    }
    return false;
  }
  static buildTargetFrom(boxes) {
    const tokens = {};
    let nanoErgs = _0n;
    for (const box of boxes) {
      nanoErgs += ensureBigInt(box.value);
      for (const token of box.assets) {
        tokens[token.tokenId] = (tokens[token.tokenId] || _0n) + ensureBigInt(token.amount);
      }
    }
    return {
      nanoErgs,
      tokens: Object.keys(tokens).map((tokenId) => ({
        tokenId,
        amount: tokens[tokenId]
      }))
    };
  }
};
var CherryPickSelectionStrategy = class extends AccumulativeSelectionStrategy {
  select(inputs, target) {
    const orderedInputs = orderBy(
      inputs,
      (x) => new Set(x.assets.map((asset) => asset.tokenId)).size,
      "asc"
    );
    return super.select(orderedInputs, target);
  }
};

// src/errors/duplicateInputError.ts
var DuplicateInputError = class extends Error {
  constructor(boxId) {
    super(`Box '${boxId}' is already included.`);
  }
};

// src/errors/insufficientTokenAmount.ts
var InsufficientTokenAmount = class extends Error {
};

// src/errors/invalidAddress.ts
var InvalidAddress = class extends Error {
  constructor(address) {
    super(`Invalid Ergo address: ${address}`);
  }
};

// src/errors/invalidInput.ts
var InvalidInput = class extends Error {
  constructor(boxId) {
    super(`Invalid input: ${boxId}`);
  }
};

// src/errors/invalidRegistersPacking.ts
var InvalidRegistersPacking = class extends Error {
  constructor() {
    super(
      `Registers should be densely packed. This means that it's not possible to use a register like 'R7' without filling 'R6', 'R5' and 'R4', for example.`
    );
  }
};

// src/errors/malformedTransaction.ts
var MalformedTransaction = class extends Error {
  constructor(message) {
    super(`Malformed transaction: ${message}`);
  }
};
var MAX_TOKENS_PER_BOX = 120;
var TokensCollection = class extends Collection {
  #minting;
  constructor(tokens, options) {
    super();
    if (isDefined(tokens)) {
      this.add(tokens, options);
    }
  }
  get minting() {
    if (!this.#minting) return void 0;
    return {
      ...this.#minting.metadata,
      amount: this._items[this.#minting.index].amount
    };
  }
  _map(token) {
    return { tokenId: token.tokenId, amount: ensureBigInt(token.amount) };
  }
  _addOne(token, options) {
    if (isUndefined(options) || options.sum && isUndefined(options.index)) {
      if (this._sum(this._map(token))) return this.length;
    }
    if (this._items.length >= MAX_TOKENS_PER_BOX) throw new MaxTokensOverflow();
    super._addOne(token, options);
    return this.length;
  }
  add(items, options) {
    if (Array.isArray(items)) {
      if (items.some((x) => !x.tokenId))
        throw new FleetError("TokenID is required.");
    } else if (!items.tokenId) {
      throw new FleetError("TokenID is required.");
    }
    return super.add(items, options);
  }
  mint(token) {
    if (isDefined(this.#minting)) {
      throw new FleetError(
        "Only one minting token is allowed per transaction."
      );
    }
    const len = super.add({ tokenId: token.tokenId, amount: token.amount });
    this.#minting = { index: len - 1, metadata: token };
    return this.length;
  }
  _sum(token) {
    for (const t of this._items) {
      if (t.tokenId === token.tokenId) {
        t.amount += token.amount;
        return true;
      }
    }
    return false;
  }
  remove(tokenIdOrIndex, amount) {
    let index = -1;
    if (typeof tokenIdOrIndex === "number") {
      if (this._isIndexOutOfBounds(tokenIdOrIndex)) {
        throw new RangeError(`Index '${tokenIdOrIndex}' is out of range.`);
      }
      index = tokenIdOrIndex;
    } else {
      index = this._items.findIndex(
        (token) => token.tokenId === tokenIdOrIndex
      );
      if (this._isIndexOutOfBounds(index)) {
        throw new NotFoundError(
          `TokenId '${tokenIdOrIndex}' not found in assets collection.`
        );
      }
    }
    if (amount && index > -1) {
      const bigAmount = ensureBigInt(amount);
      const token = this._items[index];
      if (bigAmount > token.amount) {
        throw new InsufficientTokenAmount(
          "Insufficient token amount to perform a subtraction operation."
        );
      }
      if (bigAmount < token.amount) {
        token.amount -= bigAmount;
        return this.length;
      }
    }
    this._items.splice(index, 1);
    return this.length;
  }
  contains(tokenId) {
    return this._items.some((x) => x.tokenId === tokenId);
  }
  toArray(mintingTokenId) {
    if (this.minting) {
      if (!mintingTokenId) throw new UndefinedMintingContext();
      return this._items.map((x) => ({
        tokenId: x.tokenId ? x.tokenId : mintingTokenId,
        amount: x.amount
      }));
    }
    return super.toArray();
  }
};

// src/errors/maxTokensOverflow.ts
var MaxTokensOverflow = class extends Error {
  constructor() {
    super(
      `A box must contain no more than ${MAX_TOKENS_PER_BOX} distinct tokens.`
    );
  }
};

// src/errors/notAllowedTokenBurning.ts
var NotAllowedTokenBurning = class extends Error {
  constructor() {
    super(
      "This transaction is trying to burn tokens. If that's your intention you must explicitly allow token burning on TransactionBuilder.configure() method. If no, a change address should be provided."
    );
  }
};

// src/errors/notFoundError.ts
var NotFoundError = class extends Error {
};

// src/errors/undefinedCreationHeight.ts
var UndefinedCreationHeight = class extends Error {
  constructor() {
    super(
      "Minting context is undefined. Transaction's inputs must be included in order to determine minting token id."
    );
  }
};

// src/errors/undefinedMintingContext.ts
var UndefinedMintingContext = class extends Error {
  constructor() {
    super("Creation Height is undefined.");
  }
};
var CHECKSUM_LENGTH = 4;
var BLAKE_256_HASH_LENGTH = 32;
function getNetworkType(addressBytes) {
  return first(addressBytes) & 240;
}
function getAddressType(addressBytes) {
  return first(addressBytes) & 15;
}
function unpackAddress(bytes) {
  return {
    head: bytes.subarray(0, 1),
    body: bytes.subarray(1, bytes.length - CHECKSUM_LENGTH),
    checksum: bytes.subarray(bytes.length - CHECKSUM_LENGTH, bytes.length),
    network: getNetworkType(bytes),
    type: getAddressType(bytes)
  };
}
function encodeAddress(network, type, content) {
  return new SigmaByteWriter(1 + content.length + CHECKSUM_LENGTH).write(network + type).writeBytes(content).writeChecksum(CHECKSUM_LENGTH).encode(base58);
}
function validateUnpackedAddress(unpacked) {
  const content = concatBytes(unpacked.head, unpacked.body);
  if (isEmpty(unpacked.body)) return false;
  if (unpacked.type === AddressType.P2PK && !validateEcPoint(unpacked.body))
    return false;
  const checksum = blake2b256(content).subarray(0, CHECKSUM_LENGTH);
  return areEqual(checksum, unpacked.checksum);
}
function validateAddress(encodedAddress) {
  return validateUnpackedAddress(unpackAddress(base58.decode(encodedAddress)));
}

// src/models/ergoAddress.ts
var P2PK_ERGOTREE_PREFIX = hex.decode("0008cd");
var P2PK_ERGOTREE_LENGTH = 36;
var P2SH_ERGOTREE_SUFFIX = hex.decode("d40801");
var P2SH_ERGOTREE_PREFIX = hex.decode("00ea02d193b4cbe4e3010e040004300e18");
var P2SH_ERGOTREE_LENGTH = 44;
var P2SH_HASH_LENGTH = 24;
function getErgoTreeType(ergoTree) {
  if (ergoTree.length === P2PK_ERGOTREE_LENGTH && startsWith(ergoTree, P2PK_ERGOTREE_PREFIX)) {
    return AddressType.P2PK;
  }
  if (ergoTree.length === P2SH_ERGOTREE_LENGTH && startsWith(ergoTree, P2SH_ERGOTREE_PREFIX) && endsWith(ergoTree, P2SH_ERGOTREE_SUFFIX)) {
    return AddressType.P2SH;
  }
  return AddressType.P2S;
}
var ErgoAddress = class _ErgoAddress {
  #ergoTree;
  #network;
  #type;
  get network() {
    return this.#network;
  }
  /**
   * ErgoTree hex string
   */
  get ergoTree() {
    return hex.encode(this.#ergoTree);
  }
  get type() {
    return this.#type;
  }
  /**
   * New instance from ErgoTree bytes
   * @param ergoTree ErgoTree bytes
   */
  constructor(ergoTree, network = Network.Mainnet) {
    this.#ergoTree = ergoTree;
    this.#network = network;
    this.#type = getErgoTreeType(ergoTree);
  }
  /**
   * Create a new instance from an ErgoTree
   * @param ergoTree ErgoTree hex string
   */
  static fromErgoTree(ergoTree, network) {
    return new _ErgoAddress(ensureBytes(ergoTree), network);
  }
  /**
   * Create a new instance from a public key
   * @param publicKey Public key hex string
   */
  static fromPublicKey(publicKey, network) {
    const bytes = ensureBytes(publicKey);
    if (!validateEcPoint(bytes)) throw new Error("The Public Key is invalid.");
    const ergoTree = concatBytes(P2PK_ERGOTREE_PREFIX, bytes);
    return new _ErgoAddress(ergoTree, network);
  }
  static fromHash(hash, network) {
    let bytes = ensureBytes(hash);
    if (bytes.length === BLAKE_256_HASH_LENGTH) {
      bytes = bytes.subarray(0, P2SH_HASH_LENGTH);
    } else if (bytes.length !== P2SH_HASH_LENGTH) {
      throw Error(`Invalid hash length: ${bytes.length}`);
    }
    const ergoTree = concatBytes(
      P2SH_ERGOTREE_PREFIX,
      bytes,
      P2SH_ERGOTREE_SUFFIX
    );
    return new _ErgoAddress(ergoTree, network);
  }
  /**
   * Create a new checked instance from an address string
   * @param encodedAddress Address encoded as base58
   */
  static decode(encodedAddress) {
    const bytes = base58.decode(encodedAddress);
    const unpacked = unpackAddress(bytes);
    if (!validateUnpackedAddress(unpacked))
      throw new InvalidAddress(encodedAddress);
    return _ErgoAddress.#fromUnpacked(unpacked);
  }
  static decodeUnsafe(encodedAddress) {
    return _ErgoAddress.#fromUnpacked(
      unpackAddress(base58.decode(encodedAddress))
    );
  }
  static fromBase58(address, unsafe = false) {
    return unsafe ? _ErgoAddress.decodeUnsafe(address) : _ErgoAddress.decode(address);
  }
  static #fromUnpacked(unpacked) {
    switch (unpacked.type) {
      case AddressType.P2PK:
        return _ErgoAddress.fromPublicKey(unpacked.body, unpacked.network);
      case AddressType.P2SH:
        return _ErgoAddress.fromHash(unpacked.body, unpacked.network);
      case AddressType.ADH:
        throw new Error("Invalid address type");
      default:
        return new _ErgoAddress(unpacked.body, unpacked.network);
    }
  }
  /**
   * Validate an address
   * @param address Address bytes or string
   * @deprecated Use `validateAddress()` function instead
   */
  static validate(address) {
    return validateAddress(address);
  }
  static getNetworkType(address) {
    return getNetworkType(base58.decode(address));
  }
  static getAddressType(address) {
    return getAddressType(base58.decode(address));
  }
  getPublicKeys() {
    if (this.type === AddressType.P2PK) {
      return [this.#ergoTree.subarray(P2PK_ERGOTREE_PREFIX.length)];
    }
    return [];
  }
  toP2SH(network) {
    if (this.type === AddressType.P2SH) return this.encode();
    const hash = blake2b256(this.#ergoTree).subarray(0, P2SH_HASH_LENGTH);
    return encodeAddress(network ?? this.#network, AddressType.P2SH, hash);
  }
  /**
   * Encode address as base58 string
   */
  encode(network) {
    let body;
    if (this.type === AddressType.P2PK) {
      body = first(this.getPublicKeys());
    } else if (this.type === AddressType.P2SH) {
      body = this.#ergoTree.subarray(
        P2SH_ERGOTREE_PREFIX.length,
        P2SH_ERGOTREE_PREFIX.length + P2SH_HASH_LENGTH
      );
    } else {
      body = this.#ergoTree;
    }
    return encodeAddress(network ?? this.#network, this.#type, body);
  }
  /**
   * Encode address as base58 string
   */
  toString(network) {
    return this.encode(network ?? this.#network);
  }
};
var ErgoBox = class _ErgoBox {
  boxId;
  value;
  ergoTree;
  creationHeight;
  assets;
  additionalRegisters;
  transactionId;
  index;
  constructor(box) {
    this.boxId = box.boxId;
    this.ergoTree = box.ergoTree;
    this.creationHeight = box.creationHeight;
    this.value = ensureBigInt(box.value);
    this.assets = box.assets.map((asset) => ({
      tokenId: asset.tokenId,
      amount: ensureBigInt(asset.amount)
    }));
    this.additionalRegisters = box.additionalRegisters;
    this.transactionId = box.transactionId;
    this.index = box.index;
  }
  isValid() {
    return _ErgoBox.validate(this);
  }
  static validate(box) {
    const bytes = serializeBox(box).toBytes();
    const hash = hex.encode(blake2b256(bytes));
    return box.boxId === hash;
  }
};

// src/models/ergoUnsignedInput.ts
var ErgoUnsignedInput = class extends ErgoBox {
  #extension;
  get extension() {
    return this.#extension;
  }
  constructor(box) {
    super(box);
    if (box.extension) {
      this.setContextVars(box.extension);
    }
  }
  setContextExtension(extension) {
    const vars = {};
    for (const key in extension) {
      const c = extension[key];
      if (!c) continue;
      vars[key] = typeof c === "string" ? c : c.toHex();
    }
    this.#extension = vars;
    return this;
  }
  /**
   * @deprecated use `setContextExtension` instead.
   */
  setContextVars(extension) {
    return this.setContextExtension(extension);
  }
  toUnsignedInputObject(type) {
    return {
      ...this.toPlainObject(type),
      extension: this.#extension || {}
    };
  }
  toPlainObject(type) {
    if (type === "EIP-12") {
      return {
        boxId: this.boxId,
        value: this.value.toString(),
        ergoTree: this.ergoTree,
        creationHeight: this.creationHeight,
        assets: this.assets.map((asset) => ({
          tokenId: asset.tokenId,
          amount: asset.amount.toString()
        })),
        additionalRegisters: this.additionalRegisters,
        transactionId: this.transactionId,
        index: this.index
      };
    }
    return { boxId: this.boxId };
  }
};
var ErgoUnsignedTransaction = class {
  _inputs;
  _dataInputs;
  _outputs;
  constructor(inputs, dataInputs, outputs) {
    this._inputs = Object.freeze(inputs);
    this._dataInputs = Object.freeze(dataInputs);
    this._outputs = Object.freeze(outputs);
  }
  get id() {
    return hex.encode(blake2b256(this.toBytes()));
  }
  get inputs() {
    return this._inputs;
  }
  get dataInputs() {
    return this._dataInputs;
  }
  get outputs() {
    return this._outputs;
  }
  get burning() {
    return utxoDiff(utxoSum(this.inputs), utxoSum(this.outputs));
  }
  toPlainObject(outputType) {
    return {
      inputs: this.inputs.map(
        (input) => input.toUnsignedInputObject(outputType || "default")
      ),
      dataInputs: this.dataInputs.map(
        (input) => input.toPlainObject(outputType || "default")
      ),
      outputs: this.outputs.map((output) => _stringifyBoxAmounts(output))
    };
  }
  toEIP12Object() {
    return this.toPlainObject("EIP-12");
  }
  toBytes() {
    return serializeTransaction({
      inputs: this.inputs.map(
        (input) => input.toUnsignedInputObject("default")
      ),
      dataInputs: this.dataInputs.map(
        (input) => input.toPlainObject("default")
      ),
      outputs: this.outputs
    }).toBytes();
  }
};
function _stringifyBoxAmounts(output) {
  return {
    ...output,
    value: output.value.toString(),
    assets: output.assets.map((token) => ({
      tokenId: token.tokenId,
      amount: token.amount.toString()
    }))
  };
}
var InputsCollection = class extends Collection {
  constructor(boxes) {
    super();
    if (isDefined(boxes)) {
      this.add(boxes);
    }
  }
  _map(input) {
    return input instanceof ErgoUnsignedInput ? input : new ErgoUnsignedInput(input);
  }
  _addOne(box) {
    if (this._items.some((item) => item.boxId === box.boxId)) {
      throw new DuplicateInputError(box.boxId);
    }
    return super._addOne(box);
  }
  remove(boxIdOrIndex) {
    let index = -1;
    if (typeof boxIdOrIndex === "number") {
      if (this._isIndexOutOfBounds(boxIdOrIndex)) {
        throw new RangeError(`Index '${boxIdOrIndex}' is out of range.`);
      }
      index = boxIdOrIndex;
    } else {
      index = this._items.findIndex((box) => box.boxId === boxIdOrIndex);
      if (this._isIndexOutOfBounds(index)) {
        throw new NotFoundError(
          "The input you are trying to remove is not present in the inputs collection."
        );
      }
    }
    this._items.splice(index, 1);
    return this.length;
  }
};
function setSum(map, key, value) {
  return map.set(key, (map.get(key) || _0n) + value);
}
var OutputsCollection = class _OutputsCollection extends Collection {
  constructor(outputs) {
    super();
    if (isDefined(outputs)) {
      this.add(outputs);
    }
  }
  _map(output) {
    return output;
  }
  remove(outputs) {
    let index = -1;
    if (typeof outputs === "number") {
      if (this._isIndexOutOfBounds(outputs)) {
        throw new RangeError(`Index '${outputs}' is out of range.`);
      }
      index = outputs;
    } else {
      index = this._items.lastIndexOf(outputs);
      if (this._isIndexOutOfBounds(index)) {
        throw new NotFoundError(
          "The output you are trying to remove is not present in the outputs collection."
        );
      }
    }
    this._items.splice(index, 1);
    return this.length;
  }
  clone() {
    return new _OutputsCollection(this._items);
  }
  sum(basis) {
    const tokens = /* @__PURE__ */ new Map();
    let nanoErgs = _0n;
    if (basis) {
      if (basis.nanoErgs) {
        nanoErgs = basis.nanoErgs;
      }
      if (some(basis.tokens)) {
        for (const token of basis.tokens) {
          if (isUndefined(token.amount)) continue;
          setSum(tokens, token.tokenId, token.amount);
        }
      }
    }
    for (const box of this._items) {
      nanoErgs += box.value;
      for (const token of box.assets) {
        if (token.tokenId) setSum(tokens, token.tokenId, token.amount);
      }
    }
    return {
      nanoErgs,
      tokens: Array.from(tokens, ([tokenId, amount]) => ({ tokenId, amount }))
    };
  }
};
var VERSION_MASK = 7;
var ErgoTree = class {
  _bytes;
  constructor(input) {
    if (typeof input === "string") {
      this._bytes = hex.decode(input);
    } else {
      this._bytes = input;
    }
  }
  get header() {
    return this._bytes[0];
  }
  get version() {
    return this.header & VERSION_MASK;
  }
  get hasSegregatedConstants() {
    return (this.header & ergoTreeHeaderFlags.constantSegregation) !== 0;
  }
  get hasSize() {
    return (this.header & ergoTreeHeaderFlags.sizeInclusion) !== 0;
  }
  toBytes() {
    return this._bytes;
  }
  toHex() {
    return hex.encode(this.toBytes());
  }
  toAddress(network = Network.Mainnet) {
    return ErgoAddress.fromErgoTree(this.toHex(), network);
  }
};
var SERIALIZED_HASH_LENGTH = 34;
var MessageType = {
  Hash: 0,
  Binary: 1,
  String: 2,
  Json: 3
};
var ErgoMessage = class _ErgoMessage {
  #data;
  #type;
  #hash;
  #network;
  constructor(options) {
    if ("data" in options) {
      [this.#data, this.#type] = this.#decodeData(options.data);
      this.#hash = blake2b256(this.#data);
    } else if ("hash" in options) {
      this.#hash = ensureBytes(options.hash);
      this.#type = MessageType.Hash;
    } else {
      throw new Error("Either hash or message data must be provided");
    }
    this.#network = options.network ?? Network.Mainnet;
  }
  get hash() {
    return this.#hash;
  }
  get type() {
    return this.#type;
  }
  get network() {
    return this.#network;
  }
  #decodeData(data) {
    if (typeof data === "string") {
      return isHex(data) ? [hex.decode(data), MessageType.Binary] : [utf8.decode(data), MessageType.String];
    }
    if (data instanceof Uint8Array) return [data, MessageType.Binary];
    return [utf8.decode(JSON.stringify(data)), MessageType.Json];
  }
  static decode(encodedHash) {
    const unpacked = unpackAddress(base58.decode(encodedHash));
    if (unpacked.type !== AddressType.ADH)
      throw new Error("Invalid message type");
    if (!validateUnpackedAddress(unpacked))
      throw new Error("Invalid encoded message hash");
    return new _ErgoMessage({ hash: unpacked.body, network: unpacked.network });
  }
  static fromBase58(encodedHash) {
    return _ErgoMessage.decode(encodedHash);
  }
  static fromData(data, network) {
    return new _ErgoMessage({ data, network });
  }
  encode(network) {
    return encodeAddress(network ?? this.#network, AddressType.ADH, this.hash);
  }
  toString(network) {
    return this.encode(network);
  }
  setNetwork(network) {
    this.#network = network;
    return this;
  }
  getData() {
    if (!this.#data) return;
    switch (this.#type) {
      case MessageType.String:
        return utf8.encode(this.#data);
      case MessageType.Json:
        return JSON.parse(utf8.encode(this.#data));
      default:
        return this.#data;
    }
  }
  serialize() {
    return new SigmaByteWriter(SERIALIZED_HASH_LENGTH).write(0).write(this.#network).writeBytes(this.#hash);
  }
  verify(message) {
    const [data] = this.#decodeData(message);
    return areEqual(this.#hash, blake2b256(data));
  }
};

// src/builder/outputBuilder.ts
var BOX_VALUE_PER_BYTE = BigInt(360);
var SAFE_MIN_BOX_VALUE = BigInt(1e6);
function estimateMinBoxValue(valuePerByte = BOX_VALUE_PER_BYTE) {
  return (output) => {
    return BigInt(output.estimateSize()) * valuePerByte;
  };
}
var DUMB_TOKEN_ID = "0000000000000000000000000000000000000000000000000000000000000000";
var OutputBuilder = class {
  _address;
  _tokens;
  _value;
  _valueEstimator;
  _creationHeight;
  _registers;
  constructor(value, recipient, creationHeight) {
    this.setValue(value);
    this._creationHeight = creationHeight;
    this._tokens = new TokensCollection();
    this._registers = {};
    if (typeof recipient === "string") {
      this._address = isHex(recipient) ? ErgoAddress.fromErgoTree(recipient) : ErgoAddress.fromBase58(recipient);
    } else if (recipient instanceof ErgoTree) {
      this._address = recipient.toAddress();
    } else {
      this._address = recipient;
    }
  }
  get value() {
    return isDefined(this._valueEstimator) ? this._valueEstimator(this) : this._value;
  }
  get address() {
    return this._address;
  }
  get ergoTree() {
    return this._address.ergoTree;
  }
  get creationHeight() {
    return this._creationHeight;
  }
  get assets() {
    return this._tokens;
  }
  get additionalRegisters() {
    return this._registers;
  }
  get minting() {
    return this.assets.minting;
  }
  setValue(value) {
    if (typeof value === "function") {
      this._valueEstimator = value;
    } else {
      this._value = ensureBigInt(value);
      this._valueEstimator = void 0;
      if (this._value <= _0n) {
        throw new Error(
          "An UTxO cannot be created without a minimum required amount."
        );
      }
    }
    return this;
  }
  addTokens(tokens, options) {
    if (tokens instanceof TokensCollection) {
      this._tokens.add(tokens.toArray(), options);
    } else {
      this._tokens.add(tokens, options);
    }
    return this;
  }
  addNfts(...tokenIds) {
    const tokens = tokenIds.map((tokenId) => ({ tokenId, amount: _1n }));
    return this.addTokens(tokens);
  }
  mintToken(token) {
    this.assets.mint(token);
    return this;
  }
  setCreationHeight(height, options) {
    if (isUndefined(options) || options.replace === true || options.replace === false && isUndefined(this._creationHeight)) {
      this._creationHeight = height;
    }
    return this;
  }
  setAdditionalRegisters(registers) {
    const hexRegisters = {};
    for (const key in registers) {
      const r = registers[key];
      if (!r) continue;
      hexRegisters[key] = typeof r === "string" ? r : r.toHex();
    }
    if (!areRegistersDenselyPacked(hexRegisters))
      throw new InvalidRegistersPacking();
    this._registers = hexRegisters;
    return this;
  }
  eject(ejector) {
    ejector({ tokens: this._tokens });
    return this;
  }
  build(transactionInputs) {
    let tokens;
    if (this.minting) {
      const mintingTokenId = transactionInputs ? transactionInputs[0]?.boxId : void 0;
      tokens = this.assets.toArray(mintingTokenId);
      if (isEmpty(this.additionalRegisters)) {
        this.setAdditionalRegisters({
          R4: SColl(SByte, utf8.decode(this.minting.name || "")),
          R5: SColl(SByte, utf8.decode(this.minting.description || "")),
          R6: SColl(
            SByte,
            utf8.decode(this.minting.decimals?.toString() || "0")
          )
        });
      }
    } else {
      tokens = this.assets.toArray();
    }
    if (isUndefined(this.creationHeight)) throw new UndefinedCreationHeight();
    return {
      value: this.value,
      ergoTree: this.ergoTree,
      creationHeight: this.creationHeight,
      assets: tokens,
      additionalRegisters: this.additionalRegisters
    };
  }
  estimateSize(value = SAFE_MIN_BOX_VALUE) {
    assert(!!this.creationHeight, "Creation height must be set");
    const plainBoxObject = {
      value,
      ergoTree: this.ergoTree,
      creationHeight: this.creationHeight,
      assets: this._tokens.toArray(DUMB_TOKEN_ID),
      additionalRegisters: this.additionalRegisters
    };
    return estimateBoxSize(plainBoxObject);
  }
};

// src/errors/nonStandardizedMinting.ts
var NonStandardizedMinting = class extends Error {
};

// src/builder/pluginContext.ts
function createPluginContext(transactionBuilder) {
  return {
    addInputs: (inputs) => transactionBuilder.from(inputs).configureSelector(
      (selector) => selector.ensureInclusion(
        Array.isArray(inputs) ? inputs.map((input) => input.boxId) : inputs.boxId
      )
    ).inputs.length,
    addOutputs: (outputs, options) => transactionBuilder.to(outputs, options).outputs.length,
    addDataInputs: (dataInputs, options) => transactionBuilder.withDataFrom(dataInputs, options).dataInputs.length,
    burnTokens: (tokens) => {
      if (!transactionBuilder.settings.canBurnTokensFromPlugins) {
        throw new NotAllowedTokenBurning();
      }
      transactionBuilder.burnTokens(tokens);
    },
    setFee: (amount) => transactionBuilder.payFee(amount)
  };
}

// src/builder/transactionBuilderSettings.ts
var TransactionBuilderSettings = class {
  _maxDistinctTokensPerChangeBox;
  _allowTokenBurning;
  _allowTokenBurningFromPlugins;
  _isolateErgOnChange;
  constructor() {
    this._maxDistinctTokensPerChangeBox = MAX_TOKENS_PER_BOX;
    this._allowTokenBurning = false;
    this._allowTokenBurningFromPlugins = false;
    this._isolateErgOnChange = false;
  }
  get maxTokensPerChangeBox() {
    return this._maxDistinctTokensPerChangeBox;
  }
  get canBurnTokens() {
    return this._allowTokenBurning;
  }
  get canBurnTokensFromPlugins() {
    return this.canBurnTokens || this._allowTokenBurningFromPlugins;
  }
  get shouldIsolateErgOnChange() {
    return this._isolateErgOnChange;
  }
  /**
   * Define max number of distinct tokens per change box
   */
  setMaxTokensPerChangeBox(max) {
    this._maxDistinctTokensPerChangeBox = max;
    return this;
  }
  /**
   * Allows or denies token burning from all contexts
   */
  allowTokenBurning(allow = true) {
    this._allowTokenBurning = allow;
    return this;
  }
  /**
   * Allows or denies token burning **only** from plugins context.
   */
  allowTokenBurningFromPlugins(allow = true) {
    this._allowTokenBurningFromPlugins = allow;
    return this;
  }
  /**
   * If true, it creates an exclusive change box only for ERG.
   * This setting is especially useful for Ledger devices to
   * help on avoiding to hit the max tokens limit per transaction.
   */
  isolateErgOnChange(isolate = true) {
    this._isolateErgOnChange = isolate;
    return this;
  }
};

// src/builder/transactionBuilder.ts
var RECOMMENDED_MIN_FEE_VALUE = BigInt(11e5);
var FEE_CONTRACT = "1005040004000e36100204a00b08cd0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798ea02d192a39a8cc7a701730073011001020402d19683030193a38cc7b2a57300000193c2b2a57301007473027303830108cdeeac93b1a57304";
var TransactionBuilder = class {
  _inputs;
  _dataInputs;
  _outputs;
  _settings;
  _creationHeight;
  _selectorCallbacks;
  _changeAddress;
  _feeAmount;
  _burning;
  _plugins;
  constructor(creationHeight) {
    this._inputs = new InputsCollection();
    this._dataInputs = new InputsCollection();
    this._outputs = new OutputsCollection();
    this._settings = new TransactionBuilderSettings();
    this._creationHeight = creationHeight;
  }
  get inputs() {
    return this._inputs;
  }
  get dataInputs() {
    return this._dataInputs;
  }
  get outputs() {
    return this._outputs;
  }
  get changeAddress() {
    return this._changeAddress;
  }
  get fee() {
    return this._feeAmount;
  }
  get burning() {
    return this._burning;
  }
  get settings() {
    return this._settings;
  }
  get creationHeight() {
    return this._creationHeight;
  }
  /**
   * Syntax sugar to be used in composition with another methods
   *
   * @example
   * ```
   * new TransactionBuilder(height)
   *   .from(inputs)
   *   .and.from(otherInputs);
   * ```
   */
  get and() {
    return this;
  }
  from(inputs) {
    this._inputs.add(isCollectionLike(inputs) ? inputs.toArray() : inputs);
    return this;
  }
  to(outputs, options) {
    this._outputs.add(outputs, options);
    return this;
  }
  withDataFrom(dataInputs, options) {
    this._dataInputs.add(dataInputs, options);
    return this;
  }
  sendChangeTo(address) {
    if (typeof address === "string") {
      this._changeAddress = isHex(address) ? ErgoAddress.fromErgoTree(address, Network.Mainnet) : ErgoAddress.fromBase58(address);
    } else {
      this._changeAddress = address;
    }
    return this;
  }
  payFee(amount) {
    this._feeAmount = ensureBigInt(amount);
    return this;
  }
  payMinFee() {
    this.payFee(RECOMMENDED_MIN_FEE_VALUE);
    return this;
  }
  burnTokens(tokens) {
    if (!this._burning) {
      this._burning = new TokensCollection();
    }
    this._burning.add(tokens);
    return this;
  }
  configure(callback) {
    callback(this._settings);
    return this;
  }
  configureSelector(selectorCallback) {
    if (isUndefined(this._selectorCallbacks)) {
      this._selectorCallbacks = [];
    }
    this._selectorCallbacks.push(selectorCallback);
    return this;
  }
  extend(plugins) {
    if (!this._plugins) {
      this._plugins = [];
    }
    this._plugins.push({ execute: plugins, pending: true });
    return this;
  }
  eject(ejector) {
    ejector({
      inputs: this.inputs,
      dataInputs: this.dataInputs,
      outputs: this.outputs,
      burning: this.burning,
      settings: this.settings,
      selection: (selectorCallback) => {
        this.configureSelector(selectorCallback);
      }
    });
    return this;
  }
  build() {
    if (some(this._plugins)) {
      const context = createPluginContext(this);
      for (const plugin of this._plugins) {
        if (plugin.pending) {
          plugin.execute(context);
          plugin.pending = false;
        }
      }
    }
    if (this._isMinting()) {
      if (this._isMoreThanOneTokenBeingMinted()) {
        throw new MalformedTransaction(
          "only one token can be minted per transaction."
        );
      }
      if (this._isTheSameTokenBeingMintedFromOutsideTheMintingBox()) {
        throw new NonStandardizedMinting(
          "EIP-4 tokens cannot be minted from outside of the minting box."
        );
      }
    }
    this.outputs.toArray().map(
      (output) => output.setCreationHeight(this._creationHeight, { replace: false })
    );
    const outputs = this.outputs.clone();
    if (isDefined(this._feeAmount)) {
      outputs.add(new OutputBuilder(this._feeAmount, FEE_CONTRACT));
    }
    const selector = new BoxSelector(this.inputs.toArray());
    if (some(this._selectorCallbacks)) {
      for (const selectorCallBack of this._selectorCallbacks) {
        selectorCallBack(selector);
      }
    }
    const target = some(this._burning) ? outputs.sum({ tokens: this._burning.toArray() }) : outputs.sum();
    let inputs = selector.select(target);
    if (isDefined(this._changeAddress)) {
      let change = utxoDiff(utxoSum(inputs), target);
      const changeBoxes = [];
      if (some(change.tokens)) {
        let minRequiredNanoErgs = estimateMinChangeValue({
          changeAddress: this._changeAddress,
          creationHeight: this._creationHeight,
          tokens: change.tokens,
          maxTokensPerBox: this.settings.maxTokensPerChangeBox,
          baseIndex: this.outputs.length + 1
        });
        while (minRequiredNanoErgs > change.nanoErgs) {
          inputs = selector.select({
            nanoErgs: target.nanoErgs + minRequiredNanoErgs,
            tokens: target.tokens
          });
          change = utxoDiff(utxoSum(inputs), target);
          minRequiredNanoErgs = estimateMinChangeValue({
            changeAddress: this._changeAddress,
            creationHeight: this._creationHeight,
            tokens: change.tokens,
            maxTokensPerBox: this.settings.maxTokensPerChangeBox,
            baseIndex: this.outputs.length + 1
          });
        }
        const chunkedTokens = chunk(
          change.tokens,
          this._settings.maxTokensPerChangeBox
        );
        for (const tokens of chunkedTokens) {
          const output = new OutputBuilder(
            estimateMinBoxValue(),
            this._changeAddress,
            this._creationHeight
          ).addTokens(tokens);
          change.nanoErgs -= output.value;
          changeBoxes.push(output);
        }
      }
      if (change.nanoErgs > _0n) {
        if (some(changeBoxes)) {
          if (this.settings.shouldIsolateErgOnChange) {
            outputs.add(
              new OutputBuilder(change.nanoErgs, this._changeAddress)
            );
          } else {
            const firstChangeBox = first(changeBoxes);
            firstChangeBox.setValue(firstChangeBox.value + change.nanoErgs);
          }
          outputs.add(changeBoxes);
        } else {
          outputs.add(new OutputBuilder(change.nanoErgs, this._changeAddress));
        }
      }
    }
    for (const input of inputs) {
      if (!input.isValid()) {
        throw new InvalidInput(input.boxId);
      }
    }
    const unsignedTransaction = new ErgoUnsignedTransaction(
      inputs,
      this.dataInputs.toArray(),
      outputs.toArray().map(
        (output) => output.setCreationHeight(this._creationHeight, { replace: false }).build(inputs)
      )
    );
    let burning = unsignedTransaction.burning;
    if (burning.nanoErgs > _0n) {
      throw new MalformedTransaction("it's not possible to burn ERG.");
    }
    if (some(burning.tokens) && some(this._burning)) {
      burning = utxoDiff(burning, {
        nanoErgs: _0n,
        tokens: this._burning.toArray()
      });
    }
    if (!this._settings.canBurnTokens && some(burning.tokens)) {
      throw new NotAllowedTokenBurning();
    }
    return unsignedTransaction;
  }
  _isMinting() {
    for (const output of this._outputs) {
      if (output.minting) return true;
    }
    return false;
  }
  _isMoreThanOneTokenBeingMinted() {
    let mintingCount = 0;
    for (const output of this._outputs) {
      if (isDefined(output.minting)) {
        mintingCount++;
        if (mintingCount > 1) return true;
      }
    }
    return false;
  }
  _isTheSameTokenBeingMintedFromOutsideTheMintingBox() {
    const mintingTokenId = this._getMintingTokenId();
    if (isUndefined(mintingTokenId)) return false;
    let count = 0;
    for (const output of this._outputs) {
      if (output.assets.contains(mintingTokenId)) {
        count++;
        if (count > 1) return true;
      }
    }
    return false;
  }
  _getMintingTokenId() {
    let tokenId = void 0;
    for (const output of this._outputs) {
      if (output.minting) {
        tokenId = output.minting.tokenId;
        break;
      }
    }
    return tokenId;
  }
};
function isCollectionLike(obj) {
  return obj.toArray !== void 0;
}
function estimateMinChangeValue(params) {
  const size = BigInt(estimateChangeSize(params));
  return size * BOX_VALUE_PER_BYTE;
}
function estimateChangeSize({
  changeAddress,
  creationHeight,
  tokens,
  baseIndex,
  maxTokensPerBox
}) {
  const neededBoxes = Math.ceil(tokens.length / maxTokensPerBox);
  let size = 0;
  size += estimateVLQSize(SAFE_MIN_BOX_VALUE);
  size += byteSizeOf(changeAddress.ergoTree);
  size += estimateVLQSize(creationHeight);
  size += estimateVLQSize(0);
  size += 32;
  size = size * neededBoxes;
  for (let i = 0; i < neededBoxes; i++) {
    size += estimateVLQSize(baseIndex + i);
  }
  for (const token of tokens) {
    size += byteSizeOf(token.tokenId) + estimateVLQSize(token.amount);
  }
  if (tokens.length > maxTokensPerBox) {
    if (tokens.length % maxTokensPerBox > 0) {
      size += estimateVLQSize(maxTokensPerBox) * Math.floor(tokens.length / maxTokensPerBox);
      size += estimateVLQSize(tokens.length % maxTokensPerBox);
    } else {
      size += estimateVLQSize(maxTokensPerBox) * neededBoxes;
    }
  } else {
    size += estimateVLQSize(tokens.length);
  }
  return size;
}
function SConstant(constant) {
  return constant.toHex();
}
function SParse(bytes) {
  return SConstant$1.from(bytes).data;
}

export { AccumulativeSelectionStrategy, BOX_VALUE_PER_BYTE, BoxSelector, CherryPickSelectionStrategy, CustomSelectionStrategy, DuplicateInputError, DuplicateInputSelectionError, ErgoAddress, ErgoBox, ErgoMessage, ErgoTree, ErgoUnsignedInput, ErgoUnsignedTransaction, FEE_CONTRACT, InputsCollection, InsufficientInputs, InsufficientTokenAmount, InvalidAddress, InvalidInput, InvalidRegistersPacking, MAX_TOKENS_PER_BOX, MalformedTransaction, MaxTokensOverflow, MessageType, NotAllowedTokenBurning, NotFoundError, OutputBuilder, OutputsCollection, RECOMMENDED_MIN_FEE_VALUE, SAFE_MIN_BOX_VALUE, SConstant, SParse, TokensCollection, TransactionBuilder, UndefinedCreationHeight, UndefinedMintingContext, estimateMinBoxValue, validateAddress };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.mjs.map